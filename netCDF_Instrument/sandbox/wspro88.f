C*PCV*$LARGE
C +++++ BEGIN BLOCK #1 OF PC VERSION +++++
C                                     <<<<<SUBPROGRAM *MAIN*>>>>>
C     <<<<<LAST REVISED FOR V060188>>>>>
C
C     .....PREVIOUSLY REVISED FOR V020188.....
C
C          WSPRO   -     U.S.G.S. - F.H.W.A   program   for
C                     'W'ater-'S'urface 'PRO'file computations
C
C          This version, V060188, reflects revisions through
C                            June 1, 1988
C
C
C ********************************************************************
C
C
C          Trivial MAIN Program
C
      COMMON / CHARV  / SECIDV(100)
      COMMON / DRCTRY / NXSECS, MXXSEC, IXTYPV(100),
     $                           IXIERV(100), SRDV(100), WSC(100)
      COMMON / HDGTT1 / NTITLE
      COMMON / HDGTT2 / ITITLE(70,3), IDATE(15), VDATE
      COMMON / HPCOM  / IOPTSA,ELMIN,YINC,ELMAX
      COMMON / IPTCB1 /  IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / JHPARM / DELTAY, YTOL, QTOL, FNTEST
      COMMON / JHPAR2 / IHFNO2
      COMMON / J3COM / IRISKT, MXJ3VN, IVARNO(55), IUDTNO(3)
      COMMON / KQBLK / KQ, XLTKQ, XRTKQ, UZRCOD, UZRBRL, UZRXKQ
      COMMON / LPARMS / ZD1TO2,ZDDTO2,ZD2TO3,ZD3TO4,
     *                  FD1TO2,FDDTO2,FD2TO3,FD3TO4
      COMMON / PCDBLK / NPROF, IPCDIR(20), WSI(20), EGSLPI(20),
     $          QVPOOL(200), NIPC, NWSI, NEGSI, NQV, MXPROF, MXQV
      COMMON /SAPROP/ SAA(20), SAB(20), SAWP(20), SAK(20)
      COMMON / UDTBLK /  LV1,WD1,LV1X,WD1X,LV2X,WD2X,
     1                   LV5X,WD5X,LV4L,WD4X,LV4R
      COMMON /UDTCHR/  FV1,FV1X,FV2X,FV4X,FV5X,
     1                 FH1,FH1X,FH2X,FH4X,FH5X,
     2                 HD1,HD1X,HD2X,HD4X,HD5X
      COMMON / XPARMS / XBR(21), XAS(21), XREFBR
      COMMON / CVAREA / ASUBC, ASUBN, AIN, AOUT
      CHARACTER*8 FV1, FV1X, FV2X, FV4X, FV5X
      CHARACTER*4 HD1,FH1,HD1X,FH1X,HD2X,FH2X,HD4X,FH4X,
     #            HD5X,FH5X
      CHARACTER*60  FNAME,FNAMEB
      DIMENSION LV1(35,3),WD1(35,3),HD1(40,3),FH1(40,3),FV1(40,3),
     1     LV1X( 5,3),WD1X( 5,3),HD1X(10,3),FH1X(10,3),FV1X(10,3),
     2     LV2X(15,3),WD2X(15,3),HD2X(20,3),FH2X(20,3),FV2X(20,3),
     3     LV5X(10,3),WD5X(10,3),HD5X(15,3),FH5X(15,3),FV5X(15,3),
     4     LV4L(15,3),WD4X(15,3),HD4X(20,3),FH4X(20,3),FV4X(20,3),
     5     LV4R(15,3),ISHIFT(5)
      CHARACTER*5 SECIDV,ITITLE*1,IDATE*1,VRSION*7,VDATE*7,VERSN*64
      REAL KQ 
C*PCV* logical there
C*PCV* character*16 fname
      DATA VRSION /'V060188'/
C*PCV* write(*,'(a\)') ' Enter the name of the data file: '
C*PCV* read(*,'(a16)') fname
C*PCV* open(5,file=fname)
C*PCV* write(*,'(a\)') ' Enter the name of the output file: '
C*PCV* read(*,'(a16)') fname
C*PCV* inquire(file=fname,exist=there)
C*PCV* if (there) then
C*PCV* open(6,file=fname)
C*PCV* else
C*PCV* open(6,file=fname,status='NEW')
C*PCV* endif
C*PCV* write(*,'(a\)') ' Enter the name of the input data echo file: '
C*PCV* read(*,'(a16)') fname
C*PCV* inquire(file=fname,exist=there)
C*PCV* if (there) then
C*PCV* open(7,file=fname)
C*PCV* else
C*PCV* open(7,file=fname,status='NEW')
C*PCV* endif
C*PCV* write(*,'(a\)') ' Enter the name of the temporary file #8: '
C*PCV* read(*,'(a16)') fname
C*PCV* inquire(file=fname,exist=there)
C*PCV* if (there) then
C*PCV* open(8,file=fname)
C*PCV* else
C*PCV* open(8,file=fname,status='NEW')
C*PCV* endif
C     ++++++++++++  PROMPTS FOR DATA GENERALS  +++++++++++++++
C
C
      VERSN =
     & '$Id: wspro88.f,v 1.4 1996/01/17 17:54:20 rsregan Exp rsregan $'
C     strings for Unix what command
      versn = 
     &   '@(#)WSPRO - USGS/FHWA Water-Surface PROfile computation model'
      versn = '@(#)WSPRO - FHWA-IP-89-027, J.O. Shearman'
      versn = '@(#)WSPRO - Contact: h2osoft@usgs.gov'
      versn = '@(#)WSPRO - Version: V060188 1.4x 1996/01/17'
   2  WRITE(*,5)
   5  FORMAT(/,/,' Enter the name of the data file: '$)
      READ(*,1) FNAME
      LEN=INDEX(FNAME,' ')
      WRITE(*,6)
   6  FORMAT(/,/,' Enter the name of the output file: '$)
      READ(*,1)FNAMEB
      WRITE(*,7)
   7  FORMAT(/,/)
      LENB=INDEX(FNAMEB,' ')
   1  FORMAT(A)
      OPEN(5,FILE=FNAME(1:LEN),STATUS='OLD',ERR=3)
      OPEN(6,FILE=FNAMEB(1:LENB),STATUS='UNKNOWN')
      OPEN(7,FILE='ECHO1',STATUS='UNKNOWN')
      OPEN(8,FILE='TEMP1',STATUS='UNKNOWN')
      GOTO 4
   3  PRINT*,' '
      PRINT*,'    ***   B A D     D A T A     F I L E   ***'
      PRINT*,' '
   4  VDATE = VRSION
      CALL  MAIN1
      STOP  2
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #2 OF PC VERSION +++++
C                                     <<<<<SUBPROGRAM MAIN1 >>>>>
C     <<<<<LAST REVISED 01-06-88>>>>>
C
      SUBROUTINE   MAIN1
C
C          MAIN1 DOES GLOBAL STORAGE ALLOCATION, THEN CALLS MAIN2
C          TO PROCESS THE INPUT DATA AND PASS THOSE DATA TO THE
C          PROFILE COMPUTATION ROUTINES.
C
C          GLOBAL  STORAGE  AREAS, CROSS-SECTION DATA -- XPOOL
C          STORES DATA FOR UP TO FIVE CROSS SECTIONS; WORK IS A
C          'SCRATCH' ARRAY.  THESE ARRAYS ARE USED BY MANY LOWER
C          LEVEL PROCESSING ROUTINES (PASSED VIA ARGUMENT LIST).
C          DATA LAYOUT DOCUMENTED IN THE PROGRAMMERS MANUAL.
C
      DIMENSION XPOOL(420,5), WORK(420)
C
C          POINTERS TO SUBDIVISIONS OF CROSS-SECTION DATA RECORD
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
C          MISCELLANEOUS JOB PARAMETERS -- USED IN FRICTION-LOSS
C          COMPUTATIONS AND IN BALANCING THE ENERGY EQUATION.
C          NON-DEFAULT VALUES INPUT VIA J1 DATA RECORD.  DEFAULT
C          VALUES ARE INITIALIZED BELOW.  JHPARM IS PASSED TO
C          PROFILE COMPUTATION ROUTINES.  JHPAR2 IS USED ONLY IN
C          PREPARING CROSS-SECTION DATA RECORDS.
C
      COMMON / JHPARM / DELTAY, YTOL, QTOL, FNTEST
      COMMON / JHPAR2 / IHFNO2
C
C          CROSS SECTION DIRECTORY DATA -- USED BY INPUT UTILITY
C          AND PROFILE COMPUTATION ROUTINES.
C
      COMMON / CHARV  / SECIDV(100)
      COMMON / DRCTRY / NXSECS, MXXSEC, IXTYPV(100),
     $                           IXIERV(100), SRDV(100), WSC(100)
C
      CHARACTER*5 SECIDV,ITITLE*1,IDATE*1,VDATE*7
C
C          PROFILE-CONTROL DATA -- USED BY ROUTINES QFUNCT,
C          PRCOMP, PRCPCD, AND PROFILE COMPUTATION ROUTINES.
C
      COMMON / PCDBLK / NPROF, IPCDIR(20), WSI(20), EGSLPI(20),
     $          QVPOOL(200), NIPC, NWSI, NEGSI, NQV, MXPROF, MXQV
C
C          TABLING DATA -- RISK-TABLE OPTION AND VARIABLE CODE
C          NUMBERS FOR USER-DEFINED TABLE.  INITIALIZED TO NULL
C          VALUES BELOW, DESIRED VALUES INPUT VIA J3 DATA RECORD.
C          USED IN TABLING ROUTINES CALLED FROM PROFILE
C          COMPUTATION ROUTINES.
C
      COMMON / J3COM / IRISKT, MXJ3VN, IVARNO(55), IUDTNO(3)
C
C          CROSS-SECTION PROPERTIES PARAMETERS -- USED IN THE
C          HPTABLE ROUTINE.
C
      COMMON / HPCOM / IOPTSA, ELMIN, YINC, ELMAX
C
C          USER-SUPPLIED TITLES (T1,T2,T3 RECORDS) FOR OUTPUT --
C          USED BY HDGPRT,  STORED BY HDGSTO.
C
      COMMON / HDGTT1 / NTITLE
      COMMON / HDGTT2 / ITITLE(70,3), IDATE(15), VDATE
C
C  ..............................................................
C
C          STORAGE ALLOCATION IN XPOOL
C
      DATA  NXPOOL,MXCON0,MXGP,MXSA,MXRD,MXFL,MXPA,MXCON1,MXCON2
     $    /  420,     6,  100,  20,   2,   3,  25,   30,    15 /
C
      CALL IPTSET (MXCON0, MXGP, MXSA, MXRD, MXFL, MXPA,
     $                                    MXCON1, MXCON2, NXPOOL)
C
      NTITLE = 0
      NXSECS = 0
      NPROF = 0
      NQV = 0
C
      MXXSEC = 100
      MXPROF = 20
      MXQV = 200
C
      MXJ3VN = 55
      IRISKT = 0
      IVARNO(1) = 0
      IVARNO(2) = 0
C
      DELTAY = 1.00
      YTOL = 0.02
      QTOL = 0.02
      FNTEST = 0.8
      IHFNO2 = -1
C
      IOPTSA = 0
      ELMIN = -1.0E30
      ELMAX = 1.0E30
      YINC = DELTAY
C
C  INITIALIZE PROPAGATING SCALAR COEFFS
      XPOOL(IPTMSC,1) = -1.1E32
      XPOOL(IPTMSC+1,1) = 0.0
      XPOOL(IPTMSC+2,1) = 0.0
      XPOOL(IPTMSC+3,1) = 0.5
      XPOOL(IPTMSC+4,1) = 0.0
      XPOOL(IPTMSC+5,1) = -1.1E32
C
      CALL DAFOPE
      CALL MAIN2 ( XPOOL , WORK )
C
      CLOSE(5,STATUS='KEEP')
      CLOSE(6,STATUS='KEEP')
      CLOSE(7,STATUS='DELETE')
      CLOSE(8,STATUS='DELETE')
      CLOSE(13,STATUS='DELETE')
      CLOSE(14,STATUS='DELETE')
      STOP
      END
C                                     <<<<<SUBPROGRAM IPTSET>>>>>
C     <<<<<LAST REVISED 08-07-86>>>>>
C
      SUBROUTINE   IPTSET ( MXCON0, MXGP, MXSA, MXRD, MXFL,
     $                               MXPA, MXCON1, MXCON2, NDIM )
C
C          THIS ROUTINE IS CALLED ONCE FROM MAIN1 TO SET THE
C          POINTERS TO SUBDIVISIONS OF XPOOL, THE COMPOSITE CROSS
C          SECTION DATA ARRAY.  POINTER VALUES ARE STORED IN
C          COMMON FOR USE BY PROCESSING ROUTINES.  THE ARGUMENTS
C          (INITIALIZED IN MAIN1) ARE:
C
C          MXCON0   - NUMBER OF DATA COUNTERS
C          MXGP     - MAX NUMBER OF GROUND POINTS
C          MXSA     - MAX NUMBER OF SUBAREAS
C          MXRD     - MAX NUMBER OF ROUGHNESS DEPTHS
C          MXFL     - MAX NUMBER OF FLOW-LENGTH SUBDIVISIONS
C          MXPA     - MAX NUMBER OF PIER-AREA-ELEVATION POINTS
C          MXCON1,2 - MAX NUMBER OF MISC CONSTANTS
C          NDIM     - DIMENSION OF XPOOL ARRAY, CHECKED AGAINST
C                     TOTAL SIZE DETERMINED BY OTHER ARGUMENTS.
C                     PGM HALTS WITH STOP 643 IF NDIM TOO SMALL.
C
C          THE SECTION REFERENCE DISTANCE (SRD) IS STORED
C          IN XPOOL(IPTMSC+0)
C
      COMMON  / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                     IPTABG, IPTEND
C
      IPTXY = MXCON0
      IPTRGH = IPTXY + 2*(MXGP + 4) + 2
      IPTFL = IPTRGH + MXSA + 2*MXSA*MXRD
      IPTMSC = IPTFL + 2*MXFL + 1
      IPTPEA = IPTMSC + MXCON1
      IPTABG = IPTPEA + 2*MXPA
      IPTEND = IPTABG + MXCON2
      IF(IPTEND.GT.NDIM) STOP 643
      IPTEND = NDIM
      RETURN
      END
C                                     <<<<<SUBPROGRAM MAIN2 >>>>>
C     <<<<<LAST REVISED 11-04-86>>>>>
C
      SUBROUTINE   MAIN2 ( XPOOL , WORK )
C
C          TOP-LEVEL EXECUTIVE ROUTINE FOR WSPRO -- INPUT DATA
C          COLLECTION AND INTERPRETATION DATA.
C    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C    JOS.MOD 11/86 - TO GET YMAX VALUE IN TEMPLATE VECTOR, THUS
C         ENABLING VERTICAL WALLS AT XLIML/XLIMR TO BE EXTENDED
C         SUFFICIENTLY HIGH FOR SUBSEQUENT COMPUTATIONS
C    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      COMMON /IPTCB1/  IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                            IPTABG, IPTEND
      CHARACTER*5 SECIDV(3)
      CHARACTER*1 ICDBUF
C
      DIMENSION  ICDBUF(70), INSWAP(6),BINBUF(1),
     $                          XPOOL(IPTEND,5), WORK(IPTEND)
      INTEGER ITYPE, JTYPE, IOPT, NBIN
      CHARACTER*3 KARDID, KFOPT
C
C  LOGICAL UNIT NUMBERS, ETC.
      DATA  INSWAP  / 5, 80, 1,  5, 80, 1 /
      DATA   MSG / 6 /
C
C  *** CHARACTER DATA ...
      DATA SECIDV/' ',' ',' '/
C
      IERGBL = 0
      ISW600 = 0
      CALL HDGPRT (MSG)
      CALL HDGDAT
C
  910 CONTINUE
C
      CALL GETLIN (INSWAP, ITYPE, JTYPE, KARDID, KFOPT,
     $               IOPT, SECIDV(1), ICDBUF, NBIN, XPOOL(1,5), IER)
C
  912 CONTINUE
C
      IF ( IER .EQ. 1 )  IERGBL = 1
      IF ( ITYPE.GT.0)  GO TO 920
      WRITE(MSG,911)
  911 FORMAT (/'1  NORMAL  END  OF  WSPRO  EXECUTION.')
      RETURN
C
  920 CONTINUE
C
      GO TO ( 100, 200, 300, 400, 500, 600 ), ITYPE
C
      WRITE(MSG,931)  ITYPE
  931 FORMAT(' +++001 CARD TYPE OUT OF ORDER IGNORED.',I6 /)
      IERGBL = 1
      GO TO 910
C
C  TITLE CARDS
C
  100 CALL HDGSTO (ICDBUF, JTYPE)
      GO TO 910
C
C  J-CARDS
C
  200 CALL PRCJXX (IOPT, NBIN, XPOOL(1,5), JTYPE, INSWAP)
      GO TO 910
C
C  CROSS-SECTION HEADER CARDS
C
  300 CONTINUE
      CALL HDGPRT (MSG)
      IERXS = 0
      IF ( IER.GE.2 ) IERXS = 1
      SECIDV(2) = SECIDV(1)
      IXTYPE = JTYPE
      LTYPE  = 0
      WRITE(MSG,307) SECIDV(2)
  307 FORMAT(/' *** START PROCESSING CROSS SECTION - "',A5,'"')
      WRITE(MSG,112) KARDID, KFOPT, SECIDV(1), ICDBUF
  112 FORMAT (3X,A2,A3,A5,70A1)
      CALL XSINIT (IXTYPE, IOPT, NBIN, XPOOL(1,5), XPOOL,
     $                                       IPOINT, IERXS, SRD)
  330 CONTINUE
      CALL GETLIN (INSWAP, ITYPE, JTYPE, KARDID, KFOPT,
     $             IOPT, SECIDV(1), ICDBUF, NBIN, XPOOL(1,5), IER)
      IF (ITYPE.NE.7)  GO TO 370
      IF (IER.NE.0)  IERXS = 1
      IF (SECIDV(1).EQ.SECIDV(3) .OR. SECIDV(1).EQ.SECIDV(2)) GO TO 347
      IERXS = 1
      WRITE(MSG,343) SECIDV(1), SECIDV(2)
  343 FORMAT(' +++002 SECID MISMATCH -  "',A5,'" AND "',A5,'"')
      GO TO 370
  347 CONTINUE
C
      CALL XSFILL (IXTYPE, JTYPE, LTYPE,
     #   IOPT, NBIN, XPOOL(1,5), XPOOL(1,IPOINT), IERXS)
      LTYPE = JTYPE
      GO TO 330
C
  370 CONTINUE
C
C  FINISH UP CONSTRUCTION OF X-SEC DATA RECORD
C     AND STORE ON D.A.F.  OR  TEMPLATE.
C
      WRITE(MSG,371) SECIDV(2)
  371 FORMAT(/' *** FINISH PROCESSING CROSS SECTION - "',A5,'"')
C  - - - - - BEGIN JOS.MOD 11/86 - - - - -
      IF(IXTYPE.NE.9) CALL XSWRAP (IXTYPE, IERXS,
     $                                    SECIDV(2), XPOOL, SRD)
C
      IF( IXTYPE. EQ. 9 ) THEN
        NGP2 = XPOOL(1,IPOINT)
        CALL XYMNMX ( XPOOL(IPTXY+1,IPOINT), NGP2 )
        WRITE(MSG,373) SECIDV(2)
 373    FORMAT(' *** TEMPLATE CROSS SECTION "',A5,
     $                                    '" SAVED INTERNALLY.')
      ELSE
        IF( IXTYPE .NE. 6 ) IPOINT = 1
        CALL XSSAVE ( IXTYPE, IERXS*10+IERGBL,
     $                         SECIDV(2), XPOOL(1,IPOINT), SRD )
      ENDIF
C
C  - - - - - END JOS.MOD 11/86 - - - - -
      IERGBL = 0
      IF(IXTYPE.EQ.9.OR.(100*ITYPE+JTYPE.EQ.401.AND.
     $       SECIDV(1).EQ.SECIDV(3)))  GO TO 375
      CALL PRCCMD (1, 9, 0, XPOOL(1,5), SECIDV, WORK)
  375 CONTINUE
      GO TO 912
C
C  CROSS SECTION DISPLAY COMMANDS
C
  400 CONTINUE
      CALL PRCCMD (JTYPE, IOPT, NBIN, XPOOL(1,5), SECIDV, WORK)
      GO TO 910
C
C  PROFILE-CONTROL DATA
C
  500 CONTINUE
      IF(ISW600.EQ.0) GO TO 510
      WRITE(MSG,513)
  513 FORMAT(' +++003 ORDER:  NO PROFILE CONTROL DATA CHANGES ',
     $            'AFTER "EX" RECORD.')
      JTYPE = -99
510   CONTINUE
      CALL PRCPCD (JTYPE, IOPT, NBIN, XPOOL(1,5), SECIDV)
      GO TO 910
C
C  COMPUTE PROFILE
C
  600 CONTINUE
      ISW600 = 1
      CALL PRCOMP (JTYPE, IOPT, NBIN, XPOOL(1,5), XPOOL)
      GO TO 910
      END
      SUBROUTINE HDGSTO(ICDBUF, JTYPE)
C
C        HDGSTO MOVES TITLE INFO FROM ICDBUF TO TITLE ARRAY
C
      COMMON / HDGTT1 / NTITLE
      COMMON / HDGTT2 / ITITLE(70,3), IDATE(15), VDATE
      CHARACTER*1 ITITLE, ICDBUF, IDATE, VDATE*7
      DIMENSION ICDBUF(70)
C
      IF( JTYPE .LE. 0  .OR.  JTYPE .GT. 3 )  STOP 644
C
      NTITLE = JTYPE
      DO 10 I = 1,70
      ITITLE(I,NTITLE) = ICDBUF(I)
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE HDGDAT
C
C             HDGDAT GETS TIME AND DATE OF RUN
C
      COMMON / HDGTT1 / NTITLE
      COMMON / HDGTT2 / ITITLE(70,3), IDATE(15), VDATE
      CHARACTER*1 ITITLE, IDATE, BLANK, VDATE*7
C
      DATA BLANK / ' ' /
C
      DO 10 I = 1,15
      IDATE(I) = BLANK
   10 CONTINUE
C
      CALL DATTIM (IDATE)
C
      WRITE(6,907) IDATE
  907 FORMAT(12X,'*** RUN DATE & TIME: ',15A1/' ')
C
      RETURN
      END
      SUBROUTINE HDGPRT(MSG)
C
C        HDGPRT PRINTS PAGE HEADING AND TITLES.
C
      COMMON / HDGTT1 / NTITLE
      COMMON / HDGTT2 / ITITLE(70,3), IDATE(15), VDATE
      CHARACTER*1 ITITLE, IDATE, VDATE*7
      WRITE(MSG,111) VDATE
  111 FORMAT('1'/' WSPRO         FEDERAL HIGHWAY ADMINISTRATION - ',
     $  'U. S. GEOLOGICAL SURVEY'/1X, A7 ,11X, 'MODEL  FOR  ',
     $  'WATER-SURFACE  PROFILE  COMPUTATIONS'/)
      IF( NTITLE .LE. 0 ) GO TO 500
      IF( NTITLE .GT. 3 ) STOP 644
      WRITE(MSG,112) ((ITITLE(I,J),I=1,70),J=1,NTITLE)
  112 FORMAT(9X,70A1)
      WRITE(MSG,907) IDATE
  907 FORMAT(12X,'*** RUN DATE & TIME: ', 15A1)
C
  500 RETURN
      END
      SUBROUTINE DAFOPE
C
C   DIRECT ACCESS FILE MANAGER
C
      OPEN (13,ACCESS='DIRECT',RECL=1680)
      RETURN
      END
      SUBROUTINE  DAFIN(ISEQ,XPOOL)
      COMMON  / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                     IPTABG, IPTEND
      DIMENSION XPOOL(IPTEND)
      READ(13,REC=ISEQ) (XPOOL(I), I = 1, IPTEND)
      RETURN
      END
      SUBROUTINE DAFOUT(ISEQ,XPOOL)
      COMMON  / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                     IPTABG, IPTEND
      DIMENSION XPOOL(IPTEND)
      WRITE(13,REC=ISEQ) (XPOOL(I), I = 1, IPTEND)
      RETURN
      END
      SUBROUTINE DAFZIP(XPOOL)
C
C   FILLS XPOOL WITH NULL VALUES
C
      COMMON  / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                     IPTABG, IPTEND
      DIMENSION XPOOL(IPTEND)
C
      DO 10 I = 1,IPTEND
      XPOOL(I) = -1.1E32
   10 CONTINUE
C
      RETURN
      END
      SUBROUTINE GETLIN (INSWAP, ITYPE, JTYPE, KARDID, KFOPT,
     $                    IOPT, SECID, ICDBUF, NBIN, BINBUF, IER)
C
C   GETS VALID INPUT LINE FROM INPUT DEVICE.
C   CARD TYPE, OPTION FIELD, AND SECTION-ID ARE PICKED OUT.
C   NUMERIC DATA FIELD IS CONVERTED TO BINARY.
C
C   IER = SUM OF ERROR CODES --- 2=UNRECOGNIZED CARD TYPE SKIPPED
C     1=INVALID OPTION CHARACTER IOPT=-1,  4=INVALID NUMERIC DATA
C     IN BINBUF   8 = CONTINUATION ERROR    0=NO ERROR.
C
C     AT EOF, INPUT SWAPS BACK TO PRIMARY CARD READER,
C       IF SET ON AUX INPUT.  AT EOF ON PRIMARY CARD READER,
C      ITYPE AND JTYPE ARE RETURNED AS 0 (IER IS NOT SET).
C
C  REV 9/83 WK --  ANY TRAILING NULL VALUES (.LE.-1E32) ARE DEDUCTED
C    FROM NBIN COUNT.  NULL VALUES FOLLOWED BY NON-NULL VALUES ARE
C    INCLUDED IN NBIN COUNT.   SEE LABEL 435.
C
C  REV 4/84 WK -- TO WRITE UNANNOTATED COPY OF INPUT CARDS ON UNIT MSG7.
C
      DIMENSION  INSWAP(6),  BINBUF(1)
C
C  *** CHARACTER DATA TYPES DEFINED NEXT 5 LINES ****
      CHARACTER*1  ICDBUF(70)
      CHARACTER*5  SECID, SECID2, DBLANK*1
      DOUBLE PRECISION CVTAD2
      CHARACTER*3  KFOPT, KARDID, KARDI2, IBLANK*1, ICOMMA*1
      CHARACTER*2 ISTAR,IPLUS
      DATA  ISTAR /'* '/, IPLUS/'+ '/, IBLANK/' '/, DBLANK/' '/
      DATA ICOMMA /','/
C
      DATA  MXBIN / 400 /
C         (BASED ON XPOOL DIMENSION)
      DATA  MSG  / 6 /,   MSG7 / 7 /
C
      IER = 0
C
  100 CONTINUE
      INU = INSWAP(1)
      LRECL = INSWAP(2) - 10
      IF(LRECL.GT.70)  STOP 807
C
  110 CONTINUE
      READ(INU,111,END=777) KARDID,KFOPT,SECID,ICDBUF
      WRITE(MSG7,111) KARDID,KFOPT,SECID,ICDBUF
  111 FORMAT( A2, A3, A5, 70A1 )
      IF (KARDID.EQ.ISTAR)
     *     WRITE(MSG,112) KARDID,KFOPT,SECID,ICDBUF
      IF (KARDID.EQ.ISTAR) GO TO 110
C
      ITYPE  =  ICDTYP(KARDID)
      IF(ITYPE/100.NE.3)
     *     WRITE(MSG,112) KARDID,KFOPT,SECID,ICDBUF
  112 FORMAT( 3X, A2,A3,A5,70A1)
      IF ( ITYPE .GE. 0 )  GO TO 140
      IF(KARDID.EQ.IPLUS) WRITE(MSG,136)
  136 FORMAT(' +++004 UNEXPECTED CONTINUATION RECORD SKIPPED.')
      IF(KARDID.NE.IPLUS) WRITE(MSG,133) KARDID
  133 FORMAT
     $  (' +++005 IGNORED UNRECOGNIZED RECORD TYPE - "',A2,'"')
      IER = 2
      GO TO 110
C
  140 CONTINUE
      JTYPE = MOD(ITYPE,100)
      ITYPE = ITYPE/100
      IOPT = ICDOPF(KFOPT)
      IF(IOPT.LT.0)  IER = IER + 1
      IF(IOPT.LT.0)WRITE(MSG,147)KFOPT
  147 FORMAT
     $  (' +++006 INVALID CHARACTERS IN OPTION FIELD - "',A3,'"')
C
      NBIN = 0
      BINBUF(1) = -1.1E32
C
      IF( ITYPE .EQ. 1 )   RETURN
C
  400 CONTINUE
  410 IPT = 1
      ICH=0
  420 WORK = CVTAD2(ICDBUF,LRECL, ICH,ICODE)
      IPT = ICH + 1
      IF(ICODE.EQ.2.OR.ICODE.EQ.3) GO TO 610
C
      NBIN = NBIN + 1
      IF(NBIN.LE.MXBIN)  GO TO 430
      WRITE(MSG,417)NBIN,MXBIN,IPT
  417 FORMAT(' +++007 DATA COUNT EXCEEDS ALLOWABLE MAXIMUM:'/
     $    15X,'FOUND -',I5,'  MAX -',I5,'  COL# -',I5)
      NBIN = NBIN - 1
      GO TO 670
  430 BINBUF(NBIN) = WORK
      IF(ICODE.EQ.5 .OR. ICODE.EQ.6)  GO TO 450
      IF(IPT.LE.LRECL) GO TO 420
  435 IF(NBIN.LE.0)  RETURN
      IF(BINBUF(NBIN).GT.-1E32)  RETURN
      NBIN = NBIN - 1
      GO TO 435
C
  450 CONTINUE
      READ(INU,111,END=767) KARDI2,KFOPT,SECID2,ICDBUF
      WRITE(MSG7,111) KARDI2,KFOPT,SECID2,ICDBUF
      WRITE(MSG,112) KARDI2,KFOPT,SECID2,ICDBUF
      IF(KARDI2.NE.KARDID.AND.KARDI2.NE.IPLUS) GO TO 620
      IF(KFOPT.NE.IBLANK.OR.SECID2.NE.DBLANK) GO TO 630
      GO TO 410
C
  610 IPT = IPT + 10
      IER = IER + 4
      WRITE(MSG,612)IPT
  612 FORMAT(' +++008 INVALID DATA NEAR COLUMN ',I3)
      GO TO 670
  620 WRITE(MSG,768)
      IER = IER + 8
      GO TO 670
  630 WRITE(MSG,633)
  633 FORMAT(' +++009 INVALID CONTINUATION, COLUMNS 3-10',
     $    ' MUST BE BLANK.')
      IER = IER + 8
      GO TO 670
  670 CONTINUE
      I = LRECL
  675 IF(ICDBUF(I).NE.IBLANK) GO TO 680
      I = I - 1
      IF(I.GT.1) GO TO 675
  680 IF(ICDBUF(I).NE. ICOMMA)  RETURN
      READ(INU,111,END=767) KARDI2,KFOPT,SECID2,ICDBUF
      WRITE(MSG,112) KARDI2,KFOPT,SECID2,ICDBUF
      WRITE(MSG,683)
  683 FORMAT(' +++010 CONTINUATION CARD FLUSHED.')
      GO TO 670
C
  767 CONTINUE
      IER = IER + 8
      WRITE(MSG,768)
  768 FORMAT(' +++011 EXPECTED CONTINUATION NOT FOUND.')
      IF(INU.EQ.INSWAP(4)) GO TO 763
      DO 761 I=1,3
  761 INSWAP(I) = INSWAP(I+3)
      WRITE(MSG,776)
      RETURN
  763 WRITE(MSG,775)
      STOP 763
  777 CONTINUE
      IF ( INU .EQ. INSWAP(4) )  GO TO 778
      DO 779 I=1,3
  779 INSWAP(I) = INSWAP(I+3)
      WRITE(MSG,776) INU
  776 FORMAT('      END OF FILE ON AUX INPUT UNIT ',I3/)
      GO TO 100
  778 WRITE(MSG,775) INU
  775 FORMAT(6X,'END OF FILE ON PRIMARY INPUT UNIT ',I3 / )
      ITYPE = 0
      JTYPE = 0
      RETURN
C
      END
      FUNCTION ICDTYP(KARDID)
C
C  LOOKS UP NUMERIC CARD CODE CORRESPONDING TO ALPHA KARDID FIELD.
C     IF NO MATCH, RETURNS -1.
C
C     ALSO, IF KARDID .EQ. 'CHK',  PRINTS LIST OF ALL
C     DEFINED CARD TYPES AND CODES ON LOGICAL UNIT MSG.
C
      DIMENSION  IVCIDL(42),  ITYPEL(42)
      CHARACTER*3 IOPT2,KARDID,IVCIDL
C
      DATA  MSG / 6 /,  IOPT2 / 'CHK'  /
C
C  VALID CARD-IDS AND ITYPE CODES
      DATA  NVTYPE / 42 /
      DATA  IVCIDL  /
     $    'T1', 'T2', 'T3', 'J1', 'J2', 'J3',
     $    'XT', 'XS', 'BR', 'SD', 'XR', 'AS', 'CV',
     $    'GR', 'NV', 'N ', 'SA', 'ND', 'FL', 'GT', 'RG', 'BP',
     $    'BL', 'PW', 'AB', 'BD', 'LC', 'CD', 'PG', 'KD',
     $    'CG', 'CC',
     $    'DP', 'HP', 'PX',
     $    'WS', 'SK', 'Q ',
     $    'ES', 'EX', 'EJ', 'ER'  /
      DATA  ITYPEL /
     $     101,  102,  103,  201,  202,  203,
     $     309,  301,  302,  303,  304,  305,  306,
     $     701,  702,  702,  703,  704,  705,  706,  707,  708,
     $     711,  712,  713,  714,  715,  716,  717,  718,
     $     728,  729,
     $     401,  402,  403,
     $     501,  502,  503,
     $     602,  601,  600,  0   /
C
      DO 10 I=1,NVTYPE
      IF( KARDID .EQ. IVCIDL(I) )   GO TO 20
   10 CONTINUE
      ICDTYP = -1
      IF(KARDID.EQ.IOPT2)WRITE(MSG,17)NVTYPE,(ITYPEL(I),
     $              IVCIDL(I), I=1,NVTYPE)
  17  FORMAT(//' ICDTYP -- LIST OF VALID CARD TYPES AND CODES -- ',
     $              I5 / 6(I6,1X,A3) )
      RETURN
C
   20 ICDTYP = ITYPEL(I)
      RETURN
C
      END
      FUNCTION ICDOPF (KFOPT)
C
C  CHECKS FOR VALID OPTION FIELD -- BLANK COLS 3 AND 5,
C     NUMERIC DIGIT OR BLANK COL 4.   IF NOT, RETURNS -1.
C
      CHARACTER*3  KFOPTL(11),KFOPT
      DATA  KFOPTL/' 1 ',' 2 ',' 3 ',' 4 ',
     $       ' 5 ',' 6 ',' 7 ',' 8 ',' 9 ',' 0 ','   '/
C
      ICDOPF = -1
      DO 10 I=1,11
      IF ( KFOPT .EQ. KFOPTL(I) )   GO TO 20
   10 CONTINUE
      RETURN
C
   20 ICDOPF = I
      IF ( ICDOPF .GT. 9 )  ICDOPF = 0
      RETURN
      END
C                                     <<<<<SUBPROGRAM CVTAD2>>>>>
C     <<<<<LAST REVISED 11-04-86>>>>>
C
      FUNCTION     CVTAD2 (LIT, MXCH, ICH, ICODE)
C
C  CONVERT LITERAL DATA (INPUT VIA 70A1 FORMAT) TO DOUBLE
C       PRECISION VALUES.  ALSO RETURNS CHARACTER COUNT, ICH,
C       AND RESULT CODE, ICODE, WHERE ICODE VALUES ARE:
C       0 = GENERAL REAL,  1 = UNSIGNED INTEGER,  2 = NULL DATA
C       (FIRST CHAR NOT NUMERIC),  3 = INVALID CHAR IN NUMERIC
C       FIELD,  4 = ALL-BLANK FIELD IN LIT ARRAY (NULL DATA),
C       5,6 = LAST NON-BLANK CHAR IN LIT FIELD IS TRAILING COMMA
C       (AFTER REAL OR INT, ICODE = 0 OR 1 + 5).
C
C   AUTOMATICALLY SKIPS LEADING AND TRAILING BLANKS AND COMMA,
C        IF ANY.  THUS, FINDS THE NUMBER, CONVERTS IT, AND
C        ADVANCES TO THE NEXT NUMBER.  ALSO RECOGNIZES A  NULL
C        DATA FIELD (A TRAILING COMMA WITH NOTHING BUT POSSIBLE
C        BLANKS IN FRONT OF IT) AS A VALID 'NUMERIC' NULL VALUE
C        WITH ICODE = 0.  RECOGNIZES ASTERISK * IN THE SAME WAY.
C
C  MXCH = MAX NBR OF CHAR TO CONVERT
C
C  ADAPTED FROM CVTAD/*** HARRIS ***   -- WK, 11/82.
C
C  MODIFIED 10/85 BY JOS FOR BETTER TRANSPORTABILITY AMONG
C       DIFFERENT HARDWARE (INCLUDING PERSONAL COMPUTERS).
C       INTERNAL MACHINE ARITHMETIC REPLACED BY TWO FUNCTION
C       SUBROUTINES (INTVAL AND DPVAL) TO OBTAIN INTEGER AND
C       DOUBLE PRECISION VALUES, RESPECTIVELY, OF SINGLE-
C       CHARACTER (A1) DIGITS.
C
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  JOS.MOD 11/86 - REMOVED SUBSCRIPT COMPUTATIONS FROM WRITE
C       STATEMENT (PROBLEM USING AMDAHL COMPILER - WISCONSIN)
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
      DIMENSION LIT(70)
C
      CHARACTER*6 DMSG(6)
      CHARACTER*1 LIT, IBLANK, IQUOTE, ILIMIT,
     $     ICOMMA, IPLUS, IMINUS, IDECPT,
     $     IE, ID, IBPLUS, ISTAR, IX, NXTCH
C
      DOUBLE PRECISION CVTAD2, DISCNT, DNULL, DPVAL,  POWER,
     $                                      TENTO(10), TENTEN(4)
      EQUIVALENCE (POWER,DISCNT)
      LOGICAL NUMER, LPLUS, LPORM, LEORD
C
      DATA    DNULL, IBLANK, IQUOTE, ILIMIT, ICOMMA  /
     $     -1.01D+37,  ' ' , '''',   '$',   ','   /
      DATA IPLUS, IMINUS, IDECPT,  IE,   ID, IBPLUS, ISTAR /
     $      '+',    '-',    '.',  'E',  'D',  '&' ,   '*' /
      DATA TENTO / 1D0, 1D1, 1D2, 1D3, 1D4, 1D5, 1D6, 1D7,
     $                                               1D8, 1D9 /
      DATA TENTEN / 1D0, 1D10, 1D20, 1D30 /
      DATA MAXPOW / 38 /
      DATA DMSG / 'CHARAC' ,'MAGNIT' ,'INTEGR' ,'FRACTN',
     $                                      'EXPONT' ,'EXPONT'/
      DATA MSG / 6 /
C
C          STATEMENT FUNCTIONS
C
      NUMER(IY) = IY .NE. 10
      LPLUS(IX) = IX .EQ. IPLUS  .OR.  IX .EQ. IBPLUS
      LPORM(IX) = IX .EQ. IMINUS  .OR.  LPLUS(IX)
      LEORD(IX) = IX .EQ. IE  .OR.  IX .EQ. ID
C
C          SKIP LEADING BLANKS
C
      CVTAD2 = DNULL
      ICODE = 4
   10 IF( ICH .GE. MXCH ) RETURN
      ICH = ICH + 1
      IF( LIT(ICH) .EQ. IBLANK)  GO TO  10
C
C          INITIALIZE
C
      CVTAD2=0D0
      ISIGN=0
      ICODE=0
C
C          ANALYZE FIRST CHAR
C
      NXTCH = LIT(ICH)
      INTGR = INTVAL(NXTCH)
      IF( NUMER(INTGR) ) GO TO 200
      IF( LPORM(NXTCH) ) GO TO 100
      IF( NXTCH .EQ. IDECPT ) GO TO 300
C
C          OTHERWISE NULL DATA
C
      CVTAD2 = DNULL
      IF ( NXTCH .EQ. ICOMMA ) GO TO 860
      IF ( NXTCH .EQ. ISTAR  ) GO TO 820
C
C          ELSE FIRST CHAR IS NONNUMERIC
C
      ICH = ICH - 1
      ICODE = 2
      RETURN
C
C          SIGN CHAR
C
  100 CONTINUE
      IF( NXTCH .EQ. IMINUS ) ISIGN = -1
      ICH = ICH + 1
      NXTCH = ILIMIT
      IF( ICH .LE. MXCH ) NXTCH = LIT(ICH)
      INTGR = INTVAL(NXTCH)
      IF( NUMER(INTGR) ) GO TO 200
      IF( NXTCH .EQ. IDECPT ) GO TO 300
      IER = 1
      GO TO 900
C
C          INTEGER PART
C
  200 CONTINUE
  210 CVTAD2 = 1D1 * CVTAD2 + DPVAL(NXTCH)
      ICH = ICH + 1
      NXTCH = ILIMIT
      IF( ICH .LE. MXCH ) NXTCH = LIT(ICH)
      INTGR = INTVAL(NXTCH)
      IF( NUMER(INTGR) ) GO TO 210
      IF( NXTCH .EQ. IDECPT ) GO TO 300
      IF( LEORD(NXTCH) .OR. LPORM(NXTCH) ) GO TO 400
      ICODE = 1
      GO TO 800
C
C          FRACTION
C
  300 CONTINUE
      ICH = ICH + 1
      NXTCH = ILIMIT
      IF( ICH .LE. MXCH ) NXTCH = LIT(ICH)
      INTGR = INTVAL(NXTCH)
      IF( NUMER(INTGR) ) GO TO 310
      IF( CVTAD2 .NE. DNULL ) GO TO 350
      IER = 2
      GO TO 900
  310 DISCNT = 1D0
  320 DISCNT = 1D - 1 * DISCNT
      CVTAD2 = CVTAD2 + DPVAL(NXTCH) * DISCNT
      ICH = ICH + 1
      NXTCH = ILIMIT
      IF( ICH .LE. MXCH ) NXTCH = LIT(ICH)
      INTGR = INTVAL(NXTCH)
      IF( NUMER(INTGR) ) GO TO 320
  350 CONTINUE
      IF( LEORD(NXTCH) .OR. LPORM(NXTCH) ) GO TO 400
      IF( NXTCH .NE. IDECPT ) GO TO 800
      IER = 2
      GO TO 900
C
C          EXPONENT
C
  400 CONTINUE
      IPSIGN = 1
      IF( NXTCH .EQ. IMINUS ) GO TO 410
      IF( LPLUS(NXTCH) ) GO TO 420
      ICH = ICH + 1
      NXTCH = ILIMIT
      IF( ICH .LE. MXCH ) NXTCH = LIT(ICH)
      IF( NXTCH .EQ. IMINUS ) GO TO 410
      IF( NXTCH .EQ. IBLANK .OR. LPLUS(NXTCH) ) GO TO 420
      GO TO 430
  410 IPSIGN = -1
  420 ICH = ICH + 1
      NXTCH = ILIMIT
      IF( ICH .LE. MXCH ) NXTCH = LIT(ICH)
  430 CONTINUE
      INTGR = INTVAL(NXTCH)
      IF( NUMER(INTGR) ) GO TO 440
      IER = 3
      GO TO 900
  440 IPOWER = 0
  445 IPOWER = 10 * IPOWER + INTVAL(NXTCH)
      ICH = ICH + 1
      NXTCH = ILIMIT
      IF( ICH .LE. MXCH ) NXTCH = LIT(ICH)
      INTGR = INTVAL(NXTCH)
      IF( NUMER(INTGR) ) GO TO 445
      IER = 3
      IF( NXTCH .EQ. IDECPT .OR. LPORM(NXTCH) .OR.
     $     LEORD(NXTCH) ) GO TO 900
      IER = 4
      IF( IPOWER .GT. MAXPOW ) GO TO 900
      IER = 0
      POWER = TENTEN(1+IPOWER/10) * TENTO(MOD(IPOWER,10)+1)
      IF( IPSIGN .EQ. -1 ) POWER = 1D0/POWER
      CVTAD2 = CVTAD2 * POWER
C
C          NORMAL EXIT
C
  800 CONTINUE
      IF( ISIGN .LT. 0 ) CVTAD2 = -CVTAD2
C
C          SKIP TRAILING BLANKS
C
      ICH = ICH - 1
  820 IF( ICH .GE. MXCH ) RETURN
      ICH = ICH + 1
      IF( LIT(ICH) .EQ. IBLANK ) GO TO 820
      IF( LIT(ICH) .EQ. ICOMMA ) GO TO 860
      ICH = ICH - 1
      RETURN
  860 IF ( ICH .GE. MXCH ) GO TO 880
      ICH = ICH + 1
      IF( LIT(ICH) .EQ. IBLANK) GO TO 860
      ICH = ICH - 1
      RETURN
  880 ICODE = ICODE + 5
      RETURN
C
C          WRITE ERROR MESSAGE
C
  900 CONTINUE
      ICODE = 3
      CVTAD2 = DNULL
C  - - - - - BEGIN JOS.MOD 11/86 - - - - -
      IIER1 = 1+IER/4
      IIER2 = 2+IER
      WRITE(MSG,901) DMSG(IIER1), DMSG(IIER2), ICH,
     $                                 (LIT(I), I=1,ICH), IQUOTE
C  - - - - - END JOS.MOD 11/86 - - - - -
  901 FORMAT('0+++013 CVTAD2 - ILLEGAL ',A6,' IN ',A6,
     $     ' AT END OF',I4,'-CHAR FIELD ', 1H' ,50A1/(66X,50A1))
      ICH = ICH - 1
      RETURN
      END
C                                     <<<<<SUBPROGRAM INTVAL>>>>>
C     <<<<<LAST REVISED 10-16-85>>>>>
C
      FUNCTION     INTVAL(IX)
C
C  CONVERTS LITERAL (A1) REPRESENTATION OF DIGITS 0, 1, ..., 9
C       TO THEIR INTEGER VALUE.  CHARACTERS OTHER THAN 0 THRU 9
C       RETURN INTVAL = 10 (NON-NUMERIC 'FLAG' FOR CVTAD2).
C
      CHARACTER*1 NCHAR, IX
C
      DIMENSION NCHAR(10)
      DATA NCHAR / '0','1','2','3','4','5','6','7','8','9'/
C
      DO 20 I=1,10
      IF( IX .EQ. NCHAR(I) ) GO TO 10
   20 CONTINUE
C
      I = 11
C
   10 INTVAL = I - 1
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM DPVAL >>>>>
C     <<<<<LAST REVISED 10-16-85>>>>>
C
      FUNCTION     DPVAL(IX)
C
C  CONVERTS LITERAL (A1) REPRESENTATION OF DIGITS 0, 1, ..., 9
C       TO THEIR DOUBLE PRECISION VALUE.  CHARACTERS OTHER THAN
C       0 THRU 9 RETURN DPVAL = 10.0000000
C
      DOUBLE PRECISION DPVAL
C
      CHARACTER*1 NCHAR, IX
C
      DIMENSION NCHAR(10)
      DATA NCHAR /'0','1','2','3','4','5','6','7','8','9'/
C
      DO 20 I=1,10
      IF( IX .EQ. NCHAR(I) ) GO TO 10
   20 CONTINUE
C
      I = 11
C
   10 DPVAL = FLOAT(I - 1)
C
      RETURN
      END
      SUBROUTINE PUTBIN(BINVAL,NBIN,TARGET, ISHUFF, MXCAP )
C
C  MOVES NON-NULL DATA FROM BINVAL TO REAL TARGET ARRAY
C   ALSO SEE PUTBI2 (NEXT SUBROUTINE)
C
C   MXCAP VALUES AT MOST WILL BE MOVED.
C   NULL VALUES IN BINVAL ARE SKIPPED OVER AND THE
C   CORRESPONDING TARGET ITEMS ARE NOT CHANGED.
C   NON-NULL DATA ARE THOSE THAT ARE .GE. -1E32
C     AND  ARE IN THE FIRST NBIN ELEMENTS OF BINVAL.
C  DATA MAY BE TRANSFERRED TO NONCONTIGUOUS LOCATIONS BY MEANS
C  OF SHUFFLE VECTOR ISHUFF.  TO SUPPRESS SHUFFLING, USE ISHUFF=0.
C
      DIMENSION  BINVAL(1), TARGET(1),  ISHUFF(1),  ITARGT(1)
C
      DATA  MSG / 6 /
C
C
      IF(NBIN.GT.MXCAP)WRITE(MSG,1101)
 1101 FORMAT(' +++014 WARNING:  EXCESS DATA ITEMS IGNORED.')
      NMOVE=MIN0(MXCAP,NBIN)
      IF(NMOVE.LE.0)  RETURN
C
      IF (ISHUFF(1).GT.0)  GO TO 100
C
   15 DO  16  I = 1, NMOVE
   16 IF(BINVAL(I).GT.  -1E32  )  TARGET(I) = BINVAL(I)
      RETURN
C
100   CONTINUE
   25 DO  26  I = 1, NMOVE
   26 IF(BINVAL(I).GT.  -1E32  ) TARGET(ISHUFF(I)) = BINVAL(I)
      RETURN
C
      END
      SUBROUTINE  PUTBI2 (BINVAL,NBIN,ITARGT, ISHUFF, MXCAP )
C
C   MOVES NON-NULL REAL DATA TO INTEGER TARGET ARRAY
C            (WITH REAL-INTEGER CONVERSION)
C           ALSO SEE PUTBIN (PREVIOUS SUBROUTINE)
C
      DIMENSION  BINVAL(1), TARGET(1),  ISHUFF(1),  ITARGT(1)
C
      DATA  MSG / 6 /
C
      IF(NBIN.GT.MXCAP) WRITE(MSG,1101)
 1101 FORMAT(' +++014 WARNING:  EXCESS DATA ITEMS IGNORED.')
      NMOVE=MIN0(MXCAP,NBIN)
      IF(NMOVE.LE.0)  RETURN
C
      IF (ISHUFF(1).GT.0)  GO TO 100
C
      DO  16  I = 1, NMOVE
      IF( BINVAL(I) .GT.  -1E32 ) ITARGT(I) = BINVAL(I)
   16 CONTINUE
      GO TO 500
C
  100 CONTINUE
C
      DO  26  I = 1, NMOVE
      IF( BINVAL(I) .GT.  -1E32 )
     $                 ITARGT(ISHUFF(I)) =  BINVAL(I)
   26 CONTINUE
  500 RETURN
C
      END
      SUBROUTINE MOVEO(X,Y,IOFF,N)
C  MOVE WITH OFFSET
      DIMENSION X(1), Y(1)
      IF(N.LE.0) RETURN
      DO 10 I=1,N
   10 Y(IOFF+I) = X(IOFF+I)
      RETURN
      END
C                                     <<<<<SUBPROGRAM PRCJXX>>>>>
C     <<<<<LAST REVISED 08-06-87>>>>>
C
      SUBROUTINE   PRCJXX (IOPT, NBIN, BINBUF, JTYPE, INSWAP)
C
C          PROCESS DATA FROM J_ RECORDS
C
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  JOS.MOD 08/87 - COSMETIC / STANDARDIZATION
C  JOS.MOD 08/87 - CORRECT J1 DATA OVER-RIDE PROBLEM
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
C
      COMMON /IPTCB1/  IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / JHPARM / DELTAY, YTOL, QTOL, FNTEST
      COMMON / JHPAR2 / IHFNO2
      COMMON / J3COM / IRISKT, MXJ3VN, IVARNO(55), IUDTNO(3)
      COMMON / HPCOM / IOPTSA, ELMIN, YINC, ELMAX
C
      DIMENSION BINBUF(IPTEND), INSWAP(6), NOSHUF(1),
     $                                ASHUF(4), JSHUF(1), WORK(5)
C
      DATA MSG / 6 /, NOSHUF(1) / 0 /
C
      GO TO (100, 200, 300), JTYPE
      STOP 645
C
  100 CONTINUE
C
      DO 110 I = 1,5
      WORK(I) = -1.1E32
  110 CONTINUE
C
      CALL PUTBIN (BINBUF, NBIN, WORK, NOSHUF, 5)
      ASHUF(1) = DELTAY
      ASHUF(2) = YTOL
      ASHUF(3) = QTOL
      ASHUF(4) = FNTEST
      CALL PUTBIN (WORK, 4, ASHUF, NOSHUF, 4)
      DELTAY = ASHUF(1)
      YTOL = ASHUF(2)
      QTOL = ASHUF(3)
      FNTEST = ASHUF(4)
      JSHUF(1) = IHFNO2
      CALL PUTBI2 (WORK(5), 1, JSHUF, NOSHUF, 1)
      IHFNO2 = JSHUF(1)
      YINC = DELTAY
C
      WRITE(MSG,150) DELTAY, YTOL, QTOL, FNTEST, IHFNO2
C
  150 FORMAT(/' J1 RECORD PARAMETERS:'/' DELTAY = ',F4.2,
     $  '   YTOL = ',F4.2,'   QTOL = ',F4.2,'   FNTEST = ',
     $                                  F4.2,'   IHFNOJ = ',I2/)
C
      GO TO 500
C
  200 CONTINUE
      INSWAP(2) = 80
      IF(NBIN.LE.0)  GO TO 210
      IF(NBIN.GE.1 .AND. BINBUF(1).GT.0.) INSWAP(1) = BINBUF(1)
      IF(NBIN.GE.2.AND.BINBUF(2).GT.0.) INSWAP(2) = BINBUF(2)
      IF(INSWAP(1).EQ.INSWAP(4)) INSWAP(5) = INSWAP(2)
      GO TO 500
  210 IF(INSWAP(1).EQ.INSWAP(4)) GO TO 220
      INSWAP(1) = INSWAP(4)
      INSWAP(2) = INSWAP(5)
      GO TO 500
  220 INSWAP(1) = 10
      GO TO 500
C
C          PROCESS J3 RECORD
C
  300 CONTINUE
      IRISKT = IOPT
      J = 0
      I = 0
      N = 0
  320 CONTINUE
      I = I + 1
      IF( I .GT. NBIN ) GO TO 380
      IF( BINBUF(I) .GT. -1E30 ) GO TO 350
      K = 0
  330 K = K + 1
      IF( IVARNO(J+K) .GT. 0 ) GO TO 330
      IF( K .GT. 1 )  J = J + K
      GO TO 320
C
  350 CONTINUE
      I = I - 1
      N = NBIN - I
      IF( (J + N) .LE. (MXJ3VN - 2) ) GO TO 360
      N = MXJ3VN - 2 - J
      K = I + N
      WRITE(MSG,353) K
  353 FORMAT(' +++015 WARNING:  TOO MANY DATA ITEMS ON J3 ',
     $                       'RECORD;  ONLY', I3, ' ITEMS USED.')
C
  360 CONTINUE
C
      DO 370 K = 1,N
      IVARNO(J+K) = AMAX1( 0., BINBUF(I+K) )
  370 CONTINUE
C
  380 IVARNO(J+N+1) = 0
      IF( J .GT. 0  .AND.  N .EQ. 0 ) GO TO 500
      IVARNO(J+N+2) = 0
C
  500 RETURN
C
      END
      SUBROUTINE  PRCCMD(JTYPE,IOPT,NBIN,BINBUF,SECID,  XPOOL)
C
C  PROCESS CROSS-SECTION DISPLAY COMMAND
C
      COMMON /IPTCB1/  IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      DIMENSION   XPOOL(IPTEND),  BINBUF(IPTEND)
C
C
C === TEMPORARY FOR DEBUGGING
      COMMON / HPCOM / IOPTSA,ELMIN,YINC,ELMAX
C
C  *** CHARACTER DATA ...
      CHARACTER*5   SECID(3)
      CHARACTER*3 IOPT2
C            NOTE -- SECID(2)=SECIDX, (3)=BLANK
      DATA  IOPT2 / 'CHK' /
C
      DATA  MSG /6/
C
C   TEST CALL  --
      K=1
      IF(SECID(K).EQ.SECID(3)) K=2
      IF(IOPT.EQ.9) K=2
      CALL XSISEQ(SECID(K),ISEQ)
      IF(ISEQ.GT.0) GO TO 115
      WRITE(MSG,113)SECID(K)
  113 FORMAT(' +++018 UNKNOWN SECID; DATA IGNORED - ',A8)
      RETURN
  115 CONTINUE
      CALL XSRTRV(ISEQ,IXTYPE,IERXS,XPOOL, SRD)
C
C
      GO TO ( 1000, 2000, 3000 ), JTYPE
C
C
1000  CONTINUE
      CALL XSPRT(XPOOL,ISEQ,SECID(K), SRD,IXTYPE,IERXS)
      RETURN
C
C
2000  CONTINUE
C
C***   FOLLOWING INSERTED BY JOS  08-10-84  FOR XS PROPERTIES OUTPUT
C
      IOPTSA=IOPT
      IF(NBIN.LE.0) GO TO 2040
      IF (NBIN.GE.1 .AND. ABS(BINBUF(1)).LT.1E5) ELMIN=BINBUF(1)
      IF (NBIN.GE.2 .AND. ABS(BINBUF(2)).LT.1E5) YINC=BINBUF(2)
      IF(YINC.LE.0.0) YINC=1.0
      IF (NBIN.GE.3 .AND. ABS(BINBUF(3)).LT.1E5) ELMAX=BINBUF(3)
      IF( IOPTSA .EQ. 2 ) GO TO 2050
 2040 CALL HPTABL (XPOOL,ISEQ,SECID(K),SRD,IXTYPE)
      RETURN
C
 2050 CONTINUE
      IF( ABS(BINBUF(3)) .GT. 1E5 ) ELMAX = ELMIN
      IF( NBIN .GE. 4   .AND.  ABS(BINBUF(4)) .LT. 1E5)
     $                                              Q = BINBUF(4)
      CALL VDIST ( XPOOL, ISEQ, SECID(K), SRD, IXTYPE, Q )
      RETURN
C
 3000 CONTINUE
C        PRINTER-PLOT X-SEC GEOMETRY
      IF(NBIN.LE.1) BINBUF(2) = -1E32
      CALL XSPLT (XPOOL,ISEQ,SECID(K),SRD,IXTYPE, BINBUF)
      RETURN
C
      END
      SUBROUTINE  PRCPCD (JTYPE,IOPT,NBIN,BINBUF, SECID)
C
C  PROCESS PROFILE-CONTROL DATA
C
      DIMENSION  BINBUF(1)
C
C  *** CHARACTER DATA ...
      CHARACTER*5   SECID(3)
C            (NOTE-- SECID(2)=SECIDX, (3)=BLANK)
C
C  PROFILE-CONTROL DATA
C     USED ONLY BY ROUTINES QFUNCT, PRCOMP, PRCPCD
      COMMON / PCDBLK /  NPROF, IPCDIR(20),WSI(20),EGSLPI(20),
     $              QVPOOL(200),NIPC,NWSI,NEGSI,NQV,MXPROF,MXQV
C
C
      DIMENSION NOSHUF(1)
      DATA MSG/6/,NOSHUF(1)/0/
C
      IF(JTYPE.EQ.-99) NPROF = -99
      IF(JTYPE.EQ.-99) RETURN
      IF(IOPT.NE.0 .OR. (JTYPE.NE.3.AND.SECID(1).NE.SECID(3)) )
     $       WRITE(MSG,33)
   33 FORMAT(' +++016 NOTE:  EXTRANEOUS OPTION/SECID IGNORED.')
      IF(NPROF.NE.0) GO TO 40
      NPROF=MIN0(NBIN,MXPROF)
      NIPC = 0
      DO 37 I=1,MXPROF
      WSI(I) = -1.1E32
      EGSLPI(I) = -1E32
   37 IPCDIR(I) = 0
   40 CONTINUE
      IF(NBIN.EQ.NPROF) GO TO 28
      WRITE(MSG,22)NBIN,NPROF
   22 FORMAT(' +++017 DATA COUNT INCONSISTENT WITH PROFILE COUNT -',
     $      2I6)
      NIPC = 1
      IF(NPROF.LE.NBIN) GO TO 28
      NPROF=NBIN
      WRITE(MSG,23)NPROF
   23 FORMAT(' *** PROFILE COUNT REDUCED TO -',I4)
   28 CONTINUE
      GO TO (100,200,300), JTYPE
      STOP 645
100   CONTINUE
C     --  WS CARD  --
      CALL PUTBIN (BINBUF, NBIN, WSI, NOSHUF, NPROF)
      RETURN
200   CONTINUE
C     --  SK CARD  --
      CALL PUTBIN (BINBUF, NBIN, EGSLPI, NOSHUF, NPROF)
      RETURN
300   CONTINUE
C     --  Q CARD  --
      ISEQ = 1
      K=1
      IF(SECID(K).EQ.SECID(3)) K=2
      IF(SECID(K).NE.SECID(3))  CALL XSISEQ(SECID(K),ISEQ)
      IF(ISEQ.GT.0) GO TO 315
      NPROF = -99
      WRITE(MSG,313) SECID(K)
  313 FORMAT(' +++018 UNKNOWN SECID; DATA IGNORED - ',A8)
      RETURN
  315 CONTINUE
      WRITE(MSG,318) SECID(K),ISEQ
  318 FORMAT(' *** Q-DATA FOR SEC-ID, ISEQ = ',A8,I4)
      Q = QFUNST(ISEQ,  NPROF,  BINBUF)
      IF(Q.NE.0.)  NPROF = -99
      RETURN
      END
C                                     <<<<<SUBPROGRAM PRCOMP>>>>>
C     <<<<<LAST REVISED 01-26-88>>>>>
C
      SUBROUTINE   PRCOMP ( JTYPE, IOPT, NBIN, BINBUF, XPOOL )
C
C     Profile computation control routine
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      COMMON / PCDBLK / NPROF, IPCDIR(20), WSI(20), EGSLPI(20),
     $          QVPOOL(200), NIPC, NWSI, NEGSI, NQV, MXPROF, MXQV
C
      COMMON / DRCTRY / NXSECS, MXXSEC, IXTYPV(100),
     $                           IXIERV(100), SRDV(100), WSC(100)
C
      DIMENSION BINBUF(IPTEND), NOSHUF(1), XPOOL(IPTEND,5)
C
      DATA MSG / 6 /, NOSHUF(1) / 0 /
C
      IF(IOPT.GT.1) WRITE(MSG,32) IOPT
   32 FORMAT(' +++019 INVALID OPTION CODE IGNORED -',I4)
      IF(IOPT.GT.1)  IOPT=0
      DO 35 I=1,MXPROF
   35 IPCDIR(I) = IOPT
C
      IF(NBIN.LE.0) GO TO 70
      IF(IOPT.NE.0) WRITE(MSG,41)
   41 FORMAT(' +++020 COMPUTATION DIRECTION ESTABLISHED BY EX CARD.')
      IF(NBIN.EQ.NPROF) GO TO 60
      WRITE(MSG,43) NBIN,NPROF
   43 FORMAT(' +++021 DATA COUNT INCONSISTENT WITH PROFILE COUNT -',
     $         2I6)
      IF(NBIN.LT.NPROF) WRITE(MSG,47) NPROF,NBIN
   47 FORMAT(' +++022 PROFILE COUNT REDUCED TO DATA COUNT -',2I6)
      NPROF = MIN0(NPROF,NBIN)
      NIPC = 1
   60 CONTINUE
      CALL PUTBI2 (BINBUF,NBIN,IPCDIR,NOSHUF,NPROF)
   70 CONTINUE
C
C
      IF(NQV.GT.0.AND.NQV.LE.MXQV) GO TO 98
      WRITE(MSG,96) NQV
   96 FORMAT(' +++023 DISCHARGE DATA INVALID OR MISSING -',I6)
      NPROF = -99
   98 CONTINUE
C
C
C     Scan directory to locate bridge/culvert sections and
C     reset full-valley type code from 0 to 1
C
      DO 417 I = 2,NXSECS
        IF( IXTYPV(I) .NE. 2  .AND.  IXTYPV(I) .NE. 6 ) GO TO 417
        IF( IXTYPV(I-1) .EQ. 0) IXTYPV(I-1) = 1
 417  CONTINUE
C
      IF(NPROF.GT.0 .AND. NPROF.LE.MXPROF)  GO TO 100
      WRITE(MSG,914)
  914 FORMAT(//' +++024 PROFILE COMPUTATIONS BYPASSED DUE TO ',
     $     'INCONSISTENT CONTROL DATA.'/)
      RETURN
  100 CONTINUE
C
      WRITE(MSG,332) NPROF
  332 FORMAT(/' +++ BEGINNING PROFILE CALCULATIONS -- ',I3)
      IF(NIPC.GT.0) WRITE(MSG,331)
  331 FORMAT(' +++025 CALCULATIONS MAY BE INCOMPLETE DUE TO ',
     $          'INCONSISTENT DATA.')
      DO 333 IPR = 1, NPROF
  333 CALL PCCR(IPR,IPCDIR(IPR),WSI(IPR),EGSLPI(IPR),XPOOL)
      RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #3 OF PC VERSION +++++
      SUBROUTINE  XSINIT(IXTYPE,IOPT,NBIN,BINBUF,
     $               XPOOL,IPOINT,IERXS,SRD)
C
C  INITIALIZE COMPOSITE CROSS SECTION DATA ARRAY
C
C  REVISED 1/25/83 TO STORE S.R.D. AT IPTMSC+0 IN XPOOL
C
C
      COMMON /IPTCB1/  IPTXY, IPTRGH, IPTFL,IPTMSC,
     $                IPTPEA, IPTABG,  IPTEND
      DIMENSION XPOOL(IPTEND,5)
      DIMENSION BINBUF(IPTEND)
C
C
C     SHUFFLE VECTORS
      DIMENSION ISHFXT(2),ISHFXS(4),ISHFBR(6),ISHFSD(7),
     $       ISHFXR(7),ISHFCV(5)
      DATA ISHFXT/5, 1/
      DATA ISHFXS/1, 3, 4, 5/
      DATA ISHFBR/14, 1, 3, 4, 19, 5/
      DATA ISHFSD/6, 7, 8, 1, 3, 4, 5/
      DATA ISHFXR/7, 6, 8, 1, 3, 4, 5/
      DATA ISHFCV/15, 12, 14, 13, 11/
C
C
      DATA  MSG / 6 /
C
C
C   DECIDE TEMPLATE VS REGULAR XSECTION
      IPOINT = 2
      IF(IXTYPE.EQ. 9 )  IPOINT = 3
C
      DO 10 I=1,IPTXY
   10 XPOOL(I,IPOINT) = 0.
      K1 = IPTXY+1
      K2 = IPTEND
      DO 20 I=K1,K2
   20 XPOOL(I,IPOINT) = -1.01E32
C
      SRD = BINBUF(1)
      XPOOL(IPTMSC+0,IPOINT) = SRD
C
C  REV 01/85 JOS -- ELIMINATE PROPAGATION OF SKEW (EXCEPT IN DESIGN MODE).
C
      IPT = IPTMSC+1
      XPOOL(IPT,IPOINT) = 0
C
      GO TO (210, 220, 230, 240, 210, 260), IXTYPE
      IF(IXTYPE.NE.9) STOP 213
      CALL PUTBIN (BINBUF(2), NBIN-1, XPOOL(IPT,IPOINT), ISHFXT, 2)
      GO TO 298
  210 CALL PUTBIN (BINBUF(2), NBIN-1, XPOOL(IPT,IPOINT), ISHFXS, 4)
      GO TO 298
  220 CALL PUTBIN (BINBUF(2), NBIN-1, XPOOL(IPT,IPOINT), ISHFBR, 6)
      GO TO 298
  230 CALL PUTBIN (BINBUF(2), NBIN-1, XPOOL(IPT,IPOINT), ISHFSD, 7)
      GO TO 298
  240 CALL PUTBIN (BINBUF(2), NBIN-1, XPOOL(IPT,IPOINT), ISHFXR, 7)
      GO TO 298
  260 CALL PUTBIN (BINBUF(2), NBIN-1, XPOOL(IPT,IPOINT), ISHFCV, 5)
C
  298 CONTINUE
C
      IF(IOPT.LE.0) GO TO 398
      WRITE(MSG,373) IOPT
  373 FORMAT(' +++019 INVALID OPTION CODE IGNORED -',I4)
  398 CONTINUE
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSFILL>>>>>
C     <<<<<LAST REVISED 01-12-88>>>>>
C
      SUBROUTINE   XSFILL ( IXTYPE, JTYPE, LTYPE, IOPT,
     $                               NBIN, BINBUF, XPOOL, IERXS )
C
C  FILLS COMPOSITE CROSS SECTION DATA ARRAY USING BINBUF DATA
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      DIMENSION ISHFAB(4), ISHFBL(3), ISHFCD(7), ISHFKD(6),
     $        ISHFPG(2), NOSHUF(1), XPOOL(IPTEND), BINBUF(IPTEND)
C
      DATA  ISHFAB / 9, 10, 15, 16 /, ISHFBL / 1, 9, 10 /,
     $               ISHFCD / 6, 7, 8, 21, 11, 12, 13 /,
     $    ISHFKD / 22, 23, 24, 17, 18, 25 /, ISHFPG / 4, 3 /,
     $                                 NOSHUF(1) / 0 /, MSG / 6 /
C
      IF( IXTYPE .EQ. 9 ) THEN
C       --- GR  data for XT header record ---
        IF( JTYPE .EQ. 1 ) GO TO 100
C       --- SA data for XT header record ---
        IF( JTYPE .EQ. 3 ) GO TO 300
      ELSE
C       --- invalid data record ---
        IF( IXTYPE .EQ. 9 )  GO TO 1113
      ENDIF
C
C     --- BP record ---
      IF( JTYPE .EQ. 8 ) GO TO 800
C
C     ---   culvert data ---
      IF( IXTYPE .EQ. 6 )  GO TO 6000
C
C     --- data common to all other sections ---
C     ---      GR    N   SA   ND   FL   GT ---
      GO TO ( 100, 200, 300, 400, 500, 600 ), JTYPE
C
C     --- special bridge data ---
      IF( IXTYPE .EQ. 2 )  GO TO 2000
C
C     --- special road grade data ---
      IF( IXTYPE .EQ. 4 )  GO TO 4000
C
 1113  CONTINUE
C       --- invalid data record ---
       WRITE(MSG,1114) JTYPE, IXTYPE
 1114  FORMAT(' +++028 ORDER:  CARD TYPE INVALID FOR X-SEC TYPE -',2I5)
       GO TO 1190
C
 1000 CONTINUE
      WRITE(MSG,1102) JTYPE,IXTYPE
 1102 FORMAT(' *** XSFILL NOT YET DEFINED FOR JTYPE = ',2I8)
      GO TO 1190
 1106 WRITE(MSG,1107) JTYPE, LTYPE
 1107 FORMAT(' +++027 ORDER:  INVALID CONTINUATION OR REDEFINITION -',
     $        2I8)
      GO TO 1190
 1108 WRITE(MSG,1109) KOUNT,JTYPE
 1109 FORMAT(' +++026 DATA COUNT EXCEEDS CAPACITY FOR TYPE -',2I8)
      GO TO 1190
 1190 IERXS = 1
      RETURN
C
 100  CONTINUE
C     --- GR data ---
      KOUNT = XPOOL(1)
      IF (KOUNT.LT.0)  GO TO 1106
      IF(KOUNT.NE.0.AND.JTYPE.NE.LTYPE) GO TO 1106
      IPT = IPTXY + KOUNT + 1
      KOUNT = KOUNT + NBIN
      IPT2 = IPTXY + KOUNT
      IF(IPT2 .GT. IPTRGH - 10 )  GO TO 1108
      CALL PUTBIN (BINBUF,NBIN,XPOOL(IPT), NOSHUF, NBIN )
      XPOOL(1) = KOUNT
      RETURN
C
 200  CONTINUE
C
C      --- N record --- type 702
C      uses  temporary counter NNV in XPOOL(6)
C
      KOUNT = XPOOL(6)
      MXSA = (IPTFL-IPTRGH)/5
      IPT = IPTRGH + 3*MXSA + KOUNT + 1
      IF(KOUNT.NE.0.AND.JTYPE.NE.LTYPE)  GO TO 1106
      KOUNT = KOUNT + NBIN
      MXCAP = 2*MXSA
      IF(KOUNT.GT.MXCAP)  GO TO 1108
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPT), NOSHUF, NBIN )
      XPOOL(6) = KOUNT
      RETURN
C
C
300   CONTINUE
C     SA CARD -- TYPE 703
      NSA = XPOOL(2)
      KOUNT = NSA
      IF(KOUNT.NE.0.AND.JTYPE.NE.LTYPE) GO TO 1106
      IF(KOUNT.GT.0)  KOUNT = KOUNT - 1
C            --- (REMOVED FAKED-IN R.H. BOUNDARY OF LAST SUBAREA.)
      IPT = IPTRGH + 1 + KOUNT
      KOUNT = KOUNT + NBIN
      MXCAP = (IPTFL - IPTRGH)/5
C            --- NOTE WE WILL FORCE NRD=2 LATER ---
C            ALSO REMEMBER THAT NSA WILL = 1 + KOUNT FROM SA CARDS
      IF(KOUNT+1.GT.MXCAP)  GO TO 1108
      CALL  PUTBIN (BINBUF,NBIN,XPOOL(IPT), NOSHUF, NBIN )
C   INSERT FAKE R.H. BOUNDARY FOR LAST SUBAREA.
      XPOOL(IPT+NBIN) = 1.43E32
      NSA = KOUNT + 1
      XPOOL(2) = NSA
      RETURN
C
400   CONTINUE
C    ND CARD - TYPE 704
C      -- WE WILL FORCE NRD=2 IN XSWRAP.  FOR NOW WE USE IT TO
C         COUNT NBR VALUES READ IN ON ND CARDS.
      KOUNT = XPOOL(3)
      MXSA = (IPTFL-IPTRGH)/5
      IPT  = IPTRGH + MXSA + KOUNT + 1
      IF(KOUNT.NE.0.AND.JTYPE.NE.LTYPE)  GO TO 1106
      KOUNT = KOUNT + NBIN
      MXCAP = 2*MXSA
      IF(KOUNT.GT.MXCAP) GO TO 1108
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPT), NOSHUF, NBIN )
      XPOOL(3) = KOUNT
      RETURN
C
500   CONTINUE
C  FL - FLOW-LENGTH -- TYPE 705
      NFL = XPOOL(4)
      IF(NFL.NE.0 .OR. XPOOL(IPTMSC+2).GT.0.)  GO TO 1106
      IF(NBIN.LE.0)  GO TO 505
      MXCAP = IPTMSC - IPTFL - 1
      KOUNT = NBIN
      IF( KOUNT+1.GT.MXCAP )  GO TO 1108
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTFL+1), NOSHUF, NBIN )
      NFL = NBIN + 1
      XPOOL(IPTFL + NFL) =  1E32
      IF ((NFL/2)*2.EQ.NFL)  GO TO 505
      WRITE(MSG,503)NFL
  503 FORMAT(' +++029 MISSING FLOW LENGTH OR BREAKPOINT STATION -',I4)
      IERXS = 1
  505 CONTINUE
      XPOOL(4) = NFL/2
      XPOOL(IPTMSC+2) = IOPT
      IF(IOPT.LE.4)  GO TO 510
      WRITE(MSG,507)IOPT
  507 FORMAT(' +++030 INVALID FRICTION LOSS OPTION CODE -',I4)
      IERXS = 1
  510 CONTINUE
      RETURN
C
C     --- GT record ---
 600  CONTINUE
      KOUNT = XPOOL(1)
      IF(KOUNT.NE.0)  GO TO 1106
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTXY+1),NOSHUF,5)
      XPOOL(1) = -5
      RETURN
C
  800 CONTINUE
C  BP  --  BP CARD -- TYPE 708
      IF(XPOOL(IPTMSC+26).GE.-1E30) GO TO 1106
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTMSC+26),NOSHUF,4)
      RETURN
C
C  - - - -   B R I D G E   - - -   2000  - - - -
C
 2000 CONTINUE
      I = JTYPE - 10
      GO TO (2010,2020,2030,2040,2050,2060,2070,2080), I
 2010 CONTINUE
C  -- BL - CARD
      IF(XPOOL(IPTABG+2).GE.0.)  GO TO 1106
      XPOOL(IPTABG+2) = IOPT
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTABG+1),ISHFBL,3)
      XPOOL(IPTABG+11) = 1
      RETURN
 2030 CONTINUE
C  -- AB - CARD
      IF(XPOOL(IPTMSC+9).GE.0.)  GO TO 1106
      IF(BINBUF(1).LT.0.)  BINBUF(1) = 0.
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTMSC+1),ISHFAB,4)
      RETURN
 2040 CONTINUE
C  -- BD - CARD
      IF(XPOOL(IPTABG+5).GE.0.)  GO TO 1106
      IF(BINBUF(1).LT.0.)  BINBUF(1) = 0.
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTABG+5),NOSHUF,4)
      XPOOL(IPTABG+11) = 1
      RETURN
 2050 CONTINUE
      GO TO 1000
 2060 CONTINUE
C  -- CD - CARD
      IF(XPOOL(IPTMSC+ISHFCD(1)).GE.0.)  GO TO 1106
      IF(BINBUF(1).LT.0.)  BINBUF(1) = 0.
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTMSC+1),ISHFCD,7)
      RETURN
 2070 CONTINUE
C  -- PG - CARD
      IF(XPOOL(IPTABG+ISHFPG(1)).GE.0.)  GO TO 1106
      IF(BINBUF(1).LT.0.)  BINBUF(1) = 0.
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTABG+1),ISHFPG,2)
      RETURN
 2080 CONTINUE
C  -- KD - CARD
      IF(XPOOL(IPTMSC+ISHFKD(1)).GE.0.)  GO TO 1106
      IF(BINBUF(1).LT.0.)  BINBUF(1) = 0.
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPTMSC+1),ISHFKD,6)
      RETURN
C
 2020 CONTINUE
C  ==  PIER-AREA-ELEVATION CURVE  --  TYPE 712
      KOUNT = XPOOL(5)
      IF(KOUNT.NE.0.AND.JTYPE.NE.LTYPE) GO TO 1106
      IF(KOUNT.EQ.0) XPOOL(IPTMSC+20) = IOPT
      IPT = IPTPEA + KOUNT + 1
      KOUNT = KOUNT + NBIN
      IPT2 = IPTPEA + KOUNT
      IF(IPT2 .GT. IPTABG )  GO TO 1108
      CALL PUTBIN (BINBUF,NBIN,XPOOL(IPT), NOSHUF, NBIN )
      XPOOL(5) = KOUNT
      RETURN
C
C
C  - - - - -    R O A D   G R A D E  - - -   4000  - - - -
4000   CONTINUE
      IF((NBIN/3)*3.EQ.NBIN) GO TO 4040
      WRITE(MSG,4003) NBIN
 4003 FORMAT(' +++031 MISSING EITHER PI COORDINATE OR',
     $     ' VERTICAL CURVE LENGTH -', I6)
      IERXS = 4003
      NBIN = NBIN + 2
 4040 NVC = NBIN/3 - 2
      IF(XPOOL(1).GT.0.) GO TO 1106
      XPOOL(IPTXY+1) = BINBUF(1)
      XPOOL(IPTXY+2) = BINBUF(2)
      NGP = 1
      NGPMAX = (IPTRGH-10 - IPTXY)/2
      DO 4070 I=1,NVC
      CALL XBLDVC(BINBUF(1+(I-1)*3),
     $       XPOOL(IPTXY+2*NGP+1), NGPINC )
      NGP = NGP + NGPINC
      KOUNT = NGP*2
      IF(NGP.GT.NGPMAX) GO TO 1108
 4070 CONTINUE
      XPOOL(IPTXY+2*NGP+1) = BINBUF(3*NVC+3+1)
      XPOOL(IPTXY+2*NGP+2) = BINBUF(3*NVC+3+2)
      NGP = NGP + 1
      KOUNT = 2*NGP
      IF(NGP.GT.NGPMAX) GO TO 1108
      XPOOL(1) = KOUNT
      RETURN
C
C
C - - - -  COLLECT   C U L V E R T   DATA - - - - -  6000  - - - - - -
 6000 CONTINUE
      IF(JTYPE.EQ.28) GO TO 6280
      IF(JTYPE.EQ.29) GO TO 6290
      GO TO 1113
6280  X = XPOOL(IPTMSC+6)
      IF(X.GE.-1000.0) GO TO 1106
      IF(BINBUF(1).GT.-1E30)  XPOOL(IPTMSC+6) = BINBUF(1)
      IPT = IPTABG
      CALL PUTBIN(BINBUF(2),NBIN-1,XPOOL(IPT+1),NOSHUF,5)
      GO TO 6295
6290  IPT = IPTMSC+6
      IF(XPOOL(IPT+1).GE.-1000.)  GO TO  1106
      CALL PUTBIN(BINBUF,NBIN,XPOOL(IPT+1),NOSHUF,4)
 6295 CONTINUE
6298  IF(XPOOL(IPT+I).LT. -999.9)  XPOOL(IPT+I) = -99.
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSWRAP>>>>>
C     <<<<<LAST REVISED 01-22-88>>>>>
C
      SUBROUTINE   XSWRAP (IXTYPE, IERXS, SECID, XPOOL, SRD )
C
C    WRAPS UP CONSTRUCTION OF COMPOSITE CROSS SECTION
C     DATA ARRAY AFTER NEW X-SEC HEADER OR COMMAND
C     CARD IS READ.
C
C  POINTERS TO SUBDIVISIONS OF CROSS SECTION DATA RECORD
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      COMMON / JHPAR2 / IHFNO2
C
      CHARACTER*5 SECID
C
      DIMENSION NOSHUF(1), XPOOL(IPTEND,5)
C
      DATA MSG / 6 /, NOSHUF(1) / 0 /
C
      JPCX = 1
      JCIB = 2
      JTPV = 3
      JBXX = 4
C
      IBLDBR = 0
      IF(IXTYPE.EQ.2.AND.XPOOL(IPTABG+11,JCIB).GT.0.) IBLDBR = 1
      IBLDSD = 0
      IF(IXTYPE.EQ.3.AND.XPOOL(IPTMSC+8,JCIB).GE.-1E30) IBLDSD = 1
C
      CALL XSISEQ(SECID,ISEQ)
      IF(ISEQ.GT.0) GO TO 120
      IF(IXTYPE.NE.6) GO TO 100
      WRITE(MSG,54)
   54 FORMAT(' *** NOTE -- CULVERT INPUT PRESUMED COMPLETE.')
      CALL CULWRP(XPOOL(IPTMSC+6,JCIB), XPOOL(IPTABG+1,JCIB), IERXS)
      RETURN
  100 CONTINUE
C
      IF(IXTYPE.GE.2) CALL XSPRP3(ISEQ,IXTYPE, XPOOL(1,JPCX),
     $       XPOOL(1,JCIB), XPOOL(1,JBXX) )
      XPOOL(4,JPCX) = 0.
      XPOOL(5,JPCX) = 0.
      I1 = IPTFL+1
      I2 = IPTMSC - 1
      DO 116 I = I1,I2
  116 XPOOL(I,JPCX) = -1.1E32
      I1 = IPTMSC+6
      DO 118 I = I1,IPTEND
  118 XPOOL(I,JPCX) = -1.1E32
      GO TO 200
C
  120 CONTINUE
      CALL XSRTRV(ISEQ,I,I,XPOOL,SRDJ)
      IF(SRD.LT.-1E30) SRD = SRDJ
      IF( IBLDBR + IBLDSD .GT. 0 )  CALL XSPRP3(ISEQ,IXTYPE,
     $       XPOOL(1,JPCX),XPOOL(1,JCIB), XPOOL(1,JBXX) )
      XPOOL(5,JPCX) = 2.*XPOOL(5,JPCX)
  200 CONTINUE
      SRDJ = XPOOL(IPTMSC+0,JPCX)
      IF(SRDJ.LT.-1E30)  SRDJ = SRD
C ...................
C
      IF(XPOOL(1,JCIB).LT.0) CALL XSTPTX(XPOOL(1,JCIB),XPOOL(1,JTPV),
     $       XPOOL(1,JPCX) )
C                   --  EXPAND TEMPLATE VECTOR IN C.I.B --
      NGP2 = XPOOL(1,JCIB)
      NGP  = NGP2/2
      XPOOL(1,JCIB) = NGP
      IF( 2*NGP .EQ. NGP2 )  GO TO 207
      WRITE( MSG , 203) NGP2, NGP
  203 FORMAT(' +++033 MISSING EITHER X OR Y VALUE(S) IN GR CARD ',
     $        'DATA -',2I8)
      IERXS = 1
 207  CONTINUE
C
      IF( IXTYPE .NE. 6 ) CALL XSRUFF ( XPOOL(1,JPCX),
     $                                     XPOOL(1,JCIB), IERXS )
C
      DO 210 I = 1,IPTXY
        IF( XPOOL(I,JCIB) .NE. 0. ) XPOOL(I,JPCX) = XPOOL(I,JCIB)
 210  CONTINUE
C
      ISIZE = IPTEND - IPTXY
      CALL PUTBIN ( XPOOL(IPTXY+1,JCIB), ISIZE,
     $                       XPOOL(IPTXY+1,JPCX), NOSHUF, ISIZE )
      IF( IHFNO2 .GE. 0 ) XPOOL(IPTMSC+2,JPCX) = IHFNO2
      IF( IBLDBR .GT. 0 ) XPOOL(IPTMSC+14,JPCX) =
     $                                      XPOOL(IPTMSC+14,JCIB)
C
      IF( IXTYPE .NE. 6 ) GO TO 220
C            -- COPY MODIFIED CULVERT BACK TO CIB --
      CALL MOVEO(XPOOL(1,JPCX),XPOOL(1,JCIB),0,IPTEND)
      RETURN
C
  220 CONTINUE
C
      NGP = XPOOL(1,JPCX)
C
      IF( XPOOL(1,JCIB) .GT. 0 ) GO TO 2020
C
C     adjust elevations of propagated cross section data for
C     valley slope
C
      NGP2 = 2 * NGP
      IF( NGP2 .LT. 2 ) GO TO 2020
      SLOPE = XPOOL(IPTMSC+5,JPCX)
      IF( ABS( SLOPE ) .LT. 1E5 ) THEN
C       adjust elevations using specified or propagated SLOPE
        YSHIFT = SLOPE * ( SRD - SRDJ )
C
      DO 1010 I = 2,NGP2,2
        XPOOL(IPTXY+I,JPCX) = XPOOL(IPTXY+I,JPCX) + YSHIFT
 1010 CONTINUE
C
      ELSE
C       no adjustment to be made
      ENDIF
C
 2020 CONTINUE
C
      IF( NGP .LE. 0 ) NGP = 1
C
      IF( IBLDBR .GT. 0 )
     $ CALL XBLDBR(XPOOL(IPTXY+1,JPCX),NGP,XPOOL(IPTMSC+1,
     $              JPCX), XPOOL(IPTABG+1,JPCX), IERXS)
C
      IF(IXTYPE.EQ.2 .AND. XPOOL(IPTMSC+14,JPCX).LT.-1E30)
     $        XPOOL(IPTMSC+14,JPCX) = +1.1E32
C
      IF(IBLDSD.GT.0)
     $ CALL XBLDSD(XPOOL(IPTXY+1,JPCX),NGP,SRD,XPOOL(IPTMSC+1,
     $              JPCX), IERXS)
C
C  REV 01/85 JOS -- IN DESIGN MODE ONLY, PROPOGATE SKEW FROM FULL
C                   VALLEY TO BRIDGE AND SPUR DIKE XSECS.
C
      IF(IXTYPE .EQ. 2 .AND. IBLDBR .GT. 0)
     $    XPOOL(IPTMSC+1,JPCX) = XPOOL(IPTMSC+1,JBXX)
      IF(IXTYPE .EQ. 3 .AND. IBLDSD .GT. 0)
     $    XPOOL(IPTMSC+1,JPCX) = XPOOL(IPTMSC+1,JBXX)
      IF(IXTYPE .NE. 2 .AND. IXTYPE .NE. 3)
     $    XPOOL(IPTMSC+1,JPCX) = XPOOL(IPTMSC+1,JCIB)
C
      XPOOL(1,JPCX) = NGP
      NGP2 = 2 * XPOOL(1,JPCX)
      CALL XYMNMX ( XPOOL(IPTXY+1,JPCX), NGP2 )
      YMIN = XPOOL(IPTXY+NGP2+4,JPCX)
C
C  PIER AREA ELEVATION TABLE ---
      FN = XPOOL(5,JPCX)
      FN = PIERVC(FN,XPOOL(IPTPEA+1,JPCX), YMIN)
      XPOOL(5,JPCX) = FN
      IF(FN.LT.0.) IERXS = IERXS + 800
C
C  CHECK STATIONING/CLOSURE OF XY DATA
      IF(IXTYPE.EQ.2) GO TO 9930
      DX = XPOOL(IPTXY+NGP2-1,JPCX)-XPOOL(IPTXY+1,JPCX)
      DO 9915 I=3,NGP2,2
      IF((XPOOL(IPTXY+I,JPCX)-XPOOL(IPTXY+I-2,JPCX))/DX
     $     .LT. 0.0 ) GO TO 9920
 9915 CONTINUE
      RETURN
 9920 IERXS=9920
      WRITE(MSG,9921) XPOOL(IPTXY+I,JPCX)
 9921 FORMAT(' +++032 ERROR:  XSEC STATION REVERSAL AT X =',F10.1)
      RETURN
 9930 IF(XPOOL(IPTXY+NGP2-1,JPCX).EQ.XPOOL(IPTXY+1,JPCX)
     $  .AND. XPOOL(IPTXY+NGP2,JPCX).EQ.XPOOL(IPTXY+2,JPCX)
     $   ) RETURN
      IERXS = 9930
      WRITE(MSG,9931)
 9931 FORMAT(' +++035 ERROR:  BRIDGE OPENING XSEC MUST BE CLOSED.')
      RETURN
      END
      SUBROUTINE CULWRP(COEF,DIMENS,IER)
C  WRAPS UP DEFINITION OF CULVERT SECTION --
C  DECODES THREE-DIGIT CULVERT CODE, LOOKS UP COEFFICIENTS,
C  AND DETERMINES APPROXIMATE PIPE-ARCH DIMENSIONS.
      DIMENSION  COEF(10), DIMENS(5)
      DIMENSION ICOFLI(35), IEQLIS(35), CKELIS(35), ALPHA(3,2)
      DATA  NLIST / 35 /
      DATA ICOFLI / 111,  112,  113,  114,  115,  116,  117,
     $  211,  212,  213,  214,  215,  225,  216,  226,  217,  227,
     $  221,  222,  223,
     $  311,  312,  313,  321,  322,  323,  331,  324,  325,  326,
     $  332,  327,  328,  329,  333 /
      DATA IEQLIS /   1,    2,    3,    4,    5,    6,    7,
     $    1,    2,    3,    4,    5,    5,    6,    6,    7,    7,
     $    8,    9,   10,
     $    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
     $   11,   12,   13,   14,   15 /
      DATA CKELIS /  .4,   .5,   .5,   .7,   .2,   .2,   .2,
     $   .2,   .2,   .5,   .5,   .5,   .5,   .2,   .2,   .2,   .2,
     $   .9,   .7,   .5,
     $   .5,   .2,   .2,   .9,   .9,   .9,   .9,   .7,   .7,   .7,
     $   .7,   .5,   .5,   .5,   .5  /
      DATA  ALPHA / 1.00, 1.04, 1.05,   -1E32, 1.12, 1.16  /
      DATA  MSG / 6 /
C
      ISHAPE =-99
      IF(ABS(COEF(1)).LE.10000) ISHAPE = COEF(1)+.5
      IF(ISHAPE.LE.3) ISHAPE = 100*ISHAPE + 11
      DO 20 I=1,NLIST
      IF(ISHAPE.EQ.ICOFLI(I)) GO TO 40
   20 CONTINUE
      IER = 6001
      WRITE(MSG,6001) ISHAPE,COEF(1)
 6001 FORMAT(' +++036 CULVERT CODE INVALID -',I8, F12.1)
C
   40 IEQNO = IEQLIS(I)
      CKE   = CKELIS(I)
      MATRL = MOD(ISHAPE/10,10)
      ISHAPE = ISHAPE/100
      CN = .035
      IF(MATRL.EQ.1) CN = .012
      I = 1
      IF(MATRL.GT.1) I = 2
      CVALPH = ALPHA(ISHAPE,I)
C
      COEF(1) = ISHAPE
      IF(COEF(2).LE.0.) COEF(2) = IEQNO
      IF(COEF(3).LE.0.) COEF(3) = CKE
      IF(COEF(4).LE.0.) COEF(4) = CVALPH
      IF(COEF(5).LE.0.) COEF(5) = CN
      IF(COEF(6).LT.1.) COEF(6) = 1.
      IF(COEF(7).GT.0. .AND. COEF(8).GT.-1E30 .AND.
     $       COEF(9).GT.-1E30)    GO TO 55
      IER = 6003
      WRITE(MSG,6003) (COEF(I),I=7,9)
 6003 FORMAT(' +++037 CULVERT LENGTH/INVERT INVALID -',3F10.2)
      IF(COEF(7).EQ.0.) COEF(7) = -1.1E32
   55 CONTINUE
C
      IF(DIMENS(1).LE.0.) GO TO 770
      GO TO (610, 620, 630), ISHAPE
      STOP 6004
  610 IF(DIMENS(2).LE.0.) GO TO 770
      GO TO 625
  620 IF(DIMENS(2).GT.0. .AND. DIMENS(2).NE.DIMENS(1)) GO TO 770
      DIMENS(2) = 0.
  625 DO 628 I = 3, 5
  628 DIMENS(I) = 0.
      RETURN
  630 IF(DIMENS(2).LE.DIMENS(1)) GO TO 770
      DO 633 I=3,5
      IF(DIMENS(I).GT.0.) GO TO 660
  633 CONTINUE
      IF(COEF(2).LT.1..OR.COEF(2).GT.15.) STOP 6005
      IEQNO = COEF(2)+.5
      JSHAPE = MOD(IEQNO,4) + 1
      IF(IEQNO.LE.3) JSHAPE = 5
      CALL CULPAD(JSHAPE,DIMENS)
  660 DO 665 I=3,5
      IF(DIMENS(I).LE.0.)  GO TO 670
  665 CONTINUE
      RETURN
  670 IER = 6008
      WRITE(MSG,6008) (DIMENS(I),I=3,5)
 6008 FORMAT(' +++038 CULVERT PIPE-ARCH AUXILIARY DIMENSIONS ',
     $    'INVALID -',3F9.1)
      RETURN
C
  770 IER = 6007
      WRITE(MSG,6007) DIMENS(1),DIMENS(2),ISHAPE
 6007 FORMAT(' +++039 CULVERT RISE/SPAN INVALID FOR SHAPE -',2F9.1,I4)
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSPRP3>>>>>
C     <<<<<LAST REVISED 05-20-88>>>>>
C
      SUBROUTINE   XSPRP3 ( ISEQ, IXTYPE, PCX, CIB, BXX )
C
C     Retrieve full-valley section data for building bridge
C     section; retrieve full-valley and bridge section data
C     for building spur dike section.
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      COMMON / DRCTRY / NXSECS, MXXSEC, IXTYPV(100),
     $                           IXIERV(100), SRDV(100), WSC(100)
C
      DIMENSION PCX(IPTEND), CIB(IPTEND), BXX(IPTEND)
C
      DATA MSG / 6 /
C
C     Scan directory in downstream direction to locate
C     full-valley section (IXTYPV = 0 or 1)
C
C     Modified 5-20-88 (DO 10 ... loop) to correct V020188 error
C     in determining JSEQ - J.O.S.
C
      JSEQ = 0
      NN = ISEQ
      IF( NN .LE. 0  .OR.  NN .GT. NXSECS ) NN = NXSECS
C
      DO 10 IDO = 1,NN
        NSEQ = NN + 1 - IDO
        IF( IXTYPV(NSEQ) .NE. 0
     $                     .AND.  IXTYPV(NSEQ) .NE. 1 ) GO TO 10
        JSEQ = NSEQ
        GO TO 30
 10   CONTINUE
C
        WRITE(MSG,20)
 20     FORMAT(//' +++040 FULL VALLEY SECTION NOT ON FILE --',
     $                                        ' ABORTIVE ERROR.')
        STOP 140
C
 30   CONTINUE
C
      IF( IXTYPE .EQ. 3 ) THEN
C
C       Retrieve bridge section
C
        I = ISEQ - 1
        IF( ISEQ .LE. 0 ) I = NXSECS
        CALL XSRTRV ( I, JUNK, JUNK, BXX, SRD )
        CIB(IPTMSC+9) = BXX(IPTMSC+9)
        CIB(IPTMSC+10) = BXX(IPTMSC+10)
        IBXX = IPTXY + 2 * BXX(1)
        CIB(IPTMSC+11) = BXX(IBXX+1)
        CIB(IPTMSC+12) = BXX(IBXX+6)
        CIB(IPTMSC+13) = BXX(IBXX+3)
        CIB(IPTMSC+14) = BXX(IBXX+8)
        CIB(IPTMSC+15) = BXX(IPTMSC+0)
C
      ELSE
      ENDIF
C
C     Retrieve full-valley section
C
      CALL XSRTRV (JSEQ, JUNK, JUNK, BXX, SRDJ )
      PCX(1) = BXX(1)
      NGP2 = 2 * PCX(1)
      CALL MOVEO ( BXX, PCX, IPTXY, NGP2 )
      PCX(IPTMSC+0) = SRDJ
C
      IF( ISEQ .LE. 0 ) THEN
        IF( IXTYPE .NE. 3 ) THEN
          PCX(2) = BXX(2)
          PCX(3) = BXX(3)
          PCX(6) = BXX(6)
          CALL MOVEO ( BXX, PCX, IPTRGH, IPTFL-IPTRGH )
        ELSE
        ENDIF
      ELSE
      ENDIF
C
      RETURN
      END
      SUBROUTINE XBLDBA(XTOE,YTOE,ABRUN, ELC,BSLOPE,
     $     XLC, XINTER,YINTER)
C  LOCATES INTERSECTION OF ABUTMENT AND LOWER CHORD OF BRIDGE
C  GIVEN ABUTMENT TOE COORDINATES AND ABTMNT RUN/UNIT RISE.
C  AND GIVEN ELEV OF LOWER CHORD(ELC), BRIDGE DECK SLOPE, AND
C  X-COORDINATE(XLC) IF BSLOPE IS NON-ZERO.
C  USER IS RESPONSIBLE FOR SUPPLYING PROPER ALGEBRAIC SIGN FOR
C  LEFT AND RIGHT ABUTMENT SLOPES.
C
      IF(ABS(ABRUN) .GT. 0.01) GO TO 100
      XINTER = XTOE
      YINTER = ELC + BSLOPE*(XINTER-XLC)
      RETURN
C
  100 ASLOPE = 1./ABRUN
      IF(ASLOPE.EQ.BSLOPE)  STOP 107
      ELC2 = ELC
      IF(BSLOPE.NE.0.) ELC2 = ELC2 - BSLOPE*XLC
      XINTER = ((YTOE-ASLOPE*XTOE) - ELC2)/(BSLOPE-ASLOPE)
      YINTER = ELC2 + BSLOPE*XINTER
      RETURN
      END
C                                     <<<<<SUBPROGRAM XBLDBB>>>>>
C     <<<<<LAST REVISED 05-20-88>>>>>
C
      SUBROUTINE   XBLDBB ( XA, YA, RSA, XY, NGP, XT,
     $                                            YT, IT, IER )
C
C     Locate abutment toe (XT,YT) on ground (XY,NGP) by downward
C     projection from end of lower chord (XA,YA) at slope 1./RSA.
C
C     Modified 5-20-88 (Statement Nos. 140+2 and 155+3) to
C     eliminate duplicated coordinates when channel bank slope
C     was identical to abutment slope - J.O.S.
C
      DIMENSION XY(2,NGP)
      DATA MSG / 6 /
C
      IF(XY(1,1).GT.XA) GO TO 113
      DO 110 I = 2, NGP
      IF(XY(1,I).GE.XA)  GO TO 120
  110 CONTINUE
  113 IER = 113
      WRITE(MSG,114) XA,XY(1,1),XY(1,NGP)
  114 FORMAT(' +++041 ABUTMENT TOP STATION OUTSIDE VALLEY LIMITS -',
     $   3F10.1)
      RETURN
  120 YHAT = XY(2,I-1)+((XA-XY(1,I-1))/(XY(1,I)-XY(1,I-1)))*
     $          (XY(2,I)-XY(2,I-1))
      IF(ABS(RSA) .GT. 0.01) GO TO 130
      XT = XA
      YT = YHAT
      IT = I
      IF(RSA .GT. 0.0) GO TO 125
  122 IF( XT .LT. XY(1,IT) ) RETURN
      YT = XY(2,IT)
      IT = IT + 1
      GO TO 122
  125 IT = IT - 1
      RETURN
  130 IF(YA.LT.YHAT) GO TO 193
      SA = 1./RSA
      IF(SA.GT.0.)  GO TO 150
  140 CONTINUE
      YHAT = YA + SA*(XY(1,I)-XA)
      IF(YHAT.LT.XY(2,I))  GO TO 170
      I=I+1
      IF(I.LE.NGP) GO TO 140
      GO TO 197
  150 CONTINUE
  155 I = I - 1
      IF(I.LE.0)  GO TO 197
      YHAT = YA + SA*(XY(1,I)-XA)
      IF(YHAT.GE.XY(2,I)) GO TO 155
      S = (XY(2,I+1)-XY(2,I))/(XY(1,I+1)-XY(1,I))
      GO TO 175
  170 S = (XY(2,I)-XY(2,I-1))/(XY(1,I)-XY(1,I-1))
  175 XT = XY(1,I) - (XY(2,I)-YHAT)/(S-SA)
      YT = YA + SA*(XT-XA)
      IT = I
      RETURN
C
  193 IER = 193
      WRITE(MSG,194) XA,YA,YHAT
  194 FORMAT(' +++042 ABUTMENT TOP STATION BELOW GROUND SURFACE -',
     $     3F10.1)
      RETURN
  197 IER = 197
  198 FORMAT(' +++043 ABUTMENT TOP STATION ABOVE VALLEY ',
     $     'END-POINT -'/6F10.1)
      I = NGP - I
      IF(I.LE.0) I = 1
      WRITE(MSG,198) XA,YA,RSA,XY(1,I),XY(2,I),YHAT
      RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #4 OF PC VERSION +++++
      SUBROUTINE XBLDBC(XATLT,YATLT,XABLT2,YABLT2,IABLT2,
     $      IABRT2,XABRT2,YABRT2,XATRT,YATRT, XY, NGP)
C  RECONSTRUCT X-Y CROSS SECTION USING CALCULATED
C  ABUTMENT TOP AND BOTTOM COORDINATES.
      DIMENSION  XY(2,NGP)
      IF(IABLT2.GE.3) GO TO 330
      J = IABRT2
      DO 310 I=IABLT2,IABRT2
      XY(1,J+1) = XY(1,J)
      XY(2,J+1) = XY(2,J)
  310 J = J - 1
      IABLT2 = IABLT2 + 1
      IABRT2 = IABRT2 + 1
  330 NGP = IABRT2-IABLT2+1+5
      XY(1,1) = XATLT
      XY(2,1) = YATLT
      XY(1,2) = XABLT2
      XY(2,2) = YABLT2
      IF(IABLT2.LE.3) GO TO 350
      J = 3
      DO 340 I=IABLT2,IABRT2
      XY(1,J)=XY(1,I)
      XY(2,J)=XY(2,I)
  340 J = J + 1
  350 CONTINUE
      XY(1,NGP-2)=XABRT2
      XY(2,NGP-2)=YABRT2
      XY(1,NGP-1)=XATRT
      XY(2,NGP-1)=YATRT
      XY(1,NGP)=XY(1,1)
      XY(2,NGP)=XY(2,1)
      RETURN
      END
      SUBROUTINE  XBLDBR(XY,NGP,XMSC,ABG,IER)
      DIMENSION XY(2,NGP), XMSC(NGP), ABG(NGP)
      DATA MSG / 6 /
C  STATEMENT FUNCTION --
      YBLOCH(X)= BRELEV-GIRDEP+BSLOPE*(X-BXSTA)
C
      BRLEN = ABG(1)
      BRCENT = ABG(2)
      GIRDEP = ABG(5)
      BRELEV = ABG(6)
      BSLOPE = ABG(7)
      IF(BSLOPE.LT.-1E30)  BSLOPE = 0.
      BXSTA = ABG(8)
      IF(BXSTA.LT.-1E30.AND.BSLOPE.EQ.0.) BXSTA = 0.
      XABLT = ABG(9)
      XABRT = ABG(10)
      IF(XABRT.LT.-1E30) XABRT = -XABRT
      ABSLPL = XMSC(9)
      ABSLPR = XMSC(10)
      IF(ABSLPL.LT.-1E30) ABSLPL = 0.0
      IF(ABSLPR.LT.-1E30) ABSLPR = ABSLPL
      IF(ABSLPL.EQ.0.) ABSLPL= -.0001
      IF(ABSLPR.EQ.0.) ABSLPR = +.0001
C  FIND LIMITING ABUTMENT TOE COORDS
      CALL XBLDBB(XABLT,0.,0.,XY,NGP,XJUNK,YABLT,I,IER)
      CALL XBLDBB(XABRT,0.,0.,XY,NGP,XJUNK,YABRT,I,IER)
C  PROJECT BACK UP FROM TOE
      IF(ABSLPL.GT.0.) ABSLPL=-ABSLPL
      CALL XBLDBA(XABLT,YABLT,ABSLPL,BRELEV-GIRDEP,
     $          BSLOPE,BXSTA,XATLT,YATLT)
      CALL XBLDBA(XABRT,YABRT,ABSLPR,BRELEV-GIRDEP,
     $          BSLOPE,BXSTA,XATRT,YATRT)
C  POSITION THE BRIDGE
      SLACK = BRLEN - (XATRT-XATLT)
      IF(SLACK .GT. 0.0) GO TO 215
      IF(ABS(SLACK) .LT. 0.01) GO TO 215
      WRITE(MSG,213) BRLEN,XATLT,XATRT
  213 FORMAT(' +++044 BRIDGE TOO SHORT FOR SELECTED ABUTMENTS -',
     $    3F10.1)
      IER = 213
      RETURN
  215 IF(BRCENT.GT.1.5) GO TO 228
      IF(BRCENT.GT.0.5) GO TO 224
      XATRT = XATRT+.5*SLACK
      XATLT=XATLT-.5*SLACK
      YATRT=YBLOCH(XATRT)
      YATLT=YBLOCH(XATLT)
      GO TO 230
  224 XATLT=XATLT-SLACK
      YATLT=YBLOCH(XATLT)
      GO TO 230
  228 XATRT=XATRT+SLACK
      YATRT=YBLOCH(XATRT)
  230 CONTINUE
C  CALC FINAL ABUTMENT TOE COORDS
      CALL XBLDBB(XATLT,YATLT,ABSLPL,XY,NGP,
     $     XABLT2,YABLT2,IABLT2,IER)
      CALL XBLDBB(XATRT,YATRT,ABSLPR,XY,NGP,
     $     XABRT2,YABRT2,IABRT2,IER)
C  REBUILD XY OUTLINE VECTOR
      CALL XBLDBC(XATLT,YATLT,XABLT2,YABLT2,IABLT2,
     $     IABRT2,XABRT2,YABRT2,XATRT,YATRT,XY,NGP)
C  SAVE ABTMNT TOE ELEVS FOR DISCH COEFF CALC
      XMSC(15) = YABLT2
      XMSC(16) = YABRT2
C  ALSO SUBEL...  BUT -- LET SUBEL FROM BR CARD OVERRIDE COMPUTATION
      IF(ABS(XMSC(14)).GT.1.0E05)
     $                       XMSC(14) = (YATLT+YATRT)/2.
      ABG(12)=XABLT2
      ABG(13)=XABRT2
      RETURN
      END
      SUBROUTINE XBLDSD(XY,NGP,SRD,XMSC,IER)
C  SPUR DIKE BUILDER
      DIMENSION XY(2,NGP), XMSC(NGP)
      VSLOPE = XMSC(5)
      OFFST2  = XMSC(8)
      ABSLPL  = XMSC(9)
      ABSLPR = XMSC(10)
      XRT = XMSC(11)
      YRT = XMSC(12)
      XLT = XMSC(13)
      YLT = XMSC(14)
      SRDBR = XMSC(15)
      DY = (SRD-SRDBR)*VSLOPE
      XLT = XLT - OFFST2
      XRT = XRT + OFFST2
      YLT = YLT + DY
      YRT = YRT + DY
      IF(ABSLPL.EQ.0.)  ABSLPL = -.0001
      IF(ABSLPR.EQ.0.)  ABSLPR = +.0001
      IF(ABSLPL.LT.-1E30) ABSLPL = -.0001
      IF(ABSLPR.LT.-1E30) ABSLPR = +.0001
      IF(ABSLPL.GT.0.)  ABSLPL = -ABSLPL
      CALL XBLDBB(XLT,YLT,ABSLPL,XY,NGP,XLB,YLB,ILB,IER)
      CALL XBLDBB(XRT,YRT,ABSLPR,XY,NGP,XRB,YRB,IRB,IER)
      CALL XBLDBC(XLT,YLT,XLB,YLB,ILB,
     $      IRB,XRB,YRB,XRT,YRT,XY,NGP)
      NGP = NGP - 1
      RETURN
      END
      SUBROUTINE  XBLDVC(PIV, XYV, NXY)
C
C  BUILDS A VERTICAL CURVE GIVEN P.I.S AND V.C. LENGTH
C
C      PIV = INPUT VECTOR OF P.I. COORDINATES AND
C              VERT CURVE LENGTHS
C             PIV LAYOUT -- X1,Y1,--,X0,Y0,VCL,X2,Y2,--.
C      XYV = OUTPUT VECTOR OF X-Y COORDINATES AT P.T.S
C              AND 1/4-POINTS.
C      NXY = OUTPUT NUMBER OF X-Y POINTS GENERATED.
C              = 5  UNLESS VCL=0., WHEN IT = 1
C
C   IF VCL .LT. 0., DEFAULT LENGTH IS COMPUTED
C   IF VCL .EQ. 0., ONLY THE P.I. IS GENERAED IN XYV.
C
C
      COMMON /IPTCB1/  IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      DIMENSION  PIV(IPTEND),  XYV(IPTEND)
C
C  DEFAULT VERT CURVE LENGTH COEFFS FORM AASHTO
C       MIN STOP DIST 70 MPH
      DATA  SAGK, CRESTK /  145.,  255./
C
      S1 = (PIV(5)-PIV(2))/(PIV(4)-PIV(1))
      S2 = (PIV(8)-PIV(5))/(PIV(7)-PIV(4))
      VCL = PIV(6)
      IF(VCL.GE.0.)  GO TO 10
      VCL = SAGK*100.*(S2-S1)
      IF(S1.GT.S2) VCL = CRESTK*100.*(S1-S2)
   10 IF(VCL.GT.0.)  GO TO 20
      XYV(1) = PIV(4)
      XYV(2) = PIV(5)
      NXY = 1
      RETURN
   20 NXY = 5
      DO 30 I = 1, 5
      XI = -1.+(I-1)/2.
      XYV(2*I-1) = PIV(4) + XI*VCL/2.
   30 XYV(2*I  ) = PIV(5) + (VCL/8.)*(S2*(1.+XI)**2
     $                -  S1*(1.-XI)**2)
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSTPTX>>>>>
C     <<<<<LAST REVISED 01-13-88>>>>>
C
      SUBROUTINE   XSTPTX ( CIB, TPLT, PCX )
C
C          EXPANDS TEMPLATE SECTION IN CURRENT INPUT BUFF CIB.
C          NOTE THAT TEMPLATE SRD IS STORED IN TEMPLATE VECTOR AT
C          IPTMSC+0; ALSO NOTE THAT TPLT(1) IS THE TOTAL NUMBER
C          OF X AND Y COORDINATE VALUES (I.E., 2*NGP).
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      DIMENSION  TPLT(IPTEND), CIB(IPTEND), PCX(IPTEND)
C
      DATA MSG / 6 /
C
C  STATEMENT FUNCTIONS --
C
      IX(I) = IPTXY + ( 2 * I ) - 1
      IY(I) = IPTXY + ( 2 * I )
      XFUN(T) = XORG + SCALE * ( T - XORG )
C
      TPLT1 = TPLT(IX(1))
      NGP2 = TPLT(1)
      NGP = NGP2 / 2
      SRD = CIB(IPTMSC+0)
      SRDT = TPLT(IPTMSC+0)
      SLOPE = 0.0
C
      IF( ABS( CIB(IPTMSC+5) ) .LT. 1E5 ) THEN
C       use SLOPE from current input buffer
        SLOPE = CIB(IPTMSC+5)
      ELSE  IF( ABS( TPLT(IPTMSC+5) ) .LT. 1E5 ) THEN
C       use SLOPE from template section
        SLOPE = TPLT(IPTMSC+5)
      ELSE  IF( ABS( PCX(IPTMSC+5) ) .LT. 1E5 ) THEN
C       use SLOPE from previous section
        SLOPE = PCX(IPTMSC+5)
      ENDIF
C
      CIB(IPTMSC+5) = SLOPE
C
      IF( ABS( CIB(IPTXY+5) ) .LT. 1E5 ) THEN
C       use specified XORG as origin
        XORG = CIB(IPTXY+5)
      ELSE
C       use left bank station as origin
        XORG = TPLT1
      ENDIF
      IF( ABS( CIB(IPTXY+4) ) .LT. 1E5 ) THEN
C       use specified SCALE to stretch/shrink section
        SCALE = CIB(IPTXY+4)
        ELSE
C       do not stretch/shrink section
        SCALE =  1.0
      ENDIF
C
      IF( SCALE .GT. 0.0 ) THEN
C       do nothing
      ELSE
C       print error message and exit this subroutine
        WRITE(MSG,10) SCALE
 10     FORMAT(' +++045 TEMPLATE EXPANSION ERROR:  NEGATIVE ',
     $                                    'SCALE FACTOR -',F10.2)
        CIB(1) = -99.
        GO TO 80
      ENDIF
C
      IF( ABS( CIB(IPTXY+3) ) .LT. 1E5 ) THEN
C       use specified XLIMR (adjusted for SCALE and XORG) for
C       'chop-off' point on right bank
        XLIMR = XFUN( CIB(IPTXY+3) )
      ELSE
C       no 'chop-off' specified, set XLIMR = '+ infinity'
        XLIMR = 1.1E32
      ENDIF
C
      IF( ABS( CIB(IPTXY+2) ) .LT. 1E5 ) THEN
C       use specified XLIML (adjusted for SCALE and XORG) for
C       'chop-off' point on left bank
        XLIMl = XFUN( CIB(IPTXY+2) )
      ELSE
C       no 'chop-off' specified, set XLIML = '- infinity'
        XLIML = -1.1E32
      ENDIF
C
      IF( ABS( CIB(IPTXY+1) ) .LT. 1E5 ) THEN
C       use specified YSHIFT, not SLOPE, for elev adj.
           YSHIFT = CIB(IPTXY+1)
           SLOPE = 0.0
        ELSE
C          YSHIFT not specified, use SLOPE for elev adj.
           YSHIFT = 0.
      ENDIF
C
      YSHIF2 = YSHIFT + SLOPE * ( SRD - SRDT )
      YBANKS = TPLT(IPTXY+NGP2+2) + YSHIF2
      J = 0
C
      DO 20 K = 1,NGP
        I = K
        XHAT = XFUN( TPLT(IX(I)) )
        IF( XHAT .GT. XLIML ) GO TO 40
 20   CONTINUE
C
C       print error message and exit this subroutine
        WRITE(MSG,30) I, XHAT,XLIML
 30     FORMAT(' +++046 ERROR:  ALL POINTS DELETED BY ',
     $                               'MODIFICATION -'/I10,2F12.1)
        CIB(1) = -97.
        GO TO 80
C
 40   CONTINUE
C
      IF( I .EQ. 1 ) THEN
C       carry on
      ELSE
C       place vertical wall at XLIML
        J = 1
        CIB(IY(J)) = YBANKS
        CIB(IX(J)) = XLIML
        J = 2
        X0 = XFUN( TPLT(IX(I-1)) )
        Y0  = TPLT(IY(I-1))
        CIB(IY(J)) = Y0 + YSHIF2 + ( (TPLT(IY(I)) - Y0 ) *
     $                           ( XLIML - X0 ) / ( XHAT - X0 ) )
        CIB(IX(J)) = XLIML
      ENDIF
C
      K1 = I
C
      DO 50 K = K1,NGP
        I = K
        J = J+1
        IF( I .NE. K1 ) XHAT = XFUN( TPLT(IX(I)) )
        IF( XHAT .GE. XLIMR ) THEN
C         place vertical wall at XLIMR
          X0 = XFUN( TPLT(IX(I-1)) )
          Y0 = TPLT(IY(I-1))
          CIB(IY(J)) = Y0 + YSHIF2 + ( ( TPLT(IY(I)) - Y0 ) *
     $                           ( XLIMR - X0 ) / ( XHAT - X0 ) )
          CIB(IX(J)) = XLIMR
          J = J + 1
          CIB(IY(J)) = YBANKS
          CIB(IX(J)) = XLIMR
          GO TO 60
        ELSE
C         transfer specified coordinates
          CIB(IY(J)) = TPLT(IY(I)) + YSHIF2
          CIB(IX(J)) = XHAT
        ENDIF
C
 50   CONTINUE
C
 60   CIB(1) = 2*J
C
      IF( CIB(2) .GT. 0.0 ) GO TO 80
      NSA = TPLT(2)
      IF( NSA .LE. 0 ) GO TO 80
      CIB(2) = NSA
      NXSA = NSA - 1
      CIB(IPTRGH+NXSA) = 1.1E32
      IF( NSA .GT. 1 ) THEN
C
        DO 70 I = 1,NXSA
          CIB(IPTRGH+I) = XFUN( TPLT(IPTRGH+I) )
 70     CONTINUE
C
      ELSE
      ENDIF
C
 80   CONTINUE
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSRUFF>>>>>
C     <<<<<LAST REVISED 01-22-88>>>>>
C
      SUBROUTINE   XSRUFF ( PCX, CIB, IERRUF )
C
C          Determine appropriate combination of roughness data
C          from current input buffer (CIB) and previous cross
C          section (PCX) arrays at XSWRAP-up time.
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      DIMENSION PCX(IPTEND), CIB(IPTEND)
C
      DATA MSG / 6 /
C
      MXSA = ( IPTFL - IPTRGH ) / 5
      IERRUF = 0
C
      LSA = PCX(2)
      LRD = PCX(3)
      LNV = PCX(6)
C
      ISA = CIB(2)
      IRD = CIB(3)
      INV = CIB(6)
C
      INCODE = 0
      IF( ISA .GT. 0 ) INCODE = INCODE + 1
      IF( INV .GT. 0 ) INCODE = INCODE + 2
      IF( IRD .GT. 0 ) INCODE = INCODE + 4
C
      IF( INCODE .LE. 3 ) THEN
C       Assume a single subarea, no depth breakpoints
        NSA = 1
        NRD = 0
      ELSE
C       Assume NSA = # of pairs of ND data input
        NSA = IRD / 2
        NRD = 2
C         Check for even number (pairs) of input values
          IF( IRD - ( 2 * NSA ) .NE. 0 ) GO TO 5001
      ENDIF
C
      GO TO ( 1111, 2222, 3333, 4444, 5555, 6666, 6666 ), INCODE
C
      WRITE(MSG,10)
 10   FORMAT(' *** NO ROUGHNESS DATA INPUT, WILL PROPAGATE ',
     $                            'FROM PREVIOUS CROSS SECTION.')
      IF( ( LSA + LRD + LNV ) .LE. 0 ) GO TO 5002
      GO TO 9999
C
 1111 CONTINUE
C
C            INCODE = 1 / only SA data are input
C
      IF( ISA .GT. 1 ) NSA = ISA
      IF( LRD .EQ. 2 ) NRD = 2
      IF( NSA .NE. LSA ) GO TO 5002
      GO TO 7500
C
 2222 CONTINUE
C
C            INCODE = 2 / only N data are input
C
      IF( INV .EQ. 1 ) GO TO 7500
      NSA = INV
      IF( LRD .EQ. 0 ) GO TO 201
      IF( NSA .EQ. LSA ) GO TO 7500
      NSA = INV / 2
      NRD = 2
      IF( ( INV - ( 2 * NSA ) ) .NE. 0 ) GO TO 5001
C
 201  CONTINUE
C
      IF( NSA .NE. LSA ) GO TO 5002
      GO TO 7500
C
 3333 CONTINUE
C
C            INCODE = 3 / only SA and N data are input
C
      IF( ISA .GT. 1 ) NSA = ISA
      IF( INV .NE. NSA  .AND.  INV .NE. ( 2 * NSA ) ) GO TO 5001
      IF( INV .EQ. ( 2 * NSA ) ) NRD = 2
      IF( NRD .EQ. 0 ) GO TO 7500
      IF( NSA .NE. LSA  .OR.  LRD .NE. 2 ) GO TO 5002
      GO TO 7500
C
 6666 CONTINUE
C
C            INCODE = 7 / all roughness data are input
C            INCODE = 6 / only N and ND data are input
C            Check consistency of N and ND input
C
      IF( IRD .NE. INV ) GO TO 5001
      IF( INCODE .EQ. 6 ) GO TO 4444
C
 5555 CONTINUE
C
C            INCODE = 5 / only SA and ND data are input
C            Check consistency of SA and ND input
C
      IF( NSA .EQ. 1 ) GO TO 7500
      IF( NSA .NE. ISA ) GO TO 5001
      IF( INCODE .EQ. 7 ) GO TO 7500
C
 4444 CONTINUE
C
C            INCODE = 4 / only ND data are input
C            Check for consistency with previous section to
C            assure that missing data can be propagated
C
      IF( NSA .EQ. 1 ) GO TO 7500
      IF( NSA .NE. LSA ) GO TO 5002
C
 7500 CONTINUE
C
      NSA2 = 2 * NSA
      IF( NSA .EQ. 1 ) CIB(IPTRGH+1) = 1E32
      IF( NRD .EQ. 0 )  THEN
C       Set depth breakpoints to '+ infinity'
C
        DO 750 NN = 1,NSA2
          I = IPTRGH + MXSA + NN
          CIB(I) = 1E32
 750    CONTINUE
C
      ELSE
      ENDIF
C
      IF( INV .EQ. NSA ) THEN
C       Expand roughness array to 2*NSA
        N0 = IPTRGH + 3 * MXSA
C
        DO 800 NN = 2,NSA2,2
          I = NSA2 + 2 - NN
          CIB(N0+I) = CIB(N0+I/2)
          CIB(N0+I-1) = CIB(N0+I)
 800    CONTINUE
C
      ELSE
      ENDIF
C
      PCX(2) = NSA
      PCX(3) = NRD
      PCX(6) = NSA2
      CIB(3) = 0.0
      CIB(6) = 0.0
      GO TO 9999
C
 5001 CONTINUE
C
      IERRUF = 1
      WRITE(MSG,501) INCODE, ISA, INV, IRD
 501  FORMAT
     $     (/' +++047 MISMATCH ON INPUT ROUGHNESS DATA.',6X,4I6/)
      GO TO 9999
C
 5002 CONTINUE
C
      IERRUF = 2
      WRITE(MSG,502) INCODE, ISA, INV, IRD, LSA, LNV, LRD
 502  FORMAT(/' +++048 CANNOT PROPAGATE REQUIRED ROUGHNESS',
     $                                         ' DATA.'/25X,7I6/)
C
 9999 CONTINUE
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM XYMNMX>>>>>
C     <<<<<LAST REVISED 01-22-88>>>>>
C
      SUBROUTINE   XYMNMX ( XY, NGP2 )
C
C     Determines x,y-coordinates of extreme X and Y values and
C     stores them at the end of the XY array.  Data layout is:
C     X(1), Y(1), X(2), Y(2) . . . X(NGP), Y(NGP), XMAX, YMAX,
C     XMIN, YMIN, X at YMAX, Y at XMAX, X at YMIN, Y at XMIN
C
      DIMENSION XY(1)
C
      IXMAX = 1
      IXMIN = 1
      IYMAX = 2
      IYMIN = 2
      IF( NGP2 .GT. 2 ) THEN
C
        DO 10 I = 4,NGP2,2
          IF( XY(I) .GT. XY(IYMAX) ) IYMAX = I
          IF( XY(I) .LT. XY(IYMIN) ) IYMIN = I
          IF( XY(I-1) .GT. XY(IXMAX) ) IXMAX = I - 1
          IF( XY(I-1) .LT. XY(IXMIN) ) IXMIN = I - 1
 10     CONTINUE
C
      ELSE
      ENDIF
C
      XY(NGP2+1) = XY(IXMAX)
      XY(NGP2+2) = XY(IYMAX)
      XY(NGP2+3) = XY(IXMIN)
      XY(NGP2+4) = XY(IYMIN)
      XY(NGP2+5) = XY(IYMAX-1)
      XY(NGP2+6) = XY(IXMAX+1)
      XY(NGP2+7) = XY(IYMIN-1)
      XY(NGP2+8) = XY(IXMIN+1)
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSRTRV>>>>>
C     <<<<<LAST REVISED 01-26-88>>>>>
C
      SUBROUTINE   XSRTRV ( ISEQ, IXTYPE, IERXS, XPOOL, SRD )
C
C     Cross-section data retrieval routine
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      COMMON / DRCTRY / NXSECS, MXXSEC, IXTYPV(100),
     $                           IXIERV(100), SRDV(100), WSC(100)
C
      COMMON / CHARV  / SECIDV(100)
C
      CHARACTER*5 SECIDV, SECIDX, BLANK*4
C
      DIMENSION XPOOL(IPTEND)
C
      DATA MSG / 6 /, BLANK / '   ' /
C
      IF( ISEQ .GT. 0  .AND.  ISEQ .LE. NXSECS ) THEN
C
        IXTYPE = IXTYPV(ISEQ)
        IERXS = IXIERV(ISEQ)
        SRD  =   SRDV(ISEQ)
        CALL DAFIN ( ISEQ, XPOOL )
C
      ELSE
C
        SRD = -1E32
        IXTYPE = -9999
        IERXS = 1
        CALL  DAFZIP ( XPOOL )
C
      ENDIF
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSSAVE>>>>>
C     <<<<<LAST REVISED 01-26-88>>>>>
C
      SUBROUTINE   XSSAVE ( IXTYPE, IER, SECIDX, XPOOL, SRD )
C
      COMMON / DRCTRY / NXSECS, MXXSEC, IXTYPV(100),
     $                           IXIERV(100), SRDV(100), WSC(100)
C
      COMMON / CHARV  / SECIDV(100)
C
      CHARACTER*5 SECIDX, SECIDV, BLANK*4
C
      DIMENSION XPOOL(1)
C
      DATA MSG / 6 /, BLANK / '   ' /
C
      DO 55 I = 1,NXSECS
      IF( SECIDX .EQ. SECIDV(I) )  GO TO 85
   55 CONTINUE
C
      NXSECS = NXSECS + 1
      IF( NXSECS .GT. MXXSEC )  STOP 723
      I = NXSECS
      SECIDV(I) = SECIDX
      WRITE(MSG,83) SECIDV(I), I
   83 FORMAT(' *** CROSS SECTION "',A5,'" WRITTEN TO DISK, ',
     $                                         'RECORD NO. =',I3)
      GO TO 95
   85 WRITE(MSG,87) SECIDX, I
   87 FORMAT(' *** CROSS SECTION "',A5,'" REPLACED ON DISK, ',
     $                                         'RECORD NO. =',I3)
      IF( SRD .GT. -1E30  .AND.  SRD .NE. SRDV(I) )
     $                                 WRITE(MSG,91) SRDV(I), SRD
   91 FORMAT(' +++049 WARNING:  SEC REF DIST CHANGED -',2F12.1)
      IF(IXTYPE.EQ.IXTYPV(I)) GO TO 95
      IF(IXTYPE.EQ.1.AND.IXTYPV(I).EQ.0) GO TO 95
      WRITE(MSG,92) IXTYPV(I), IXTYPE
   92 FORMAT(' +++050 ERROR:  SECTION TYPE CODE CHANGED -',2I6)
      IER = 192
95    CONTINUE
      IXTYPV(I) = IXTYPE
      IF(IXTYPE.EQ.1)  IXTYPV(I) = 0
      IXIERV(I) = IER
      SRDV(I) = SRD
      CALL DAFOUT( I, XPOOL )
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSISEQ>>>>>
C     <<<<<LAST REVISED 01-26-88>>>>>
C
      SUBROUTINE   XSISEQ ( SECIDX, ISEQ )
C
      COMMON / DRCTRY / NXSECS, MXXSEC, IXTYPV(100),
     $                           IXIERV(100), SRDV(100), WSC(100)
C
      COMMON / CHARV  / SECIDV(100)
C
      CHARACTER*5 SECIDX, SECIDV, BLANK*4
C
      DATA MSG / 6 /, BLANK / '   ' /
C
      ISEQ = 0
      IF( NXSECS .GT. 0 ) THEN
C
        IF( SECIDX .EQ. BLANK ) THEN
C
          ISEQ = NXSECS
C
        ELSE
C
          DO 10 IDO = 1,NXSECS
            IF( SECIDX .EQ. SECIDV(IDO) ) ISEQ = IDO
 10       CONTINUE
C
        ENDIF
C
      ELSE
      ENDIF
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSPRT >>>>>
C     <<<<<LAST REVISED O1-13-88>>>>>
C
      SUBROUTINE   XSPRT ( XPOOL, ISEQ, SECID, SRD,
     $                                            IXTYPE, IERXS )
C
C  PRINTS CONTENTS OF GIVEN CROSS SECTION DATA ARRAY XPOOL
C
C  ..... RESTRICTION .....  ROUGHNESS DATA LAYOUT EXPANDED FORMAT
C  ..... DESIGNED FOR NRD = 2 OR NRD = 0   O N L Y .....
C  ..... ELSE PRINTOUT WILL BE GARBAGE .....
C
C  REV NO 271 - XPOOL(3) CONTAINS NRD*NSA INSTEAD OF NRD ONLY.
C
      CHARACTER*5 SECID
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      DIMENSION IXMXMN(8), XPOOL(IPTEND)
      DATA IXMXMN / 3, 8, 7, 4, 1, 6, 5, 2 /, MSG / 6 /
C
      WRITE(MSG,10) SECID, SRD, IERXS
   10 FORMAT(/' --- DATA SUMMARY FOR SECID "',A5,'" AT SRD =',
     $   F8.0,'  ERR-CODE =',I7)
      IF ( IXTYPE .EQ. 6 ) GO TO 250
C
C  IF NOT A CULVERT
C
      WRITE(MSG,20) XPOOL(IPTMSC+1), XPOOL(IPTMSC+2),
     $          XPOOL(IPTMSC+5), XPOOL(IPTMSC+3), XPOOL(IPTMSC+4)
   20 FORMAT(/6X,'SKEW',5X,'IHFNO',4X,'VSLOPE',8X,'EK',8X,'CK',
     $                             /6X,F4.1,F10.0,1X,F9.4,2F10.2)
C
      NGP = XPOOL(1)
      NSA = XPOOL(2)
      NRD = XPOOL(3)
      IF ( NRD .GT. 0  .AND.  NRD .EQ. 2*NSA )  NRD = 2
      NFL = XPOOL(4)
      NPW = XPOOL(5)
C
C  GROUND-POINTS
C
      NP2 = NGP*2
      IF ( NGP .GT. 0 ) WRITE(MSG,40)
     $                              NGP, (XPOOL(IPTXY+I),I=1,NP2)
   40 FORMAT(/' X-Y COORDINATE PAIRS  (NGP =',I4,'):'/
     $                   8X,4('X',6X,'Y',10X)/4(3X,F7.1,1X,F7.2))
      IF ( NGP .GT. 0 ) WRITE(MSG,50)
     $                         (XPOOL(IPTXY+NP2+IXMXMN(I)),I=1,8)
   50 FORMAT(/'  X-Y MAX-MIN POINTS:'/6X,'XMIN',7X,'Y',9X,'X',
     $            4X,'YMIN',6X,'XMAX',7X,'Y',9X,'X',4X,'YMAX'/
     $                                        4(3X,F7.1,1X,F7.2))
C
      IF ( NSA .LE. 1 )  GO TO 70
      NSA1 = NSA - 1
      WRITE(MSG,60) NSA, (XPOOL(IPTRGH+I),I=1,NSA1)
   60 FORMAT(/' SUBAREA BREAKPOINTS (NSA =',I3,'):'/(5X,8F8.0))
   70 CONTINUE
      NSA1 = NSA
      IF ( NSA .LE. 0 )  NSA1 = 1
      MXSA = ( IPTFL - IPTRGH ) / 5
      IPT = IPTRGH + MXSA - 1
      IF ( NRD .LE. 0 )  GO TO 110
      WRITE(MSG,80) NRD
   80 FORMAT(/' ROUGHNESS DEPTHS (NRD =',I3,'):')
   90 FORMAT(' BOT: ',8F8.2/('      ',8F8.2))
  100 FORMAT(' TOP: ',8F8.2/('      ',8F8.2))
      WRITE(MSG,90) (XPOOL(IPT+2*I),I=1,NSA1)
      IPT = IPT + 1
      WRITE(MSG,100) (XPOOL(IPT+2*I),I=1,NSA1)
  110 CONTINUE
      WRITE(MSG,120) NSA1
  120 FORMAT(/' ROUGHNESS COEFFICIENTS (NSA =',I3,'):')
  130 FORMAT('      ',8F8.3)
  140 FORMAT(' BOT: ',8F8.3/('      ',8F8.3))
  150 FORMAT(' TOP: ',8F8.3/('      ',8F8.3))
      IPT = IPTRGH + 3*MXSA - 1
      IF ( NRD .LE. 0 ) WRITE(MSG,130) (XPOOL(IPT+2*I),I=1,NSA1)
      IF ( NRD .GT. 0 ) WRITE(MSG,140) (XPOOL(IPT+2*I),I=1,NSA1)
      IPT = IPT + 1
      IF ( NRD .GT. 0 ) WRITE(MSG,150) (XPOOL(IPT+2*I),I=1,NSA1)
C
C  FLOW LENGTH DATA
C
      IF ( NFL .GT. 0 ) WRITE(MSG,160) NFL
  160 FORMAT(/' FLOW LENGTH DATA (NFL =',I2,'):'/
     $    12X,'FLEN',2(6X,'XSTA',6X,'FLEN'))
      NP2 = 2*NFL - 1
      IF ( NFL .GT. 0 ) WRITE(MSG,170) (XPOOL(IPTFL+I),I=1,NP2)
  170 FORMAT(6X,5F10.0)
C
C   --- MISC SCALARS ---
C
      IF ( IXTYPE .LT. 2) GO TO 260
      GO TO ( 260, 190, 220, 230, 240 ), IXTYPE
  190 WRITE(MSG,200)
  200 FORMAT(/' BRIDGE PARAMETERS:')
      IBRTYP = IFIX ( ABS ( XPOOL(IPTMSC+6) + 0.005 ) )
C
      IF ( IBRTYP .EQ. 1 ) WRITE(MSG,201) IBRTYP,
     $   XPOOL(IPTMSC+7), XPOOL(IPTMSC+14), XPOOL(IPTMSC+19),
     $   XPOOL(IPTMSC+11), XPOOL(IPTMSC+12), XPOOL(IPTMSC+13)
  201 FORMAT('  BRTYPE  BRWDTH     LSEL  USERCD  WWANGL',
     $            '  WWWID ENTRND'/I6,5X,F5.1,1X,F8.2,1X,F7.3,
     $                                        1X,F7.1,2(1X,F6.2))
C
      IF ( IBRTYP .EQ. 2 ) WRITE(MSG,202) IBRTYP,
     $   XPOOL(IPTMSC+7), XPOOL(IPTMSC+14), XPOOL(IPTMSC+19),
     $   XPOOL(IPTMSC+8), XPOOL(IPTMSC+21), XPOOL(IPTMSC+15),
     $   XPOOL(IPTMSC+16)
  202 FORMAT('  BRTYPE  BRWDTH     LSEL  USERCD  EMBSS',
     $          '   EMBELV    YABLT    YABRT'/I6,5X,F5.1,1X,
     $                           F8.2,1X,F7.3,1X,F6.2,3(1X,F8.2))
C
      IF ( IBRTYP .EQ. 3 ) WRITE(MSG,203) IBRTYP,
     $   XPOOL(IPTMSC+7), XPOOL(IPTMSC+14), XPOOL(IPTMSC+19),
     $   XPOOL(IPTMSC+8), XPOOL(IPTMSC+21), XPOOL(IPTMSC+9),
     $   XPOOL(IPTMSC+10)
  203 FORMAT('  BRTYPE  BRWDTH     LSEL  USERCD  EMBSS',
     $          '   EMBELV  ABSLPL  ABSLPR'/I6,5X,F5.1,1X,
     $                   F8.2,1X,F7.3,1X,F6.2,1X,F8.2,2(1X,F7.2))
C
      IF ( IBRTYP .EQ. 4 ) WRITE(MSG,204) IBRTYP,
     $   XPOOL(IPTMSC+7), XPOOL(IPTMSC+14), XPOOL(IPTMSC+19),
     $   XPOOL(IPTMSC+8), XPOOL(IPTMSC+21), XPOOL(IPTMSC+11)
  204 FORMAT('  BRTYPE  BRWDTH     LSEL  USERCD  EMBSS',
     $          '   EMBELV  WWANGL'/I6,5X,F5.1,1X,
     $                      F8.2,1X,F7.3,1X,F6.2,1X,F8.2,1X,F7.2)
C
      IF ( ABS ( XPOOL(IPTABG+1) ) .GT. 1E6 ) GO TO 210
      WRITE(MSG,205) (XPOOL(IPTABG+I),I=1,2),
     $          (XPOOL(IPTABG+I),I=9,10), (XPOOL(IPTABG+I),I=5,8)
  205 FORMAT(/' DESIGN DATA:    BRLEN  LOCOPT  XCONLT  XCONRT',
     $       /15X,F7.1,1X,F7.0,2(1X,F7.0)//15X,' GIRDEP  BDELEV',
     $            '   BDSLP   BDSTA'/14X,2(1X,F7.2),1X,F7.4,1X,
     $                F7.1)
C
  210 WRITE(MSG,212) NPW, XPOOL(IPTMSC+20)
  212 FORMAT(/' PIER DATA:  NPW =',I3,'    PPCD = ',F2.0)
      IF ( NPW .LE. 0 ) GO TO 260
      NPW2 = 2 * NPW
      WRITE(MSG,217) (XPOOL(IPTPEA+I),I=1,NPW2)
  217 FORMAT(4(6X,'PELV  PWDTH')/4(4X,F7.2,1X,F5.1))
      GO TO 260
C
  220 WRITE(MSG,222) (XPOOL(IPTMSC+I),I=6,8)
  222 FORMAT(/' SPUR DIKE DATA:  SDTYPE  OFFSET  DESOFF',
     $   /17X,F7.0,2(1X,F7.2))
      GO TO 260
C
  230 WRITE(MSG,232) (XPOOL(IPTMSC+I),I=6,8)
  232 FORMAT(/' ROAD GRADE DATA:  IPAVE  RDWID  USERCF',
     $   /19X,F5.0,1X,F6.1,1X,F7.3)
C
  240 WRITE(MSG,242) (XPOOL(IPTMSC+I),I=26,29)
  242 FORMAT(/' BRIDGE PROJECTION DATA:  XREFLT  XREFRT',
     $                         '  FDSTLT  FDSTRT'/24X,4(1X,F7.0))
      GO TO 260
C
C    C U L V E R T
C
  250 CONTINUE
      WRITE(MSG,255) (XPOOL(IPTMSC+I),I=6,15),
     $                                    (XPOOL(IPTABG+I),I=1,5)
  255 FORMAT(//' CULVERT PARAMETERS:  ISHAPE   IEQNO     CKE',
     $   '  CVALPH      CN'/20X,2(1X,F7.0),2(1X,F7.2),1X,F7.3,
     $   //20X,'    NBBL  CVLENG   USINV   DSINV    XCTR',
     $   /21X,F7.0,1X,F7.1,2(1X,F7.2),1X,F7.1,//20X,'    RISE',
     $   '    SPAN  BOTRAD  TOPRAD  CORRAD'/20X,5(1X,F7.2))
  260 RETURN
      END
      SUBROUTINE  XSPLT (XPOOL, ISEQ,SECID,SRD,IXTYPE,BINBUF)
C
C   PRINTER-PLOT OF CROSS-SECTION OUTLINE
C
      DIMENSION  BINBUF(2)
C
C     *** CHARACTER DATA ...
      CHARACTER*5   SECID
C
      COMMON /IPTCB1/  IPTXY, IPTRGH, IPTFL,IPTMSC,
     $                IPTPEA, IPTABG,  IPTEND
      DIMENSION  XPOOL(IPTEND)
C
      DATA    IPRT / 6 /
C
C
      WRITE(IPRT,1011) ISEQ,SRD,SECID
 1011 FORMAT( '1 --- CROSS SECTION OUTLINE PLOT ---  SEQ-NOB =',
     $      I3,5X,'SEC-REF-DIST =',F9.1,5X,'SECID = ''',A5,''''/)
C
      IF(IXTYPE.NE.6) GO TO 1020
      WRITE(IPRT,1013) IXTYPE
 1013 FORMAT(/' *** XSPLT -- PLOT NOT AVAILABLE FOR CULVERT ***',I6/)
      RETURN
 1020 CONTINUE
C
      NGP =  XPOOL (1)
      NSA =  XPOOL (2)
      CALL XPLOT0(XPOOL(IPTXY+1),NGP, XPOOL(IPTXY+2*NGP+1),
     $         XPOOL(IPTRGH+1),NSA,  BINBUF(1),BINBUF(2) )
C
      RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #5 OF PC VERSION +++++
C                                     <<<<<SUBPROGRAM XPLOT0>>>>>
C     <<<<<LAST REVISED 06-30-87>>>>>
C
      SUBROUTINE   XPLOT0 ( XYV, NXY, XYMXMN, XSA, NSA,
     $                                           XRANGE, YRANGE )
C
C  XPLOT0 - PRINTER PLOT OF CROSS-SECTION OUTLINE
C
C    NOTE -- THIS ROUTINE  D E S T R O Y S   THE X-Y COORDINATE DATA
C          STORED IN VECTOR XYV.
C
C  REV 1/84 WK - CORRECT LABEL 130/150 TO PREVENT INFINITE PLOT LOOP
C    FOR UNSUBDIVIDED XSECTIONS - NSA1 = 0.
C
C  REV 6/87 JOS - REVISED DECLARATIONS FOR PC PURPOSES
C
      DIMENSION XYV(NXY), XYMXMN(8), XSA(1), LINE(121), XAXIS(7)
      CHARACTER*1 IBLANK, IDASH, IBAR, IPLUS, IDOT, ISTAR,
     $                                        LINE, IFILL, IFILL2

C
      DATA  IBLANK / ' ' /, IDASH / '-' /, IBAR / '|' /,
     $            IPLUS / '+' /, IDOT / '#' /, ISTAR / ':' /,
     $                                   NLINES / 41 /, MSG / 6 /
C
C  DETERMINE PLOT SCALES
C
      IF(XRANGE.GT.0.) CALL PRPCTR(XYMXMN(1),XYMXMN(3),XYMXMN(7),
     $     XRANGE, 12, XMAX,XMIN)
      IF(XRANGE.LE.0.) CALL PRPSCL(XYMXMN(1),XYMXMN(3),
     $             12, XMAX,XMIN)
      IF(YRANGE.GT.0.) CALL PRPCTR(XYMXMN(2),XYMXMN(4),XYMXMN(4),
     $     YRANGE, NLINES/10 , YMAX,YMIN)
      IF(YRANGE.LE.0.) CALL PRPSCL(XYMXMN(2),XYMXMN(4),
     $             NLINES/10 , YMAX,YMIN)
C
C  CONVERT X-Y VALUES TO PLOT-SCALE
C
      XSCALE = 120./(XMAX-XMIN)
      YSCALE = (NLINES-1)/(YMAX-YMIN)
      DO 40 I = 1, NXY
      XYV(2*I) = NLINES+1 - INT((XYV(2*I)-YMIN)*YSCALE + 1.5)
   40 XYV(2*I-1) = MAX0(0,MIN0(121,INT((XYV(2*I-1)-XMIN)*XSCALE+1.5)))
      NSA1 = NSA - 1
      IF(NSA1.LE.0) GO TO 80
      DO 60 I=1,NSA1
   60 XSA(I) = INT((XSA(I)-XMIN)*XSCALE+1.5)
   80 CONTINUE
      JFIRST = NLINES+1-INT((XYMXMN(2)-YMIN)*YSCALE+1.5) - 1
      JLAST = NLINES+1 - INT((XYMXMN(4)-YMIN)*YSCALE+1.5) + 1
C*****
      WRITE(MSG,11833)JFIRST,JLAST
11833 FORMAT(6X,2I12)
C*****
C
C   FOR EACH LINE OF PLOT ...
      DO 180 JLINE = 1,NLINES
C       INITIALIZE LINE IMAGE
      IFILL = IBLANK
      IFILL2 = IBAR
      IF(MOD(JLINE,10).NE.1) GO TO 110
      IFILL = IDASH
      IFILL2 = IPLUS
  110 CONTINUE
      DO 115 I = 1,121
  115 LINE(I) = IFILL
      DO 120 I = 1,121, 10
  120 LINE(I) = IFILL2
C      PLOT SUBAREA BOUNDARIES
      IF(NSA1.LE.0) GO TO 130
      DO 125 I=1,NSA1
  125 LINE(INT(XSA(I))) = ISTAR
  130 CONTINUE
C      CHECK TO SEE IF ANY X-Y POINTS FALL IN THIS LINE
      IF(JLINE.LT.JFIRST .OR. JLINE.GT.JLAST) GO TO 155
      DO 150 I = 1,NXY
  150 IF(XYV(2*I).EQ.JLINE) LINE(INT(XYV(2*I-1))) = IDOT
  155 CONTINUE
C       PRINT THE LINE IMAGE
      IF(MOD(JLINE,10).NE.1) GO TO 170
      YAXIS = YMIN + (NLINES-JLINE)/YSCALE
      WRITE(MSG,161) YAXIS, LINE
  161 FORMAT(1X,F7.1,1X,121A1)
      GO TO 180
  170 WRITE(MSG,171) LINE
  171 FORMAT(9X,121A1)
  180 CONTINUE
C
C       PRINT THE BOTTOM AXIS
      DO 210 I = 1, 7
  210 XAXIS(I) = (I-1)*20./XSCALE + XMIN
      WRITE(MSG,211) XAXIS
  211 FORMAT(/4X,F8.1,6(12X,F8.1)//40X,'HORIZONTAL ',
     $          'STATIONING')
C
      RETURN
      END
      SUBROUTINE  PRPCTR(XTOP,XBOT,XMID, XWINDW,
     $          NGRID,  GTOP, GBOT)
C
C  PRPCTR - PRINTER-PLOTTER - CENTERING OF PLOT ON
C            GRID WHEN PLOT WINDOW LENGTH IS GIVEN
C
      LOGICAL NOSWIT
      DATA TOL /.005/
C
C***************************************
C  STATEMENT FUNCTIONS
      STEP(X)  =  .5 + SIGN(.5,X)
      ZINT(X)  =  AINT(X) - 1. + STEP(X)
      FLOOR(X)  =  ZINT(X+TOL)
      CEIL(X)  =  ZINT(X+1.-TOL)
C***************************************
C
      XMAX = AMAX1(XTOP,XBOT)
      XMIN = AMIN1(XTOP,XBOT)
      NOSWIT = XTOP.GT.XBOT
      FNGRID = NGRID
      SCALE  =  XWINDW/FNGRID
   20 CONTINUE
      GMAX = CEIL(XMAX/SCALE)
      GMIN = FLOOR(XMIN/SCALE)
      GRANGE = GMAX-GMIN
      IF(GRANGE.LE.FNGRID) GO TO 100
      GMAX1 = CEIL(2.*XMAX/SCALE)/2.
      GMIN1 = FLOOR(2.*XMIN/SCALE)/2.
      GRANGE = GMAX1-GMIN1
      IF(GRANGE.LE.FNGRID) GO TO 100
      GMID = FLOOR(XMID/SCALE)
      IF(GMID-GMIN .LE. FNGRID/2.)  GO TO 60
      IF(GMAX-GMID .GT. FNGRID/2.)  GMAX = GMID+FNGRID/2.
      GMIN = GMAX - FNGRID
      GO TO 120
   60 GMAX = GMIN + FNGRID
      GO TO 120
C
C  90 GMAX = GMAX1
C     GMIN = GMIN1
  100 CONTINUE
      EXCESS = FNGRID-GRANGE
      SMALL = AINT(EXCESS/2.)
      BIG = EXCESS-SMALL
      IF((GMAX*SCALE-XMAX) .GT. (XMIN-GMIN*SCALE)) GO TO 110
      GMAX = GMAX+BIG
      GMIN = GMIN-SMALL
       GO TO 120
  110 GMAX = GMAX+SMALL
      GMIN = GMIN-BIG
  120 CONTINUE
      GTOP = GMAX*SCALE
      GBOT = GMIN*SCALE
      IF(NOSWIT) GO TO 130
      TEMP = GBOT
      GBOT = GTOP
      GTOP = TEMP
  130 CONTINUE
      RETURN
      END
      SUBROUTINE PRPSCL (XTOP,XBOT,NGRID,GTOP,GBOT)
C  PRPSCL -- PRINTER-PLOTTER  SCALE SELECTION.
      LOGICAL NOSWIT
      DATA TOL /.005/
      DATAMSG/6/
C***************************************
C  STATEMENT FUNCTIONS
      STEP(X) = .5 + SIGN(.5,X)
      ZINT(X) = AINT(X) - 1. + STEP(X)
      FLOOR(X) = ZINT(X+TOL)
      CEIL(X) = ZINT(X+1.-TOL)
C***************************************
      XMX=AMAX1(XTOP,XBOT)
      XMN=AMIN1(XTOP,XBOT)
      NOSWIT=XTOP.GT.XBOT
      FNGRID=NGRID
      UGLY=(XMX-XMN)/FNGRID
      U=0.
      M=0
      IF(UGLY.EQ.0.)GO TO 11
      U = ALOG10(ABS(UGLY))
      M=INT(U)
      IF(U.LT.0.) M = M - 1
      U = 10**(U-M)
   11 CONTINUE
      IF(U.LT.1.+TOL)U=10.*U
      TENTOM=UGLY/U
      U=U/(1.+TOL)
      SCALE=5.
      IF(U.LT.2.)SCALE=2.
      IF(U.GT.5.)SCALE=10.
      SCALE=SCALE*TENTOM
   20 CONTINUE
      GMX=CEIL(XMX/SCALE)
      GMN=FLOOR(XMN/SCALE)
      GRANGE=GMX-GMN
      IF(GRANGE.LE.FNGRID)GOTO100
      IF(ABS((SCALE/TENTOM)-5.) .LT. 1.)GOTO80
      GMX=CEIL(2.*XMX/SCALE)/2.
      GMN=FLOOR(2.*XMN/SCALE)/2.
      GRANGE=GMX-GMN
      IF(GRANGE.LE.FNGRID)GOTO100
   80 CONTINUE
      SCALE=2.*SCALE
      IF(SCALE.LT.(5.*TENTOM))SCALE=(5.*TENTOM)
      GMX=CEIL(XMX/SCALE)
      GMN=FLOOR(XMN/SCALE)
      GRANGE=GMX-GMN
      IF(GRANGE.LE.FNGRID)GOTO100
      WRITE(MSG,98)XTOP,XBOT,GMX,GMN,SCALE
   98 FORMAT('0***PRPSCL098 LOGIC ERROR',1P5E16.6/)
      GBOT=XBOT
      GTOP=XTOP
      RETURN
  100 CONTINUE
      EXCESS=FNGRID-GRANGE
      SMALL=AINT(EXCESS/2.)
      BIG=EXCESS-SMALL
      IF((GMX*SCALE-XMX) .GT. (XMN-GMN*SCALE))GOTO110
      GMX=GMX+BIG
      GMN=GMN-SMALL
      GOTO120
  110 GMX=GMX+SMALL
      GMN=GMN-BIG
  120 CONTINUE
      GTOP=GMX*SCALE
      GBOT=GMN*SCALE
      IF(NOSWIT)GOTO130
      TEMP=GBOT
      GBOT=GTOP
      GTOP=TEMP
  130 CONTINUE
      RETURN
      END
      FUNCTION QFUNC(IPROF, IXSNO)
C
C  LOOKS UP Q-VALUE DISCHARGE FOR PROFILE NO IPROF,
C   AT CROSS SECTION IXSNO (PHYSICAL UPSTREAM SEQ NO).
C   IF NO Q-VALUE IS STORED AT X-SECT, QFUNC RETURNS THE NEXT-DOWNSTREAM
C   STORED Q-VALUE.  IF NO STORED Q OR IF NONE FOR IPROF, THEN
C   QFUNC RETURNS A LARGE NEGATIVE NUMBER.
C
C   ENTRY  QFUNST  STORES THE Q-DATA IN ARRAY QVPOOL
C   IN THE FORMAT EXPECTED BY QFUNC.   THAT FORMAT IS --
C    IXSNO NKOUNT Q Q ... Q IXSN2 N2 Q..Q IXS3 N3 Q...EOF.
C   EOF -END OF CHAIN- IS INDICATED BY IXSNO .LE.0.
C
C  REVISED 1/18/83 TO LOOK DOWNSTRAM IF NO Q IS STORED AT IXSNO.
C
C
C      DIMENSION  BINBUF(1)
C
      COMMON / PCDBLK / NPROF, IPCDIR(20), WSI(20),EGSLPI(20),
     $               QVPOOL(200), NIPC, NWSI,NEGSI,NQV,MXPROF,MXQV
C
      DATA  MSG / 6 /
C
C
C--- ENTRY QFUNC  ----
C     SEARCH QVPOOL FOR IXSNO
      I = 1
      QFUNC = -1E32
      I2 = 0
      IQV2 = 0
10    CONTINUE
      IQV = QVPOOL(I)
      IF(IQV.EQ.IXSNO)  GO TO  20
      IF(IQV.LE.0)  GO TO 40
      N = QVPOOL(I+1)
      IOLD = I
      I = I + N + 2
      IF(.NOT.(IQV.LT.IXSNO.AND.IQV.GT.IQV2))  GO TO 10
      I2 = IOLD
      IQV2 = IQV
             GO TO 10
C
C     FOUND IXSNO
20    N = QVPOOL(I+1)
      IF(IPROF.GT.N)  GO TO 30
      QFUNC = QVPOOL(I+1+IPROF)
      RETURN
C
C  NO Q-VALUE FOR THIS IPROF OR XSECTION
   30 QFUNC = -2E32
   40 CONTINUE
      I = I2
      IQV = IQV2
      IF(I.GT.0) GO TO 20
      RETURN
        END
        FUNCTION QFUNST(IXSNO,NBIN,BINBUF)
C
C--- ENTRY QFUNST -- STORES INCOMING DATA IN QVPOOL
C
C        RETURNS FUNCTION VALUE TO INDICATE RESULTS --
C         0 = OK.   1 = DATA TOO BIG TO FIT IN QVPOOL - NOT STORED.
C         2 = DATA NOT STORED - IXSNO NOT LAST IN QVPOOL.
C
C   NOTE - NQV MUST BE INITIALIZED .LE. 0. BEFORE FIRST USE.
C
C     ENTRY QFUNST ( IXSNO, NBIN,BINBUF)
C
      DIMENSION  BINBUF(1)
C
      COMMON / PCDBLK / NPROF, IPCDIR(20), WSI(20),EGSLPI(20),
     $               QVPOOL(200), NIPC, NWSI,NEGSI,NQV,MXPROF,MXQV
C
      DATA  MSG / 6 /
C  SEARCH FOR END OF CHAIN
      IF(NBIN.LE.0) GO TO 190
      IF(NQV.LE.0) QVPOOL(1) = 0.
      I = 1
  100 CONTINUE
      IQV = QVPOOL(I)
      IF(IQV.LE.0)  GO TO 140
      IF(IQV.EQ.IXSNO)  GO TO 120
      N = QVPOOL(I+1)
      I = I + N + 2
      GO TO 100
C
C  EXTEND EXISTING X-SEC IF AT END OF CHAIN
  120 N = QVPOOL(I+1)
      I2 = I + N + 2
      IF(QVPOOL(I2).GT.0.)  GO TO 170
      IF(I2+NBIN.GT.MXQV)   GO TO 180
      NQV = I2 + NBIN
      QVPOOL(I+1) = N+NBIN
      DO 125 I=1,NBIN
  125 QVPOOL(I2+I) = BINBUF(I)
      QVPOOL(NQV) = 0.
      QFUNST = 0.
      RETURN
C
C  ADD NEW X-SEC AT END OF CHAIN
  140 IF(I+NBIN+2.GT.MXQV)  GO TO 180
      NQV = I + NBIN + 2
      QVPOOL(I) = IXSNO
      QVPOOL(I+1) = NBIN
      I2 = I+1
      DO 145 I = 1, NBIN
  145 QVPOOL(I2+I) = BINBUF(I)
      QVPOOL(NQV) = 0.
      QFUNST = 0.
      RETURN
C
C  -- ERRORS  --
  170 QFUNST = 2.
      WRITE(MSG,171)
  171 FORMAT(' +++051 Q CARD OUT OF ORDER - IGNORED.')
      RETURN
  180 QFUNST = 1.
      WRITE(MSG,181)
  181 FORMAT(' +++052 Q CARD IGNORED - NO ROOM TO STORE IT.')
      RETURN
  190 QFUNST = 0.
      RETURN
      END
      FUNCTION  ENFUNC(ISA,DEPTH,XSDATA)
C
C  ENFUNC -- FUNCTION LOOKS UP MANNINGS N-VALUE
C     OUT OF GIVEN XS-DATA BLOCK, FOR GIVEN
C     SUBAREA NUMBER (ISA) AND DEPTH.
C
C *** RESTRICTION -- WORKS ONLY FOR NRD = 2.  ***
C            ELSE EXECUTES  STOP 647
C
      COMMON / IPTCB1 / NULL, IPTRGH,IPTFL, JUNK(3), IPTEND
      DIMENSION  XSDATA(IPTEND)
C
C
C                             WK    11/82
C  12/18/82 REVISED FOR EXPANDED FORMAT OF ROUGHNESS ARRAY NRD=2
C    1/27/83 - REV 271 - XSDATA(3) HAS NRD*NSA, NOT JUST NRD
C
C
      NSA = XSDATA(2)
      NRD = XSDATA(3)
      MXSA = (IPTFL-IPTRGH)/5
      IBD = IPTRGH +   MXSA + ISA*2 - 2
      IBN = IPTRGH + 3*MXSA + ISA*2 - 2
C
      IF ( NRD .NE. 2*NSA  .AND. NRD.NE.0 )  STOP 647
      IF( NSA.GT.MXSA )  STOP 647
      ENFUNC = 0.
      IF(ISA.LT.1) RETURN
      IF(ISA.GT.NSA.AND.(ISA.NE.1.OR.NSA.NE.0)) RETURN
C
      IF ( DEPTH .LE. XSDATA(IBD+1) )  GO TO 101
      IF ( DEPTH .GE. XSDATA(IBD+2)) GO TO 102
C     --- ELSE --
      W = 0.5
      D1 = XSDATA(IBD+1)
      D2 = XSDATA(IBD+2)
      IF ( D2 .GT. D1 )  W = (DEPTH-D1)/(D2-D1)
      FN1 = XSDATA(IBN+1)
      FN2 = XSDATA(IBN+2)
      ENFUNC = FN1 + W*(FN2-FN1)
      GO TO 177
C
101   ENFUNC = XSDATA(IBN+1)
      GO TO 177
102   ENFUNC = XSDATA(IBN+2)
177   RETURN
      END
      FUNCTION PIERAF(XI,N,PEWV)
C  PIER-AREA FUNCTION -- COMPUTES PIER AREA SUBMERGED BELOW
C  WATER-SURFACE ELEV XI.  PIER ELEV-WIDTH CURVE PEWV HAS
C  N POINTS.
C  NOTE --  ENTRY  PIERVC  CHECKS VALIDITY OF P.E.W. RELATION.
C    ALSO DETERMINES AND RETURNS CORRECT NUMBER OF P.E.W. TABLE POINTS
C    VIA FUNCTION VALUE PIERVC.   RETURNS NEGATIVE PIERVC VALUE IF ANY
C    ERROR IS FOUND IN P.E.W. TABLE.
C
      DIMENSION  PEWV(2,1)
      DATA  MSG / 6 /
C
      PIERAF = 0.
      IF(N.LE.0) RETURN
      IF(XI.LE.PEWV(1,1))  RETURN
      Y1 = PEWV(1,1)
      W1 = PEWV(2,1)
      IF(N.LE.1) GO TO 45
      DO 40 I = 2, N
      Y0 = Y1
      W0 = W1
      Y1 = PEWV(1,I)
      W1 = PEWV(2,I)
      IF(Y1.GT.XI) GO TO 80
   40 PIERAF = PIERAF + (Y1-Y0)*(W1+W0)/2.
   45 PIERAF = PIERAF + (XI-Y1)*W1
      RETURN
   80 W1 = W0 + (XI-Y0)*(W1-W0)/(Y1-Y0)
      PIERAF = PIERAF + (XI-Y0)*(W1+W0)/2.
      RETURN
      END
      FUNCTION PIERVC(FN,PEWV,YMIN)
      DIMENSION PEWV(2,1)
      DATA MSG/6/
C
C     ENTRY  PIERVC (FN,PEWV,YMIN)
C  DETERMINES CORRECT POINT COUNT, CHECKS TABLE, AND
C  RETURNS NEGATIVE VALUE IF ERROR IS FOUND.
      PIERER = 1.
      KOUNT = FN
      NPA = KOUNT/2
      PIERVC = NPA
      IF(2*NPA.EQ.KOUNT)  GO TO 230
      WRITE(MSG,228)KOUNT,NPA
  228 FORMAT(' +++034 MISSING EITHER WIDTH OR ELEV VALUE(S) IN PIER ',
     $       'ELEV-WIDTH TABLE -',2I6 )
      PIERER = -1.
  230 CONTINUE
      IF(NPA.LE.0) RETURN
      Y0 = YMIN
      DO 117 I=1,NPA
      IF(PEWV(1,I).GE.Y0 .AND. PEWV(2,I).GE.0.) GO TO 117
      WRITE(MSG,119) I, PEWV(1,I), PEWV(2,I)
  119 FORMAT(' +++054 PIER ELEV-WIDTH POINT INVALID -',I4,2F9.1)
      PIERER = -1.
  117 Y0 = PEWV(1,I)
      PIERVC = PIERVC*PIERER
      RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #6 OF PC VERSION +++++
C                                     <<<<<SUBPROGRAM PCCR  >>>>>
C     <<<<<LAST REVISED 08-06-87>>>>>
C
      SUBROUTINE   PCCR   (IPR, IDIR, WSBEG, EGSL, XSBLOK)
C
C  THIS SUBROUTINE IS THE PROFILE COMPUTATION CONTROL ROUTINE
C
C  XSBLOK IS THE X-SEC DATA BLOCK FOR A FULL VALLEY SECTION (UPST
C       OR DNST DEPENDING ON IDIR, THE COMPUTATION DIRECTION)
C
C  ANSVEC IS AN ANSWER VECTOR FOR "NORMAL" VALLEY SUBREACHES.
C       ELEMENTS 1-4 AND 5-8 CONTAIN THE WS, VH, Q & SRD FOR THE
C       UPST & DNST X-SECS RESPECTIVELY.  ELEMENTS 9-16 CONTAIN
C       THE EG, FX (THE ENERGY BALANCE ERROR), FDIST (FLOW DIST-
C       ANCE), ZDIST (SRD DIFF.), HF, HE, V, AND FRDN FOR THE
C       "CURRENT" X-SEC AND SUBREACH.
C
C  XSPVEC IS A VECTOR CONTAINING X-SEC PROPERTIES RELATED TO THE
C       RESULTS STORED IN THE ANSWER VECTOR.  ELEMENTS 1-4 AND
C       5-8 CONTAIN THE K, A, ALPHA & BETA VALUES FOR UPST & DNST
C       X-SECS.  ELEMENTS 9-12 CONTAIN XMAX, YMAX, XMIN, AND YMIN
C       AND ELEMENTS 16-19 CONTAIN WETTED PERIMETER, TOP WIDTH,
C       AND LEFT AND RIGHT EDGES OF WATER.  XSTYPE IS STORED IN
C       ELEMENT 40.
C
C  INDEXA & INDEXP DIRECT ANSWERS & PROPERTIES TO THE APPROPRIATE
C       UPST OR DNST SLOTS IN THE ANSWER & PROPERTY VECTORS.
C
      CHARACTER*5 SECID, XSID, NULL
C
      COMMON / JHPARM / DELTAY, YTOL, QTOL, FNTEST
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / CHARV  / SECID(100)
      COMMON / DRCTRY / LREC, MXXSEC, ITYPE(100),
     $                            IXSERR(100), SRD(100), WSC(100)
      COMMON / J3COM / IRISKT, MXJ3VN, IVARNO(55), IUDTNO(3)
      DIMENSION  XSBLOK(IPTEND,5), ANSVEC(40,5), XSPVEC(40,5),
     $    OUTVEC(58), TEMPSV(9), PROFN(14), CVAR(15), IOREC(100),
     $     NVTOC(2,20), NPTOC(3,20), LIST1(6), LIST2(6), LIST3(6)
C
      DATA LIST1 /  5,  9, 10, 11, 12, 40 /, DUMMY / 1.0E30 /,
     $     LIST2 /  5,  1,  2,  3,  4, 17 /, NULL / ' NULL' /,
     $     LIST3 /  5,  4, 12, 17, 18, 19 /, ISEQT1 / 2 /,
     $     IALT / 0 /, NERRS / 0 /,  MSG / 6 /
C
      IF( IPR .EQ. 1 ) IALT = IALT + 1
      IF( IPR .EQ. 1  .AND.  IALT .EQ. 1 ) CALL ODSOPN
      NVTOC(1,IALT) = IPR
      IF( IPR .GT. 1 ) GO TO 10
      NVTOC(2,IALT) = ISEQT1
      IASEQ = ISEQT1 + 6
      IPSEQ = IASEQ + 1
      ISEQ = IPSEQ
      LINES1 = 0
      LINES2 = 0
      CALL ODSDIR ( ISEQT1 )
      IF( IVARNO(1) .GT. 0 ) CALL UDTSET
   10 DO 20 I = 1,100
      IOREC(I) = 99999
   20 CONTINUE
      LINES = 0
      CALL HDGPRT ( MSG )
      LINES = LINES + 8
      INDEXA = 4 * IDIR + 1
      INDEXM = 3 * IDIR + 1
      INDEXP = INDEXA
      DIR = 0.5 - FLOAT ( IDIR )
      WS = WSBEG
      IREC = 1 + IDIR * ( LREC - 1 )
      IF( IXSERR(IREC) .EQ. 0 ) GO TO 40
      WRITE(MSG,30) IPR, SECID(IREC)
C
C**********ERROR MESSAGE
   30 FORMAT(/'  ===195 PROFILE COMPUTATIONS  T _ E _ R _ M _ ',
     $   'I _ N _ A _ T _ E _ D  !!!!!'/15X,'IPR = ',I4,5X,
     $          'CHECK INPUT ERROR MESSAGES FOR SECID "',A5,'"')
C
      RETURN
C
   40 DO 50 I = 1,40
      ANSVEC(I,1) = 1.0E30
      XSPVEC(I,1) = 1.0E30
   50 CONTINUE
      XSPVEC(13,1) = -1.0E30
C
C  OBTAIN X-SEC DATA BLOCK AND DISCHARGE FOR INITIAL X-SEC
C
      CALL DAFIN ( IREC, XSBLOK(1,1) )
      Q = QFUNC ( IPR, IREC )
      IF( ITYPE(1) .NE. 6 ) GO TO 60
      CALL CULCAL (1, XSBLOK(1,1), Q, WSBEG, WS1, AREA )
      RETURN
C
   60 CONTINUE
      XSTYPE = FLOAT ( ITYPE(IREC) ) + 0.001
      XSPVEC(15,1) = XSBLOK(IPTMSC+1,1)
C
C  PLACE X & Y MAX/MIN VALUES IN PROPERTIES VECTOR
C
      LXY = IPTXY + 2 * XSBLOK(1,1)
      CALL STORIT ( XSPVEC(1,1), LIST1, XSBLOK(LXY+1,1),
     $               XSBLOK(LXY+2,1), XSBLOK(LXY+3,1),
     $                              XSBLOK(LXY+4,1), XSTYPE )
      IF( IDIR .EQ. 0 ) GO TO 90
C
C  PLACE ENERGY-LOSS PARAMETERS IN TEMPORARY STORAGE VECTOR FOR
C       USE IN DOWNSTREAM CONPUTATIONS.
C
      TEMPSV(1) = XSBLOK(4,1)
      DO 70 I = 1,5
      TEMPSV(I+1) = XSBLOK(IPTFL+I,1)
   70 CONTINUE
      DO 80 I = 1,3
      TEMPSV(I+6) = XSBLOK(IPTMSC+I+1,1)
   80 CONTINUE
C
C  DETERMINE STARTING WATER-SURFACE ELEVATION --
C               SPECIFIED, SLOPE-CONVEYANCE, OR CRITICAL?
C
   90 IF( EGSL .LE. 0.0 ) GO TO 100
      CALL SLPCON ( Q, EGSL, WS, INDEXP,
     $                                XSPVEC(1,1), XSBLOK(1,1) )
  100 IF( ABS( WSC(IREC) ) .GT. 1E5 ) GO TO 110
      QB4 = QFUNC ( IPR-1, IREC )
      IF( QB4 .EQ. Q ) GO TO 120
  110 CALL CRITWS ( Q, WSC(IREC), INDEXP, XSPVEC(1,1),
     $                                        XSBLOK(1,1), YTOL )
  120 IF( WS .GT. XSPVEC(12,1) ) GO TO 140
      WRITE(MSG,130) SECID(IREC), XSPVEC(12,1), WS, WSC(IREC)
  130 FORMAT(/'  ===010 WSI BELOW YMIN AT SECID "',A5,
     $           '":  USED WSI = CRWS.',
     $                  /25X,'YMIN,WSI,CRWS = ',F8.1,2(3X,F8.2))
      GO TO 160
  140 IF( ( WS - WSC(IREC) ) * SIGN ( 1.001, DIR ) .GE. 0.0 )
     $                                                 GO TO 170
      WRITE(MSG,150) SECID(IREC), WS, WSC(IREC)
  150 FORMAT(/'  ===015 WSI IN WRONG FLOW REGIME AT SECID "',
     $         A5,'":  USED WSI = CRWS.'/30X,
     $                                 'WSI,CRWS = ',2(F8.2,3X))
  160 WS = WSC(IREC)
  170 CALL XSPROP ( WS, XSPVEC(11,1), XSPVEC(9,1), INDEXP,
     $                                XSPVEC(1,1), XSBLOK(1,1) )
C
C  PLACE INITIAL CONDITIONS IN ANSWER VECTOR  --
C       WS, Q, AND DIST LOCALLY; V, VH, EG AND FRDN
C       VIA THE HYDEQS SUBPROGRAM.
C
      DO 180 I = 1,4
      LIST2(I+1) = INDEXA + I - 1
  180 CONTINUE
      LIST3(2) = INDEXA + 3
      CALL STORIT ( ANSVEC(1,1), LIST2, WS, 1.0E30, Q,
     $                                    SRD(IREC), WSC(IREC) )
      CALL HYDEQS ( INDEXA, ANSVEC(1,1), INDEXP, XSPVEC(1,1) )
      GO TO 690
C
C  SET POINTER TO NEXT X-SEC (IF ANY)
C
  510 IF( IREC .EQ. ( LREC - IDIR * (LREC - 1) ) ) GO TO 2000
  520 REC = IREC + 1.0 * SIGN ( 1.001, DIR )
      IREC = IFIX ( REC + 0.005 )
      IF( IXSERR(IREC) .EQ. 0 ) GO TO 525
      WRITE(MSG,30) IPR, SECID(IREC)
      RETURN
C
  525 IF( IDIR .EQ. 0 ) GO TO 530
      IF( ITYPE(IREC) .EQ. 4 ) GO TO 520
  530 CALL DAFIN ( IREC, XSBLOK(1,1) )
      ANSVEC(INDEXA+2,1) = QFUNC ( IPR, IREC )
      IF( ABS( WSC(IREC) ) .GT. 1E5 ) GO TO 540
      QB4 = QFUNC ( IPR-1, IREC )
      IF(QB4.EQ.ANSVEC(INDEXA+2,1)) GO TO 540
      WSC(IREC) = 1E30
  540 XSTYPE=FLOAT(ITYPE(IREC))+0.001
      XSPVEC(15,1)=XSBLOK(IPTMSC+1,1)
      ZDIST=SRD(IREC)-ANSVEC(9-INDEXA,1)
      LXY=IPTXY+2*XSBLOK(1,1)
      CALL STORIT(XSPVEC(1,1),LIST1,XSBLOK(LXY+1,1),XSBLOK(LXY+2,1),
     *     XSBLOK(LXY+3,1),XSBLOK(LXY+4,1),XSTYPE)
      IF(IDIR.EQ.0) GO TO 570
C
C  FOR DNST COMPUTATIONS, PLACE PREVIOUS X-SEC ENERGY LOSS
C  PARAMETERS IN DATA BLOCK AND STORE CURRENT DATA BLOCK VALUES
C  FOR NEXT SUBREACH.
C
      TSCALR=XSBLOK(4,1)
      XSBLOK(4,1)=TEMPSV(1)
      TEMPSV(1)=TSCALR
      DO 550 I = 1,5
      TSCALR=XSBLOK(IPTFL+I,1)
      XSBLOK(IPTFL+I,1)=TEMPSV(I+1)
      TEMPSV(I+1)=TSCALR
  550 CONTINUE
      DO 560 I = 1,3
      TSCALR=XSBLOK(IPTMSC+I+1,1)
      XSBLOK(IPTMSC+I+1,1)=TEMPSV(I+6)
      TEMPSV(I+6)=TSCALR
  560 CONTINUE
  570 CALL STORIT(ANSVEC(1,1),LIST3,SRD(IREC),ZDIST,WSC(IREC),
     *                XSBLOK(IPTMSC+3,1),XSBLOK(IPTMSC+4,1))
      CALL STEPBW(SECID(IREC),INDEXA,ANSVEC(1,1),INDEXP,XSPVEC(1,1),
     *    XSBLOK(1,1))
      IF(IDIR.EQ.1) GO TO 690
      IF(ITYPE(IREC).NE.1) GO TO 690
C
C  STORE "NATURAL" PROFILE RESULTS FOR XS4(EXIT) AND XS3(FULL VALLEY
C  DNST) X-SECS TO CONVEY TO BRIDGE ROUTINE(S).
C
      DO 580 I=1,4
      PROFN(6+I)=ANSVEC(I+4,1)
      PROFN(10+I)=XSPVEC(I+4,1)
  580 CONTINUE
      PROFN(5)=ANSVEC(1,1)
      PROFN(6)=ANSVEC(4,1)
C
C  FIND HOW MANY (NBO) OPENINGS, INPUT RG (IF ANY) AND FIND THE APPROACH
C  X-SEC.
C
      DO 600 I=1,40
      DO 590 J=2,5
      ANSVEC(I,J)=1.0E30
      XSPVEC(I,J)=1.0E30
  590 CONTINUE
  600 CONTINUE
      DO 610 J=1,4
      XSPVEC(13,J)=-1.0E30
  610 CONTINUE
      NBO=0
      IRECAS=IREC
      XSBLOK(1,3)=-1.
      XSBLOK(1,4)=-1.
  660 IRECAS=IRECAS+1
      IF(IXSERR(IRECAS) .EQ. 0) GO TO 665
      WRITE(MSG,30) IPR,SECID(IRECAS)
      RETURN
C
  665 XSTYPE=FLOAT(ITYPE(IRECAS))+0.001
      IF(ITYPE(IRECAS).EQ.5) GO TO 690
      IF(ITYPE(IRECAS).NE.4) GO TO 670
      CALL DAFIN(IRECAS,XSBLOK(1,4))
      ANSVEC(4,4)=SRD(IRECAS)
      XSPVEC(15,4)=XSBLOK(IPTMSC+1,4)
      XSPVEC(39,4)=0.0
      LXY=IPTXY+2*XSBLOK(1,4)
      CALL STORIT(XSPVEC(1,4),LIST1,XSBLOK(LXY+1,4),XSBLOK(LXY+2,4),
     *     XSBLOK(LXY+3,4),XSBLOK(LXY+4,4),XSTYPE)
      GO TO 660
  670 IF(ITYPE(IRECAS).NE.3) GO TO 680
      XSBLOK(1,3)=1.
      GO TO 660
  680 NBO=NBO+1
      GO TO 660
C
C  TRANSFER RESULTS FROM UPST/DNST TO DNST/UPST LOCATIONS
C
  690 DO 700 I = 1,4
      ANSVEC(I+5-INDEXA,1)=ANSVEC(I-1+INDEXA,1)
      XSPVEC(I+5-INDEXP,1)=XSPVEC(I-1+INDEXP,1)
  700 CONTINUE
      CALL OUTSTR(OUTVEC,INDEXA,ANSVEC(1,1),XSPVEC(1,1))
      ISEQ=ISEQ+1
      CALL ODSOUT(ISEQ,SECID(IREC),OUTVEC)
      IOREC(IREC)=ISEQ
      XSID=SECID(IREC)
      IGO=ITYPE(IREC)+1
      CALL STDPRT(XSID,IGO,LINES,OUTVEC)
      IF(IRISKT.EQ.1) CALL RATBL1(LINES1,IREC,LREC,ANSVEC(3,1),
     *                 OUTVEC(2),SECID(IREC),SRD(IREC),ANSVEC(1,1))
      WSC(IREC)=ANSVEC(17,1)
      IF(IDIR.EQ.1) GO TO 510
      IF(ITYPE(IREC).EQ.0) GO TO 510
      CALL DAFIN(IRECAS,XSBLOK(1,5))
      IF( ABS( WSC(IRECAS) ) .GT. 1E5 ) GO TO 810
      IF(QB4.EQ.ANSVEC(3,1)) GO TO 810
      WSC(IRECAS) = 1E30
  810 ZDIST=SRD(IRECAS)-ANSVEC(8,1)
      CALL STORIT(ANSVEC(1,1),LIST3,SRD(IRECAS),ZDIST,WSC(IRECAS),
     *           DUMMY,DUMMY)
      XSPVEC(15,1)=XSBLOK(IPTMSC+1,5)
      LXY=IPTXY+2*XSBLOK(1,5)
      CALL STORIT(XSPVEC(1,1),LIST1,XSBLOK(LXY+1,5),XSBLOK(LXY+2,5),
     *     XSBLOK(LXY+3,5),XSBLOK(LXY+4,5),XSTYPE)
      CALL STEPBW(SECID(IRECAS),1,ANSVEC(1,1),1,XSPVEC(1,1),XSBLOK(1,5))
      WSC(IRECAS)=ANSVEC(17,1)
      PROFN(1)=ANSVEC(1,1)
      PROFN(2)=ANSVEC(4,1)
      CALL OUTSTR(OUTVEC,INDEXA,ANSVEC(1,1),XSPVEC(1,1))
      ISEQ=ISEQ+1
      CALL ODSOUT(ISEQ,SECID(IRECAS),OUTVEC)
      XSID=SECID(IRECAS)
      IGO=ITYPE(IRECAS)+1
      CALL STDPRT(XSID,IGO,LINES,OUTVEC)
      PROFN(3)=0.0
      PROFN(4)=0.0
  830 DO 840 I=1,40
      ANSVEC(I,5)=ANSVEC(I,1)
      XSPVEC(I,5)=XSPVEC(I,1)
  840 CONTINUE
      IF(NBO.GT.1) GO TO 1000
      CALL DAFIN(IREC+1,XSBLOK(1,2))
      LXY=IPTXY+2*XSBLOK(1,2)
      CALL STORIT(XSPVEC(1,2),LIST1,XSBLOK(LXY+1,2),XSBLOK(LXY+2,2),
     *     XSBLOK(LXY+3,2),XSBLOK(LXY+4,2),2.0)
      ANSVEC(4,2)=SRD(IREC+1)
      XSPVEC(15,2)=XSBLOK(IPTMSC+1,2)
      IF(XSBLOK(1,3).LT.0.) GO TO 930
      CALL DAFIN(IREC+2,XSBLOK(1,3))
      LXY=IPTXY+2*XSBLOK(1,3)
      CALL STORIT(XSPVEC(1,3),LIST1,XSBLOK(LXY+1,3),XSBLOK(LXY+2,3),
     *     XSBLOK(LXY+3,3),XSBLOK(LXY+4,3),3.0)
      ANSVEC(4,3)=SRD(IREC+2)
      XSPVEC(15,3)=XSBLOK(IPTMSC+1,3)
      PROFN(4)=SRD(IREC+2)
C
C  WS2=WS3+(WS1-WS3)*(SRD2-SRD3)/(SRD1-SRD3)
C
      PROFN(3)=PROFN(5)+(PROFN(1)-PROFN(5))*(PROFN(4)-PROFN(6))/
     *                                      (PROFN(2)-PROFN(6))
  930 DO 940 I=1,15
      CVAR(I)=-1E6
  940 CONTINUE
      CALL BRIDGE(IREC,IRECAS,PROFN,XSBLOK(1,1),ANSVEC(1,1),
     *                                   XSPVEC(1,1),CVAR,ERRFLG)
C**********DEBUG OUTPUT BLOCK
           DO 5000 J=2,5
           BLK=FLOAT(J)+0.1
           WRITE(8,*) BLK
           WRITE(8,*) (ANSVEC(I,J),I=1,40)
           BLK=BLK+0.1
           WRITE(8,*) BLK
           WRITE(8,*) (XSPVEC(I,J),I=1,40)
 5000      CONTINUE
      IF(ERRFLG .LT. 0.1) GO TO 945
      WRITE(MSG,1945) IPR
 1945 FORMAT(/'  ===295 PROFILE COMPUTATIONS  T _ E _ R _ M _ ',
     $   'I _ N _ A _ T _ E _ D  !!!!!'/15X,'IPR = ',I4,5X,
     $           'BRIDGE FLOW COMPUTATIONS  F_A_I_L_E_D  !!!!!')
      RETURN
C
  945 DO 960 J=2,5
      IREC=IREC+1
      XSID=SECID(IREC)
      IF(XSBLOK(1,J).GT.0.0) GO TO 950
      ANSVEC(1,J)=-1.0E15
      XSID=NULL
      IREC=IREC-1
  950 CALL OUTSTR(OUTVEC,INDEXA,ANSVEC(1,J),XSPVEC(1,J))
      ISEQ=ISEQ+1
      CALL ODSOUT(ISEQ,XSID,OUTVEC)
      IF(XSBLOK(1,J).LE.0.0) GO TO 960
      IF(XSPVEC(39,J).LE.0.0) GO TO 955
      IRT=2*XSBLOK(1,J)+IPTXY
      WRITE(MSG,1955) XSID, ANSVEC(1,J), XSBLOK(IPTXY+2,J),
     $                                             XSBLOK(IRT,J)
C
C**********ERROR MESSAGE
 1955 FORMAT(/' ===140 AT SECID "',A5,'":  END OF CROSS ',
     $         'SECTION EXTENDED VERTICALLY.'/30X,
     $                        'WSEL,YLT,YRT = ',F8.2,2(3X,F8.1))
C
  955 IOREC(IREC)=ISEQ
      IGO=ITYPE(IREC)+1
      CALL STDPRT(XSID,IGO,LINES,OUTVEC)
  960 CONTINUE
      DO 970 I=1,4
      ANSVEC(I+4,1)=ANSVEC(I,5)
      XSPVEC(I+4,1)=XSPVEC(I,5)
  970 CONTINUE
      IREC=IRECAS
      IF(IRISKT.EQ.2) CALL RATBL2(IOREC(IREC),LINES2)
      GO TO 510
 1000 CALL MULTBO(IREC,IRECAS,NBO,PROFN,XSBLOK(1,1),ANSVEC(1,1),
     *      XSPVEC(1,1),ERRFLG)
      IF(ERRFLG .GT. 0.1) GO TO 1020
      IREC=IRECAS
      DO 1010 I=1,4
      ANSVEC(I+4,1)=ANSVEC(I,5)
      XSPVEC(I+4,1)=XSPVEC(I,5)
 1010 CONTINUE
      XSPVEC(13,1)=-1E30
      XSPVEC(14,1)=1E30
      GO TO 510
 1020 WRITE(MSG,1945) IPR
      RETURN
 2000 NPTOC(1,IPR)=IPSEQ+1
      NPTOC(2,IPR)=ISEQ
      NPTOC(3,IPR)=IDIR
      CALL ODSTOC(IASEQ,IPSEQ,NVTOC,NPTOC,IOREC,IALT,IPR,NERRS)
      IPSEQ=ISEQ+1
      ISEQ=IPSEQ
      ISEQT1=IPSEQ
      IF(IUDTNO(1).GT.0) CALL UDTPRT(LREC,IOREC,IUDTNO)
      RETURN
 9000 STOP
      END
C                                     <<<<<SUBPROGRAM STEPBW>>>>>
C     <<<<<LAST REVISED 12-32-86>>>>>
C
      SUBROUTINE   STEPBW ( SECID, NDXA, AVECTR, NDXP,
     $                                          PVECTR, XSDATA )
C
      CHARACTER*5 SECID
C
      COMMON / JHPARM / DELTAY, YTOL, QTOL, FNTEST
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      DIMENSION AVECTR(1), PVECTR(1), XSDATA(IPTEND)
C
      DATA MSG / 6 /
C
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  JOS.MOD 12/86 - COSMETIC - JHPARM PARAMETER CONSISTENCY
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
      FN = FNTEST
      IERR = 0
      WSC = AVECTR(17)
      Q = AVECTR(NDXA+2)
      ELINC = DELTAY
      IF( NDXA .EQ. 1 ) GO TO 10
      ELINC =  -ELINC
      WSEND = PVECTR(12) + 0.2
      GO TO 20
   10 WSBEG = AVECTR(5) - 0.5 * ELINC
      WSEND = PVECTR(10)
      IFN = 0
      IF( WSBEG .GT. PVECTR(12) ) GO TO 110
      IERR = 1
   20 IF( ABS( WSC ) .LT. 1E5 ) GO TO 30
      CALL CRITWS ( Q, WSC, NDXP, PVECTR, XSDATA, YTOL )
      AVECTR(17) = WSC
   30 IF( IERR .EQ. 0 ) GO TO 100
      GO TO ( 40, 60, 80 ), IERR
C
C**********ERROR MESSAGE
   40 WRITE(MSG,50) SECID, PVECTR(12), WSBEG, WSC
   50 FORMAT(/'  ===105 WSMIN BELOW YMIN AT SECID "',A5,
     $          '":  USED WSMIN = CRWS.'/25X,
     $                          'YMIN,WSMIN,CRWS = ',3(F8.2,3X))
C
      GO TO 100
C
C**********ERROR MESSAGE
   60 WRITE(MSG,70) SECID, WSBEG, WSEND, WSC
   70 FORMAT(/'  ===115 WSEL NOT FOUND AT SECID "',A5,
     $                       '":  USED WSMIN = CRWS.'/20X,
     $                       'WSLIM1,WSLIM2,CRWS = ',3(F8.2,3X))
C
      FN = 1E22
      GO TO 100
C
C**********ERROR MESSAGE
   80 WRITE(MSG,90) SECID, FN, AVECTR(16), WS, WSC
   90 FORMAT(/'  ===125 FR# EXCEEDS FNTEST AT SECID "',A5,
     $                   '":  TRIALS CONTINUED.'/15X,
     $          'FNTEST,FR#,WSEL,CRWS = ',2(F5.2,3X),2(F8.2,3X))
C
      IF( IFN .EQ. 10 ) GO TO 190
      IF( WS1 .LT. WSC ) WS1 = WSC
      GO TO 130
  100 WSBEG = WSC
  110 WSMIN = AMIN1 ( WSBEG, WSEND )
      WSMAX = AMAX1 ( WSBEG, WSEND )
  120 WS1 = WSBEG
  130 ITER = 1
      AVECTR(NDXA) = WS1
      WS = WS1
      CALL ENRGEQ ( NDXA, AVECTR, NDXP, PVECTR, XSDATA )
      ERRWS1 = AVECTR(10)
      IF( ABS ( ERRWS1 ) .LE. YTOL ) GO TO 210
      NOI = ( WSEND - WS1 ) / ELINC + 1
      DO 140 I = 1,NOI
      WS = WS1 + ELINC
      IF( ELINC .LT. 0.0  .AND.  WS .LT. WSEND ) WS = WSEND
      IF( ELINC .GT. 0.0  .AND.  WS .GT. WSEND ) WS = WSEND
      WSB1 = WS1
      WSB2 = WS
      AVECTR(NDXA) = WS
      CALL ENRGEQ ( NDXA, AVECTR, NDXP, PVECTR, XSDATA )
      ERRWS = AVECTR(10)
      IF( ABS ( ERRWS ) .LE. YTOL ) GO TO 210
      IF( ERRWS1 * ERRWS .LT. 0.0 ) GO TO 160
      WS1 = WS
  140 ERRWS1 = ERRWS
      IF( ABS ( ELINC ) .NE. DELTAY ) GO TO 190
      ELINC = ELINC / 2.0
C
C**********ERROR MESSAGE
      WRITE(MSG,150) SECID, WSBEG, WSEND, ELINC
  150 FORMAT(/'  ===110 WSEL NOT FOUND AT SECID "',A5,
     $                  '":  REDUCED DELTAY.'/20X,
     $                'WSLIM1,WSLIM2,DELTAY = ',2(F8.2,3X),F5.2)
C
      IF( ELINC .LE. 0.0 ) GO TO 120
      IERR = 2
      GO TO 20
  160 WS2 = WS
      ERRWS2 = ERRWS
  170 WS = WS1 + (WS2 - WS1) * ERRWS1 / (ERRWS1 - ERRWS2)
      AVECTR(NDXA) = WS
      CALL ENRGEQ ( NDXA, AVECTR, NDXP, PVECTR, XSDATA )
      ERRWS = AVECTR(10)
      IF( ABS ( ERRWS ) .LE. YTOL ) GO TO 210
      IF( ITER .GT. 10 ) GO TO 180
      ITER = ITER + 1
      IF( ERRWS * ERRWS1 .LT. 0.0 ) GO TO 160
      WS1 = WS
      ERRWS1 = ERRWS
      GO TO 170
C
C**********ERROR MESSAGE
  180 WRITE(MSG,185) SECID, YTOL, WSB1, WSB2
  185 FORMAT(/'  ===120 YTOL NOT SATISFIED AT SECID "',A5,
     $                    '":  TRIALS CONTINUED.'/25X,
     $                  'YTOL,WSLIM1,WSLIM2 = ',F5.2,2(3X,F8.2))
C
      WS1 = WSB2
      GO TO 130
  190 WS = WSC
      AVECTR(NDXA) = WS
      CALL XSPROP ( WS, PVECTR(13), PVECTR(14), NDXP,
     $                                          PVECTR, XSDATA )
      CALL HYDEQS ( NDXA, AVECTR, NDXP, PVECTR )
      AVECTR(10) = 1.0E30
      AVECTR(13) = 1.0E30
      AVECTR(14) = 1.0E30
C
C**********ERROR MESSAGE
      WRITE(MSG,200) SECID, WSBEG, WSEND, WSC
  200 FORMAT(/'  ===130 CRITICAL WATER-SURFACE ELEVATION  A _ ',
     $   'S _ S _ U _ M _ E _ D  !!!!!'/15X,'ENERGY EQUATION ',
     $   ' N_O_T  B_A_L_A_N_C_E_D  AT SECID "',A5,'"'/20X,
     $   'WSBEG,WSEND,CRWS = ',3(F8.2,3X))
C
      GO TO 240
  210 IF( ELINC .LT. 0. ) GO TO 220
      IF( AVECTR(16) .LT. FN ) GO TO 220
      WS1 = WS + YTOL + 5.0 * YTOL
      IFN = IFN + 1
      IERR = 3
      GO TO 20
  220 CONVR = PVECTR(1) / PVECTR(5)
      IF( CONVR .GE. 0.7  .AND.  CONVR .LE. 1.4 ) GO TO 240
C
C**********ERROR MESSAGE
      WRITE(MSG,230) SECID, CONVR
  230 FORMAT(/'  ===135 CONVEYANCE RATIO OUTSIDE OF RECOM',
     $      'MENDED LIMITS.'/30X,'"',A5,'"',5X,'KRATIO = ',F5.2)
C
  240 IF( PVECTR(39) .LE. 0.0 ) GO TO 260
      IRT = 2 * XSDATA(1) + IPTXY
C
C**********ERROR MESSAGE
      WRITE(MSG,250) SECID, AVECTR(NDXA), XSDATA(IPTXY+2),
     $                                              XSDATA(IRT)
  250 FORMAT(/'  ===140 AT SECID "',A5,'":  END OF CROSS ',
     $   'SECTION EXTENDED VERTICALLY.'/30X,'WSEL,YLT,YRT = ',
     $         3(F8.2,3X))
C
  260 AVECTR(17) = WSC
      RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #7 OF PC VERSION +++++
C                                     <<<<<SUBPROGRAM BRIDGE>>>>>
C     <<<<<LAST REVISED 12-31-86>>>>>
C
      SUBROUTINE   BRIDGE ( IREC, IRECAS, PROFN, XSBLOK,
     $                             ANSVEC, XSPVEC, CVAR, ERRFLG )
C
      REAL  K4, K3, K1, KQ, KC, KSD, LSEL
C
      CHARACTER*5 SECID
C
      COMMON / JHPARM / DELTAY, YTOL, QTOL, FNTEST
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / CHARV  / SECID(100)
      COMMON / DRCTRY / LREC, MXXSEC, ITYPE(100),
     $                            IXSERR(100), SRD(100), WSC(100)
      COMMON / XPARMS / XBR(21), XAS(21), XREFBR
      COMMON / LPARMS / ZD1TO2, ZDDTO2, ZD2TO3, ZD3TO4,
     $                  FD1TO2, FDDTO2, FD2TO3, FD3TO4
      COMMON / KQBLK / KQ, XLTKQ, XRTKQ, UZRCOD, UZRBRL, UZRXKQ
C
      DIMENSION  XSBLOK(IPTEND,5), ANSVEC(40,5), XSPVEC(40,5),
     $      PROFN(14), CVAR(15), YUOVRZ(12), ORFQCD(12),
     $      YMAX(3), WSCR(3), WSB4(3), WSERR(3), WSSAVE(6),
     $      LIST1(5), LIST2(6), LIST3(6), LIST4(6), DUMVEC(40)
C
      DATA YUOVRZ / 0.9, 1.0, 1.05, 1.1, 1.15, 1.2,
     $                            1.25, 1.3, 1.4, 1.5, 1.7, 2.0 /
      DATA ORFQCD / 0.1, 0.1, 0.27, 0.37, 0.425, 0.445,
     $                      0.463, 0.475, 0.49, 0.495, 0.5, 0.5 /
      DATA   LIST1 /  4,  1,  3, 12, 17 /,
     $       LIST2 /  5, 10, 11, 13, 14, 23 /,
     $       LIST3 /  5, 18, 19, 20, 21, 22 /,
     $       LIST4 /  5, 22, 23, 24, 25, 26 /,
     $       SUBPGM / 010101. /, DUMMY / 1E30 /, MSG / 6 /,
     $       NDUM / 40 /, IOFF / 0 /
C
C          TO COMPUTE ALL COMBINATIONS OF FREE-SURFACE AND
C          ORIFICE-TYPE FLOW THROUGH BRIDGE WITH OR WITHOUT
C          SIMULTANEOUS WEIR-FLOW OVER EMBANKMENT.
C
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  JOS.MOD 12/86 - COSMETIC - JHPARM PARAMETER CONSISTENCY
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
      WRITE(8,*) SUBPGM
      WRITE(8,*) PROFN
      ERRFLG = 0.0
      IFLOB4 = 0
      IFLOW2 = 0
      IFLOW4 = 0
      ITRYCF = 0
      NPA = XSBLOK(5,2)
      WS1N = PROFN(1)
      WSSDN = PROFN(3)
      WS3N = PROFN(5)
      WS3DS = WS3N
      YMAX(1) = XSPVEC(10,5)
      YMAX(2) = XSPVEC(10,3)
      YMAX(3) = XSPVEC(10,2)
      QT = PROFN(9)
      CALL CRITWS ( QT, WSCR(1), 1, XSPVEC(1,5),
     $                                       XSBLOK(1,5), YTOL )
      IF( ABS( WSCR(1) - YMAX(1) ) .LE. YTOL )
     $                WRITE(MSG,10) SECID(IRECAS), QT, WSCR(1)
C
C**********ERROR MESSAGE
   10 FORMAT(/'  ===210 QUESTIONABLE CRITICAL-FLOW SOLUTION.',
     $        /20X,'SECID "',A5,'"',5X,'Q,CRWS = ',2(F8.2,3X))
C
      WSC(IRECAS) = WSCR(1)
      LSEL = XSBLOK(IPTMSC+14,2)
      IDIDIT = 1
      QBO = QT
      QRD = 0.0
      IFLOW = 1
      RGMIN = XSPVEC(12,4)
      ANSVEC(15,4) = XSBLOK(IPTMSC+6,4)
      IF( ABS( ANSVEC(15,4) ) .GT. 5.0 ) ANSVEC(15,4) = 1.002
      RDWDTH = XSBLOK(IPTMSC+7,4)
      IF( ABS( RDWDTH ) .GT. 1E5 ) RDWDTH = XSBLOK(IPTMSC+7,2)
      FD1TOR = PROFN(2) - PROFN(6) - RDWDTH
      ZD1TOR = ANSVEC(4,5) - ANSVEC(4,4)
      IF( ZD1TOR .LE. 0.0 ) ZD1TOR = 1E30
      WSMAX = YMAX(1)
      FLOW = IFLOW
      CALL CPARMS ( PROFN, CVAR, IBRTYP, XSBLOK(1,1),
     $                                ANSVEC(1,1), XSPVEC(1,1) )
      EMPRIM = 1.0 - ( XBR(21) - XBR(1) ) / ( XAS(21) - XAS(1) )
      IF( EMPRIM .LT. 0.0 ) EMPRIM = 0.0
      XREFRD = XSBLOK(IPTMSC+26,4)
      IF( ABS( XREFRD ) .GT. 1E5 ) XREFRD = XREFBR
      IF( WS3N .LT. LSEL ) GO TO 30
      IFLOW = 3
      WSMIN = WS3N
      WS3 = WS3N
      CDORFQ = UZRCOD
      IF( CDORFQ .LE. 0.0) CDORFQ = 0.8
      WRITE(MSG,20) WS3N, LSEL
C
C**********ERROR MESSAGE
   20 FORMAT(/'  ===255 ATTEMPTING FLOW CLASS 3 (6) ',
     $               'SOLUTION.'/25X,'WS3N,LSEL = ',2(F8.2,3X))
C
      GO TO 280
   30 VH4 = PROFN(8)
      WS4 = PROFN(7)
      K4 = PROFN(11)
      A4 = PROFN(12)
      ALPHA4 = PROFN(13)
      BETA4 = PROFN(14)
      XSPVEC(1,3) = 1E30
      XSPVEC(3,3) = 0.0
      XSPVEC(2,3) = 1.0
   40 WS1 = WS1N
      WSSD = WSSDN
      WS3 = WS3N
      WSB4(1) = WS1
      WSB4(2) = WSSD
      WSB4(3) = WS3
      WSCR(2) = -1E30
      IF( XSBLOK(1,3) .LE. 0.0 ) GO TO 50
      CALL CRITWS ( QBO, WSCR(2), 1,
     $                          XSPVEC(1,3), XSBLOK(1,3), YTOL )
      IF( ABS( WSCR(2) - YMAX(2) ) .LE. YTOL )
     $                WRITE(MSG,10) SECID(IREC+2), QBO, WSCR(2)
      WSC(IREC+2) = WSCR(2)
   50 CALL CRITWS ( QBO, WSCR(3), 1,
     $                          XSPVEC(1,2), XSBLOK(1,2), YTOL )
      IF( ABS( WSCR(3) - YMAX(3) ) .LE. YTOL )
     $                WRITE(MSG,10) SECID(IREC+1), QBO, WSCR(3)
      WSC(IREC+1) = WSCR(3)
      ITRYFS = 0
   60 ITRYFS = ITRYFS + 1
      NOTFS = 0
      CALL CPARMV ( IBRTYP, CVAR, C, WS1, WSSD, WS3, QBO,
     $                   XSBLOK(1,1), ANSVEC(1,1), XSPVEC(1,1) )
      K1 = XSPVEC(1,5)
      VH1 = ( XSPVEC(3,5) * QT**2 ) / (64.3 * XSPVEC(2,5)**2 )
      BETA3 = 1.0 / C
      ALPHA3 = BETA3 / C
      A3 = XSPVEC(2,2)
      VH3 = ( ALPHA3 * QBO**2 ) / ( 64.3 * A3**2 )
C
C*********DEBUG OUTPUT
          ST=60.111
          WRITE(8,*) ST,BETA3,ALPHA3,A3,K1
C
      QAVG = 0.5 * ( QBO + QT )
      HE3TO4 = ( QAVG**2 ) / ( 64.3 * A4**2 ) * (2.0 * BETA4 -
     $    ALPHA4 - 2.0 * BETA3 * A4/A3 + ALPHA3 * ((A4/A3)**2 ))
      IF( HE3TO4 .LT. 0.0 ) HE3TO4 = 0.0
      IF( HE3TO4 .GT. ABS( VH3 - VH1) ) HE3TO4 = ABS(VH3-VH1)
      K3 = XSPVEC(1,2)
      KSD = XSPVEC(1,3)
      KC = AMIN1( K3, KSD, KQ)
C
C*********DEBUG OUTPUT
          ST=60.222
          WRITE(8,*) K3,KSD,KQ,KC
C
      HF3TO4 = FD3TO4 * QAVG**2 / (KC * K4)
      HF2TO3 = FD2TO3 * ( (QBO / K3)**2 )
C
C*********DEBUG OUTPUT
          ST=60.333
          WRITE(8,*) ST,FDDTO2,QBO
C
      HFDTO2 = FDDTO2 * ( (QBO**2) / (K3 * KSD) )
      HF1TO2 = FD1TO2 * QAVG**2 / (KC * K1)
      WS3 = WS4 + VH4 + HE3TO4 + HF3TO4 - VH3
      IF( WS3 .LT. WSCR(3) ) WS3 = WSCR(3)
      IF( WS3 .GT. YMAX(3) ) WS3 = YMAX(3)
      VHSD = ( XSPVEC(3,3) * QBO**2 )/( 64.3 * XSPVEC(2,3)**2 )
      WSSD = WS3 + VH3 + HF2TO3 + HFDTO2 - VHSD
      IF( WSSD .LT. WSCR(2) ) WSSD = WSCR(2)
      IF( WSSD .GT. YMAX(2) ) WSSD = YMAX(2)
      WS1 = WSSD + VHSD + HF1TO2 - VH1
      IF( WS1 .LT. WSCR(1) ) WS1 = WSCR(1)
      IF( WS1 .GT. YMAX(1) ) WS1 = YMAX(1)
      IF( XSBLOK(1,3) .LE. 0.0 ) WSSD = 0.0
      WSERR(1) = WS1 - WSB4(1)
      WSERR(2) = WSSD - WSB4(2)
      WSERR(3) = WS3 - WSB4(3)
      ITOL = 0
      DO 70 J=1,3
      IF( ABS( WSERR(J) ) .LE. YTOL ) ITOL = ITOL + 2**J
   70 CONTINUE
      IF( ABS( WSERR(1) ) .LT. 1.0 ) GO TO 80
      WS1 = ( WS1 + WSB4(1) ) / 2.0
      WSSD = ( WSSD + WSB4(2) ) / 2.0
      WS3 = ( WS3 + WSB4(3) ) / 2.0
   80 WSB4(1) = WS1
      WSB4(2) = WSSD
      WSB4(3) = WS3
C
C*********DEBUG OUTPUT
          ST=80.111
          WRITE(8,*) ST,ITOL,WSB4
C
      IF( ITOL .EQ. 14 ) GO TO 110
      IF( ITRYFS .LT. 15 ) GO TO 60
      WRITE(MSG,90) IFLOW, QBO, WSB4
C
C**********ERROR MESSAGE
   90 FORMAT(/'  ===225 NO ENERGY BALANCE IN 15 ITERATIONS.',
     $           /21X,'FLOW,Q = ',I4,3X,F8.0/15X,
     $                           'WS1,WSSD,WS3 = ',3(F8.2,3X))
C
      IF( IFLOW .EQ. 1 ) GO TO 210
      WRITE(MSG,100) ITRYCF, QRD, WS, WSMIN, WSMAX
C
C**********ERROR MESSAGE
  100 FORMAT(/'  ===235 CONTINUE FLOW CLASS 4 COMPUTATIONS.',
     $           /21X,'ITER,QRD = ',I4,3X,F8.0/15X,
     $                         'WS,WSMIN,WSMAX = ',3(F8.2,3X))
C
      IF( WSB4(1) .GT. WS ) WSMIN = WS
      IF( WSB4(1) .LT. WS ) WSMAX = WS
      GO TO 310
  110 CONTINUE
      IF( IDIDIT .EQ. 2 ) GO TO 140
      DO 120 I=1,3
      IF( WSB4(I) .GE. YMAX(I) ) NOTFS = NOTFS + 1
  120 CONTINUE
      IF( IFLOW .EQ. 1 ) GO TO 140
      IF( ABS( WS1 - WS ) .LE. YTOL ) GO TO 240
      IF( ITRYCF .GE. 15 ) GO TO 370
      IF( WS1 .GT. WSCR(1) ) GO TO 130
      WSMIN = WS
      GO TO 310
  130 IF( WS1 .LT. WS ) WSMAX = WS
      IF( WS1 .GT. WS ) WSMIN = WS
      GO TO 310
  140 WSMAX = YMAX(1)
      IF( NOTFS .EQ. 0 ) GO TO 160
      WRITE(MSG,150) WSB4, WSCR, YMAX
C
C**********ERROR MESSAGE
  150 FORMAT(/'  ===230 REJECTED FLOW CLASS 1 SOLUTION.',
     $        /15X,'WS1,WSSD,WS3 = ',3(F8.2,3X)/23X,
     $            'CRWS = ',3(F8.2,3X)/23X,'YMAX = ',3(F8.2,3X))
C
      GO TO 170
  160 IF( WS1 .GT. WSCR(1) ) GO TO 180
      WRITE(MSG,150) WSB4, WSCR, YMAX
  170 IFLOW = 0
      WSIU = LSEL
      GO TO 210
  180 DO 190 I=1,3
      WSSAVE(I) = WSB4(I)
      WSSAVE(I+3) = WSCR(I)
  190 CONTINUE
      IFLOB4 = 1
C
C*********DEBUG OUTPUT
          ST=190.111
          WRITE(8,*) ST,WS1,LSEL,RGMIN,IFLOW
C
      IF( IFLOW4 .GT. 0 ) GO TO 240
      IF( WS1 .LT. RGMIN ) GO TO 240
      WRITE(MSG,200) WSB4, RGMIN
C
C**********ERROR MESSAGE
  200 FORMAT(/'  ===215 FLOW CLASS 1 SOLUTION INDICATES ',
     $  'POSSIBLE ROAD OVERFLOW.'/,
     $     12X,'WS1,WSSD,WS3,RGMIN = ',4(F8.2,3X))
C
      GO TO 220
  210 IF( RGMIN .GT. 1E5 ) GO TO 260
      WS1 = YMAX(1)
  220 WRITE(MSG,230)
C
C**********ERROR MESSAGE
  230 FORMAT(/'  ===260 ATTEMPTING FLOW CLASS 4 SOLUTION.')
C
      IFLOW = 4
      IFLOW4 = 4
      FLOW = 4.000001
      WSMAX = WS1
      WSMIN = RGMIN
      GO TO 300
  240 CONTINUE
C
C*********DEBUG OUTPUT
          ST=240.111
          WRITE(8,*) ST
C
      IF( IFLOW2 .GT. 0 ) GO TO 490
      WSIU = WS1 - HF1TO2
      IF( WSIU .LE. LSEL ) GO TO 490
      WRITE(MSG,250) WS3, WSIU, WS1, LSEL
C
C**********ERROR MESSAGE
  250 FORMAT(/'  ===220 FLOW CLASS 1 (4) SOLUTION INDICATES ',
     $         'POSSIBLE PRESSURE FLOW.',
     $                 /12X,'WS3,WSIU,WS1,LSEL = ',4(F8.2,3X))
C
      IFLOB4 = IFLOW
      IF( IFLOW .EQ. 4 ) WSGOOD = WS
  260 WRITE(MSG,270)
C
C**********ERROR MESSAGE
  270 FORMAT(/'  ===245 ATTEMPTING FLOW ',
     $                         'CLASS 2 (5) SOLUTION.')
C
      IFLOW = 2
      IFLOW2 = 2
      WSMIN = LSEL
      WS3 = LSEL
      IF( WS3 .LT. WSIU ) WS3 = WSIU
  280 CONTINUE
      IF( WS3 .GT. YMAX(3) ) WS3 = YMAX(3)
      CALL XSPROP ( WS3, XSPVEC(11,2), XSPVEC(9,2), 1,
     $                                XSPVEC(1,2), XSBLOK(1,2) )
      ANET = XSPVEC(2,2)
      K3 = XSPVEC(1,2)
C
C*********DEBUG OUTPUT
          ST=280.111
          WRITE(8,*) ST,ANET
C
      IF( NPA .LE. 0 ) GO TO 290
      APR = PIERAF( WS3, NPA, XSBLOK(IPTPEA+1,2) )
      ANET = ANET - APR
      AJ = APR / XSPVEC(2,2)
  290 IF( IFLOW .EQ. 3  .OR.  IFLOW .EQ. 6 ) GO TO 300
      Z = ANET / ( XSPVEC(19,2) - XSPVEC(18,2) )
      BEDEL = LSEL - Z
C
C*********DEBUG OUTPUT
          ST=290.111
          WRITE(8,*) ST,WS3,ANET,Z,BEDEL
C
  300 WSMAX = YMAX(1)
      ITRYCF = 0
  310 WS = 0.5 * ( WSMIN + WSMAX )
      ITRYCF = ITRYCF + 1
  320 QERR = 0.0
C
C*********DEBUG OUTPUT
          ST=320.111
          WRITE(8,*) ST,WSMIN,WSMAX,WS
C
      CALL XSPROP ( WS, XSPVEC(13,5), XSPVEC(14,5), 1,
     $                                XSPVEC(1,5), XSBLOK(1,5) )
      VH = XSPVEC(3,5) * ( QT/XSPVEC(2,5) )**2 / 64.3
      K1 = XSPVEC(1,5)
      QRD = 0.0
      QBO = 0.0
      QRDRAT = 0.0
      IF( WS .LE. RGMIN ) GO TO 330
      HF1TOR = FD1TOR * ( ( QT / K1 )**2 )
      EGR = WS + VH - HF1TOR
      WSRD = RGMIN + 5.0 * ( EGR - RGMIN ) / 6.0
      IF( WSRD .GT. WS ) WSRD = WS
      ANSVEC(2,4) = VH
      ANSVEC(9,4) = EGR
      XRDCNT = XREFRD + ( XBR(11) - XREFBR )
C
C*********DEBUG OUTPUT
          ST=320.222
          WRITE(8,*) ST,WSRD,WS3DS,EGR,VH
C
      CALL QOVRRD ( 1, WSRD, WS3DS, XSPVEC(13,4), XRDCNT,
     $                   ANSVEC(1,4), XSPVEC(1,4), XSBLOK(1,4) )
      CALL QOVRRD ( 2, WSRD, WS3DS, XRDCNT, XSPVEC(14,4),
     $                   ANSVEC(1,4), XSPVEC(1,4), XSBLOK(1,4) )
      WRITE(8,*) (ANSVEC(I,4),I=1,40)
      WRITE(8,*) (XSPVEC(I,4),I=1,40)
      QRD = XSPVEC(19,4) + XSPVEC(20,4)
      IF( QRD .LE. 0.0 ) GO TO 330
      CALL XSPROP ( RGMIN, XSPVEC(13,5), XSPVEC(14,5), 1,
     $                                XSPVEC(1,5), XSBLOK(1,5) )
      QRDMAX = QT * ( K1 - XSPVEC(1,5) ) / K1
      QRDRAT = QRD / QRDMAX
C
C*********DEBUG OUTPUT
          ST=320.333
          WRITE(8,*) ST,QRD,QRDMAX,QRDRAT,RGMIN
C
  330 IF( IFLOW .NE. 4 ) GO TO 340
      QBO = QT - QRD
C
C*********DEBUG OUTPUT
          ST=330.111
          WRITE(8,*) ST,QBO,QRD
C
      IF( ITRYCF .GT. 15 ) GO TO 370
      IF( QBO .GT. 1.001*QT ) WSMIN = WS
      IF( QBO .LE. 0.0 ) WSMAX = WS
      IF( QBO .GT. 1.001*QT  .OR.  QBO .LE. 0.0 ) GO TO 310
      GO TO ( 40, 60 ), IDIDIT
  340 HF1TO2 = FD1TO2 * ( ( QT - (0.5 * QRD) )**2 ) / (K1 * K3)
      WSIU = WS - HF1TO2
C
C*********DEBUG OUTPUT
          ST=340.111
          WRITE(8,*) ST,WSIU,HF1TO2
C
      IF( IFLOW .EQ. 3  .OR.  IFLOW .EQ. 6 ) GO TO 350
      YU = WSIU - BEDEL
      IF( YU/Z .LT. 1.0 ) GO TO 360
      YOZ = YU/Z
      IF( (YU - Z/2.0 + VH) .LE. 0.0 ) GO TO 360
      CDORFQ = UZRCOD
      IF( CDORFQ .LE. 0.0) CDORFQ = TERPL8( YU/Z, 1, 11,YUOVRZ,ORFQCD )
      QBO = 8.02 * CDORFQ * ANET * SQRT(YU - Z/2.0 + VH)
C
C*********DEBUG OUTPUT
          ST=340.222
          WRITE(8,*) ST,YU,YOZ,CDORFQ,VH,QBO,WS
C
      GO TO 360
  350 IF( WSIU + VH - WS3DS .LE. 0.0 ) GO TO 360
      QBO = 6.42 * ANET * SQRT(WSIU + VH - WS3DS)
C
C*********DEBUG OUTPUT
          ST=350.111
          WRITE(8,*) ST,QBO,IFLOW
C
  360 QERR = (QBO + QRD - QT) / QT
      IF( IFLOW .GT. 3 ) IFLOW = IFLOW - 3
      IF( QRD .GT. 0.0 ) IFLOW = IFLOW + 3
      FLOW = IFLOW * 1.00001
      IF( ABS( QERR ) .LE. QTOL ) GO TO 420
      IF( ITRYCF .GE. 15 ) GO TO 370
      IF( QERR .GT. 0.0 ) WSMAX = WS
      IF( QERR .LT. 0.0 ) WSMIN = WS
C
C*********DEBUG OUTPUT
          ST=360.111
          WRITE(8,*) ST,QBO,QRD,IFLOW,FLOW,WSMIN,WSMAX,WS
C
      GO TO 310
  370 WRITE(MSG,380) WS, QBO, QRD
C
C**********ERROR MESSAGE
  380 FORMAT(/'  ===240 NO DISCHARGE BALANCE IN 15 ',
     $     'ITERATIONS.'/20X,'WS,QBO,QRD = ',F8.2,2(3X,F8.0))
C
      IF( IFLOW .EQ. 2 .OR. IFLOW .EQ. 5 ) GO TO 430
      IF( IFLOW .NE. 4 ) GO TO 400
      WRITE(MSG,390)
C
C**********ERROR MESSAGE
  390 FORMAT(/'  ===280 REJECTED FLOW CLASS 4 SOLUTION.')
C
      IF( IFLOW2 .GT. 0 ) GO TO 450
      WSIU = LSEL
      GO TO 260
  400 WRITE(MSG,410)
C
C**********ERROR MESSAGE
  410 FORMAT(/'  ===275 REJECTED FLOW CLASS 3 (6) SOLUTION.')
C
      GO TO 450
  420 IF( IFLOW .EQ. 3  .OR.  IFLOW .EQ. 6 ) GO TO 480
      IF( YOZ .GT. 1.10 ) GO TO 480
      WRITE(MSG,425) YOZ, WSIU, WS
C
C**********ERROR MESSAGE
  425 FORMAT(/'  ===250 INSUFFICIENT HEAD FOR PRESSURE FLOW.',
     $                 /25X,'YU/Z,WSIU,WS = ',F4.2,2(3X,F8.2))
C
  430 WRITE(MSG,440)
C
C**********ERROR MESSAGE
  440 FORMAT(/'  ===270 REJECTED FLOW CLASS 2 (5) SOLUTION.')
C
  450 CONTINUE
      IF( IFLOB4 .EQ. 0 ) GO TO 999
      IF( IFLOB4 .EQ. 4 ) GO TO 470
      QBO = QT
      QRD = 0.0
      DO 460 I=1,3
      WSB4(I) = WSSAVE(I)
      WSCR(I) = WSSAVE(I+3)
  460 CONTINUE
  470 WS1 = WSB4(1)
      WSSD = WSB4(2)
      WS3 = WSB4(3)
      IDIDIT = 2
      IFLOW = IFLOB4
      FLOW = IFLOW * 1.0001
      IF( IFLOW .EQ. 1 ) GO TO 60
      WS = WSGOOD
      ITRYCF = 0
      GO TO 320
  480 WS1 = WS
      WSSD = -1E30
      C = CDORFQ
      WSERR(1) = QERR
  490 OTEL = 1E30
      IF( QRD .GT. 0.0 ) GO TO 510
      WSRD = -1E30
      DO 500 I=19,38
      XSPVEC(I,4) = 1.0E30
  500 CONTINUE
      GO TO 530
  510 IF( QRDRAT .GT. 1.0 )
     $                        WRITE(MSG,520) QRD, QRDMAX, QRDRAT
C
C**********ERROR MESSAGE
  520 FORMAT(/'  ===265 ROAD OVERFLOW APPEARS EXCESSIVE.',
     $             /20X,'QRD,QRDMAX,RATIO = ',2(F8.0,3X),F5.2)
C
  530 IF( IFLOW .EQ. 1  .OR.  IFLOW .EQ. 4 ) GO TO 550
      IF( XSBLOK(1,3) .LE. 0.0 ) GO TO 540
      CALL MOVEO ( XSPVEC(1,3), DUMVEC, IOFF, NDUM )
      CALL CRITWS ( QBO, WSC(IREC+2), 1, DUMVEC,
     $                                       XSBLOK(1,3), YTOL )
      IF( WSC(IREC+2) .GE. YMAX(2) )
     $            WRITE(MSG,10) SECID(IREC+2), QBO, WSC(IREC+2)
  540 CALL MOVEO ( XSPVEC(1,2), DUMVEC, IOFF, NDUM )
      CALL CRITWS ( QBO, WSC(IREC+1), 1, DUMVEC,
     $                                       XSBLOK(1,2), YTOL )
      IF( WSC(IREC+1) .GE. YMAX(3) )
     $            WRITE(MSG,10) SECID(IREC+1), QBO, WSC(IREC+1)
      GO TO 580
  550 IF( WS3 .GT. WSC(IREC+1) ) GO TO 570
      WRITE(MSG,560) SECID(IREC+1), QBO, WSC(IREC+1)
C
C**********ERROR MESSAGE
  560 FORMAT(/'  ===285 CRITICAL WATER-SURFACE ELEVATION ',
     $           ' A _ S _ S _ U _ M _ E _ D !!!!!',
     $       /20X,'SECID "',A5,'"',5X,'Q,CRWS = ',F8.0,3X,F8.2)
C
      HE3TO4 = 1.0E30
      HF3TO4 = 1.0E30
      WSERR(3) = 1.0E30
  570 IF( XSBLOK(1,3) .LE. 0.0 ) GO TO 580
      IF( WSSD .GT. WSC(IREC+2) ) GO TO 580
      WRITE(MSG,560) SECID(IREC+2), QBO, WSC(IREC+2)
      HF2TO3 = 1.0E30
      HFDTO2 = 1.0E30
      WSERR(2) = 1.0E30
  580 IF( IFLOW .LT. 4 ) OTEL = WS1 - FD1TOR * ( (QT / K1)**2 )
      CALL STORIT ( ANSVEC(1,5), LIST1, WS1, QT, ZD1TO2,
     $                                      WSC(IRECAS), DUMMY )
      CALL STORIT ( ANSVEC(1,4), LIST1, WSRD, QRD, ZD1TOR,
     $                                            DUMMY, DUMMY )
      CALL STORIT ( ANSVEC(1,3), LIST1, WSSD, QBO, ZDDTO2,
     $                                      WSC(IREC+2), DUMMY )
      CALL STORIT ( ANSVEC(1,2), LIST1, WS3, QBO, ZD3TO4,
     $                                      WSC(IREC+1), DUMMY )
      CALL STORIT ( ANSVEC(1,5), LIST2, WSERR(1), FD1TO2,
     $                                    HF1TO2, HF2TO3, OTEL )
      CALL XSPROP ( WS1 ,XSPVEC(13,5), XSPVEC(14,5), 1,
     $                                XSPVEC(1,5), XSBLOK(1,5) )
      CALL HYDEQS ( 1, ANSVEC(1,5), 1, XSPVEC(1,5) )
      IF( IFLOW .LT. 4 ) GO TO 590
      CALL STORIT ( ANSVEC(1,4), LIST2, QERR, FD1TOR, HF1TOR,
     $                                            DUMMY, DUMMY )
  590 IF( WSSD .LE. 0.0 ) GO TO 600
      CALL STORIT ( ANSVEC(1,3), LIST2, WSERR(2), FDDTO2,
     $                                    HFDTO2, DUMMY, DUMMY )
      CALL XSPROP ( WSSD, XSPVEC(11,3), XSPVEC(9,3), 1,
     $                                XSPVEC(1,3), XSBLOK(1,3) )
      CALL HYDEQS ( 1, ANSVEC(1,3), 1, XSPVEC(1,3) )
  600 IF( IFLOW .NE. 1  .AND.  IFLOW .NE. 4 ) GO TO 610
      IF( IBRTYP .EQ. 1 ) ANSVEC(16,2) = CVAR(9)
      AJ = CVAR(5)
      CALL STORIT ( ANSVEC(1,5), LIST3, CVAR(2), KQ,
     $                                    XLTKQ, XRTKQ, EMPRIM )
      CALL STORIT ( ANSVEC(1,2), LIST2, WSERR(3), FD3TO4,
     $                                   HF3TO4, HE3TO4, DUMMY )
      CALL XSPROP ( WS3, XSPVEC(11,2), XSPVEC(9,2), 1,
     $                                XSPVEC(1,2), XSBLOK(1,2) )
      XSPVEC(3,2) = ALPHA3
      XSPVEC(4,2) = BETA3
      GO TO 620
  610 XSPVEC(2,2) = ANET
  620 CALL HYDEQS ( 1, ANSVEC(1,2), 1, XSPVEC(1,2) )
      CALL STORIT ( ANSVEC(1,2), LIST3, XSBLOK(IPTABG+1,2),
     $   XSBLOK(IPTABG+12,2), XSBLOK(IPTABG+13,2), LSEL, DUMMY )
      CALL STORIT ( ANSVEC(1,2), LIST4, FLOW,
     $          XSBLOK(IPTMSC+6,2), C, XSBLOK(IPTMSC+20,2), AJ )
      RETURN
C
  999 ERRFLG = 1.0
      RETURN
      END
C                                     <<<<<SUBPROGRAM CPARMS>>>>>
C     <<<<<LAST REVISED 01-02-86>>>>>
C
      SUBROUTINE   CPARMS ( PROFN, CVAR, IBRTYP, XSBLOK,
     $                                           ANSVEC, XSPVEC )
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / XPARMS / XBR(21), XAS(21), XREFBR
      COMMON / LPARMS / ZD1TO2, ZDDTO2, ZD2TO3, ZD3TO4,
     $                  FD1TO2, FDDTO2, FD2TO3, FD3TO4
      COMMON / KQBLK / KQ, XLTKQ, XRTKQ, UZRCOD, UZRBRL, UZRXKQ
C
      REAL KQ
      DIMENSION  XSBLOK(IPTEND,5), ANSVEC(40,5), XSPVEC(40,5),
     $                              CVAR(1), XBPAS(4), PROFN(14)
C
C          ESTABLISH THE FIXED PARAMETERS REQUIRED TO DETERMINE
C          THE COFFICIENT OF DISCHARGE.
C
      WS1N=PROFN(1)
      WS3N=PROFN(5)
      XREFBR=XSBLOK(IPTABG+12,2)
      IF (ABS(XREFBR).GT.1E5) XREFBR=XSPVEC(11,2)
      DO 5 I=1,4
      XBPAS(I)=XSBLOK(IPTMSC+25+I,5)
      IF (ABS(XBPAS(I)).GT.1E5) XBPAS(I)=-1E10
    5 CONTINUE
      IF (ABS(XBPAS(1)).GT.1E5) XBPAS(1)=XREFBR
      IBRTYP=XSBLOK(IPTMSC+6,2)
      BRWDTH=XSBLOK(IPTMSC+7,2)
      XLTKQ=XSBLOK(IPTMSC+17,2)
      XRTKQ=XSBLOK(IPTMSC+18,2)
      UZRXKQ=XRTKQ-XLTKQ
      XAS(11)=XSBLOK(IPTMSC+25,2)
      UZRCOD=XSBLOK(IPTMSC+19,2)
      XBR(1)=XSBLOK(IPTMSC+22,2)
      XBR(21)=XSBLOK(IPTMSC+23,2)
      XBR(11)=XSBLOK(IPTMSC+24,2)
      UZRBRL=XBR(21)-XBR(1)
      IF(UZRBRL.LE.0.) GO TO 60
      CALL XSPROP(WS3N,XBR(1),XBR(21),1,XSPVEC(1,2),XSBLOK(1,2))
      GO TO 70
   60 CALL XSPROP(WS3N,XSPVEC(11,2),XSPVEC(9,2),1,XSPVEC(1,2),
     *            XSBLOK(1,2))
      XBR(1)=XSPVEC(18,2)
      XBR(21)=XSPVEC(19,2)
   70 IF(XBR(11).GT.XBR(1).AND.XBR(11).LT.XBR(21)) GO TO 80
      CALL CNTRDK(XBR(11),WS3N,XBR(1),XBR(21),XSPVEC(1,2),2.,
     *            XSBLOK(1,2))
   80 CALL PARTK(WS3N,XBR,XSPVEC(1,2),2.,XSBLOK(1,2))
      CALL XSPROP(WS1N,XSPVEC(13,5),XSPVEC(14,5),1,XSPVEC(1,5),
     *            XSBLOK(1,5))
      XAS(1)=XSPVEC(18,5)
      XAS(21)=XSPVEC(19,5)
      CALL CNTRDK(XAS(11),WS1N,XAS(1),XAS(21),XSPVEC(1,5),0.,
     *        XSBLOK(1,5))
   90 CALL PARTK(WS1N,XAS,XSPVEC(1,5),0.,XSBLOK(1,5))
      ZD1TO2=PROFN(2)-PROFN(6)-BRWDTH
      IF(XSBLOK(1,3).GT.0.) ZD1TO2=PROFN(2)-PROFN(4)
C*********DEBUG OUTPUT
          ST=90.111
          WRITE(8,*) ST,XBR,XAS,ZD1TO2
      CALL GETLAV(XBR,XAS,ZD1TO2,FD1TO2,XSPVEC(15,2),
     *                          XSPVEC(15,5),XREFBR,XBPAS)
C*********DEBUG OUTPUT
          ST=95.111
          WRITE(8,*) ST,FD1TO2,UZRBRL
      ZDDTO2=-0.0001
      ZD2TO3=BRWDTH
      ZD3TO4=PROFN(6)-PROFN(10)
      FD3TO4=ZD3TO4
      IF(XSBLOK(1,3).LE.0.) GO TO 120
      CVAR(14)=XSBLOK(IPTMSC+6,3)
      CVAR(13)=XSBLOK(IPTMSC+7,3)
      ZDDTO2=PROFN(4)-PROFN(6)-BRWDTH
  120 IF(ZDDTO2.LT. 0.0) ZDDTO2=0.0
      FDDTO2=ZDDTO2
      IF(UZRCOD.GT.0.) GO TO 150
      CVAR(12)=FDDTO2
      CVAR(15)= XSBLOK(IPTMSC+8,2)
      CVAR(4)=XSBLOK(IPTMSC+20,2)
      IF(IBRTYP.EQ.1.OR.IBRTYP.EQ.4) CVAR(8)=XSBLOK(IPTMSC+11,2)
      IF(IBRTYP.NE.1) GO TO 150
      CVAR(7)=XSBLOK(IPTMSC+12,2)
      CVAR(6)=XSBLOK(IPTMSC+13,2)
  150 RETURN
      END
C                                     <<<<<SUBPROGRAM CPARMV>>>>>
C     <<<<<LAST REVISED 01-02-86>>>>>
C
      SUBROUTINE   CPARMV ( IBRTYP, CVAR, C, WS1, WSSD,
     $                         WS3, QBO, XSBLOK, ANSVEC, XSPVEC )
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / XPARMS / XBR(21), XAS(21), XREFBR
      COMMON / LPARMS / ZD1TO2, ZDDTO2, ZD2TO3, ZD3TO4,
     $                  FD1TO2, FDDTO2, FD2TO3, FD3TO4
      COMMON / KQBLK / KQ, XLTKQ, XRTKQ, UZRCOD, UZRBRL, UZRXKQ
C
      REAL KQ
      DIMENSION  XSBLOK(IPTEND,5), ANSVEC(40,5), XSPVEC(40,5),
     $                              CVAR(1), XBPAS(4), PROFN(14)
C
C          ESTABLISH THE DYNAMIC PARAMETERS REQUIRED TO DETERMINE
C          THE COEFFICIENT OF DISCHARGE.
C
      CALL XSPROP(WS3,XSPVEC(11,2),XSPVEC(9,2),1,XSPVEC(1,2),
     *            XSBLOK(1,2))
      IF(XSBLOK(1,3).LE.0.0) GO TO 190
      CALL XSPROP(WSSD,XSPVEC(11,3),XSPVEC(9,3),1,XSPVEC(1,3),
     *            XSBLOK(1,3))
  190 XEMBUS=0.0
      XEMBDS=0.0
      IF(IBRTYP.EQ.1) GO TO 200
      XEMBUS=CVAR(15)*(XSBLOK(IPTMSC+21,2)-WS1)
      IF(XEMBUS.LT.0.) XEMBUS=0.
      IF(IBRTYP.NE.2) GO TO 200
      XEMBDS=CVAR(15)*(XSBLOK(IPTMSC+21,2)-WS3)
      IF(XEMBDS.LT.0.) XEMBDS=0.
  200 FD2TO3=ZD2TO3+XEMBUS+XEMBDS
      DELBYA=0.
      DELBYB=0.
C*********DEBUG OUTPUT
          ST=206.666
          WRITE(8,*) ST,UZRXKQ,UZRBRL
      IF(IBRTYP.NE.2.AND.IBRTYP.NE.3) GO TO 210
      IF(IBRTYP.EQ.2.AND.UZRCOD.GT.0.) GO TO 210
      IF(IBRTYP.EQ.3.AND.UZRBRL.GT.0.) GO TO 210
      YA=-1.0E30
      YB=YA
      IF(ABS(XSBLOK(IPTMSC+15,2)).GT.1E5) GO TO 202
      YA=WS3-XSBLOK(IPTMSC+15,2)
  202 IF(ABS(XSBLOK(IPTMSC+16,2)).GT.1E5) GO TO 204
      YB=WS3-XSBLOK(IPTMSC+16,2)
  204 IF(YA.LT.0.0) YA=0.0
      IF(YB.LT.0.0) YB=0.0
      IF(IBRTYP.EQ.2) GO TO 210
      IF(ABS(XSBLOK(IPTMSC+9,2)).GT.1E5) GO TO 208
      DELBYA=0.5*YA*XSBLOK(IPTMSC+9,2)
  208 IF(ABS(XSBLOK(IPTMSC+10,2)).GT.1E5) GO TO 210
      DELBYB=0.5*YB*XSBLOK(IPTMSC+10,2)
  210 IF(UZRBRL.LE.0.) GO TO 220
      XLTBR=XBR(1)
      XRTBR=XBR(21)
      GO TO 230
  220 XLTBR=XSPVEC(18,2)+DELBYA
      XRTBR=XSPVEC(19,2)-DELBYB
  230 IF(UZRXKQ.GT.0.) GO TO 240
      XLTKQ=XAS(11)-(XBR(11)-XLTBR)
      XRTKQ=XAS(11)+(XRTBR-XBR(11))
  240 BKQ=XRTKQ-XLTKQ
      IF(BKQ.LE.(XSPVEC(9,5)-XSPVEC(11,5))) GO TO 250
      XLTKQ=XSPVEC(11,5)
      XRTKQ=XSPVEC(9,5)
      GO TO 270
  250 IF(XLTKQ.GE.XSPVEC(11,5)) GO TO 260
      XLTKQ=XSPVEC(11,5)
      XRTKQ=XLTKQ+BKQ
      GO TO 270
  260 IF(XRTKQ.LE.XSPVEC(9,5)) GO TO 270
      XRTKQ=XSPVEC(9,5)
      XLTKQ=XRTKQ-BKQ
  270 CALL XSPROP(WS1,XLTKQ,XRTKQ,1,XSPVEC(1,5),XSBLOK(1,5))
      KQ=XSPVEC(1,5)
      CALL XSPROP(WS1,XSPVEC(13,5),XSPVEC(14,5),1,XSPVEC(1,5),
     *            XSBLOK(1,5))
      B=XRTBR-XLTBR
      AJ=-1E10
      IF(XSBLOK(5,2).LE.0) GO TO 280
      NPA=XSBLOK(5,2)
      APR=PIERAF(WS3,NPA,XSBLOK(IPTPEA+1,2))
      AJ=APR/XSPVEC(2,2)
  280 CVAR(5)=AJ
      C=UZRCOD
      IF(C.GT.0.0) GO TO 290
      CVAR(1)=FD2TO3
C*********DEBUG OUTPUT
          ST=270.555
          WRITE(8,*) ST
      EM=1.-(KQ/XSPVEC(1,5))
      IF(EM.LT.0.) EM=0.
C*********DEBUG OUTPUT
          ST=270.888
          WRITE(8,*) ST,EM,B
      CVAR(2)=EM
      CVAR(3)=B
      IF(IBRTYP.EQ.1) CVAR(9)=QBO/(SQRT(32.17*XSPVEC(2,2)/B)
     *                *XSPVEC(2,2))
      IF(IBRTYP.EQ.2) CVAR(10)=0.5*(YA+YB)
      IF(IBRTYP.EQ.3) CVAR(11)=XEMBUS
      CALL CVALUE(C,IBRTYP,CVAR)
  290 RETURN
      END
      SUBROUTINE CVALUE(C,IBRTYP,CVAR)
C
C***   LAST REVISED 10-19-84
C
      DIMENSION TYP1(6,8),TYP2A(6,8),TYP2B(6,8),TYP3A(6,8),TYP3B(6,8),
     1  TYP3C(6,8),TYP4A(6,8),TYP4B(6,8)
      DIMENSION AKRND(7,6),AKW30(7,6),AKW45(7,6),AKW60(7,6),AKY1(5,5),
     1  AKY2(5,5),AKX1(6,3),AKX2(6,3),AKD1(6,4),AKD2(6,4),AKA1(6,4),
     2  AKB1(6,4),AKJPER(5,5),AKJPIL(5,5),AKJPEC(6,4)
      DIMENSION DEXM(6),DEXB(8)
      DIMENSION DM1(6),DW1(7),DYOB2(5),DM2(5),DXOB3(6),DLOB3(3)
      DIMENSION SDM(4),SDLDOB(6),SDLDBD(6),PIJ(5),PIM(5),PLOB(5)
      DIMENSION THSL1(6),THSL2(6)
      DIMENSION PLKJC(4),PLJC(6)
      DIMENSION CVAR(15),FACTRK(9)
      DATA DEXM/0.0,0.1,0.3,0.5,0.8,1.0/
      DATA DEXB/0.0,0.2,0.4,0.6,0.8,1.0,1.5,2.0/
      DATA DM1/0.1,0.2,0.4,0.6,0.8,1.0/
      DATA DW1/0.01,0.02,0.04,0.06,0.08,0.1,0.14/
      DATA DYOB2/0.03,0.05,0.07,0.1,0.15/
      DATA DM2/0.0,0.2,0.4,0.7,1.0/
      DATA DLOB3/0.0,0.2,0.5/
      DATA DXOB3/0.0,0.08,0.12,0.16,0.20,0.25/
      DATA SDM/0.2,0.4,0.6,0.8/
      DATA SDLDOB/0.0,0.2,0.4,0.6,1.0,1.5/
      DATA SDLDBD/0.0,0.5,1.0,1.5,2.0,2.8/
      DATA PIJ/0.0,0.05,0.1,0.15,0.2/
      DATA PIM/0.4,0.6,0.8,0.9,1.0/
      DATA PLOB/0.0,0.25,0.5,1.0,2.0/
      DATA PLKJC/0.76,0.8,0.9,1.0/
      DATA PLJC/0.0,0.04,0.08,0.12,0.16,0.2/
      DATA THSL1/0.00057,0.001,0.002,0.00343,0.00413,0.00483/
      DATA THSL2/0.00243,0.00283,0.00373,0.00467,0.00557,0.00667/
      DATA TYP1/1.0,0.83,0.745,0.7,0.67,0.67,1.0,0.92,0.81,0.74,0.685,
     1  0.685,1.0,0.95,0.86,0.775,0.71,0.71,1.0,0.965,0.89,0.82,0.735,
     2  0.735,1.0,0.97,0.91,0.855,0.77,0.765,1.0,0.98,0.935,0.885,0.8,
     3  0.795,1.0,0.985,0.95,0.91,0.845,0.835,1.0,0.99,0.955,0.92,
     4  0.87,0.86/
      DATA TYP2A/1.0,0.92,0.845,0.805,0.755,0.745,1.0,0.955,0.88,0.83,
     1  0.775,0.765,1.0,0.97,0.91,0.85,0.795,0.79,1.0,0.975,0.925,0.87,
     2  0.81,0.805,1.0,0.98,0.94,0.895,0.835,0.825,1.0,0.985,0.95,0.91,
     3  0.855,0.845,1.0,0.988,0.96,0.93,0.885,0.88,1.0,0.99,0.965,0.94,
     4  0.905,0.90/
      DATA TYP2B/1.,0.965,0.915,0.86,0.79,0.78,1.0,0.97,0.925,0.87,
     1  0.8,0.79,1.0,0.98,0.935,0.89,0.81,0.8,1.0,0.99,0.95,0.90,0.83,
     2  0.82,1.0,0.995,0.96,0.91,0.845,0.83,1.0,1.0,0.97,0.925,0.855,
     3  0.84,1.0,1.0,0.975,0.94,0.89,0.875,1.0,1.0,0.98,0.95,
     4  0.905,0.895/
      DATA TYP3A/1.0,0.85,0.74,0.71,0.69,0.69,1.0,0.91,0.79,0.745,0.71,
     1  0.71,1.0,0.945,0.83,0.775,0.74,0.735,1.0,0.97,0.87,0.81,0.765,
     2  0.76,1.0,0.985,0.91,0.85,0.795,0.79,1.0,0.995,0.945,0.88,0.82,
     3  0.81,1.0,1.0,0.96,0.91,0.86,0.85,1.0,1.0,0.97,0.925,0.88,0.875/
      DATA TYP3B/1.0,0.885,0.76,0.715,0.7,0.7,1.0,0.92,0.8,0.75,0.725,
     1  0.72,1.0,0.945,0.84,0.78,0.75,0.745,1.0,0.97,0.88,0.815,0.77,
     2  0.765,1.0,0.99,0.915,0.85,0.805,0.8,1.0,1.0,0.945,0.88,0.83,
     3  0.825,1.0,1.0,0.955,0.905,0.87,0.87,1.0,1.0,0.965,0.92,0.885,
     4  0.885/
      DATA TYP3C/1.0,0.9,0.78,0.72,0.7,0.7,1.0,0.92,0.81,0.755,0.72,
     1  0.72,1.0,0.94,0.845,0.785,0.75,0.75,1.0,0.96,0.875,0.81,0.78,
     2  0.78,1.0,0.985,0.91,0.845,0.81,0.81,1.0,1.0,0.94,0.87,0.845,
     3  0.84,1.0,1.0,0.95,0.905,0.875,0.87,1.0,1.0,0.96,0.92,0.895,0.89/
      DATA TYP4A/0.99,0.85,0.755,0.715,0.695,0.69,1.0,0.9,0.815,0.775,
     1  0.735,0.73,1.0,0.955,0.885,0.83,0.775,0.77,1.0,0.985,0.935,
     2  0.875,0.815,0.81,1.0,0.99,0.955,0.91,0.84,0.835,1.0,1.0,0.965,
     3  0.925,0.855,0.85,1.0,1.0,0.97,0.94,0.89,0.885,1.0,1.0,0.975,
     4  0.95,0.905,0.9/
      DATA TYP4B/1.0,0.93,0.8,0.705,0.67,0.67,1.0,0.95,0.855,0.765,
     1  0.725,0.725,1.0,0.97,0.895,0.815,0.78,0.78,1.0,0.985,0.925,
     2  0.845,0.805,0.805,1.0,0.99,0.94,0.87,0.825,0.825,1.0,0.995,
     3  0.95,0.89,0.85,0.85,1.0,0.995,0.965,0.91,0.88,0.88,1.0,1.0,
     4  0.97,0.925,0.89,0.89/
      DATA AKRND/1.06,1.07,1.07,1.07,1.07,1.07,1.07,1.04,1.08,1.11,
     1  1.11,1.11,1.11,1.11,1.03,1.05,1.09,1.12,1.14,1.15,1.16,1.02,
     2  1.04,1.08,1.12,1.15,1.17,1.18,1.02,1.04,1.08,1.12,1.16,1.18,
     3  1.20,1.02,1.04,1.08,1.12,1.16,1.18,1.22/
      DATA AKW30/1.01,1.02,1.02,1.02,1.02,1.02,1.02,1.01,1.025,1.04,
     1  1.04,1.04,1.04,1.04,1.01,1.025,1.04,1.06,1.06,1.06,1.06,1.01,
     2  1.025,1.05,1.06,1.07,1.07,1.07,1.01,1.025,1.05,1.07,1.08,1.09,
     3  1.09,1.01,1.025,1.05,1.07,1.08,1.09,1.1/
      DATA AKW45/1.0,1.01,1.01,1.02,1.02,1.02,1.02,1.01,1.02,1.04,
     1  1.04,1.05,1.05,1.05,1.03,1.05,1.07,1.08,1.09,1.09,1.09,1.03,
     2  1.06,1.10,1.11,1.12,1.12,1.12,1.03,1.06,1.11,1.13,1.15,1.15,
     3  1.15,1.03,1.06,1.11,1.13,1.15,1.16,1.17/
      DATA AKW60/1.02,1.04,1.05,1.05,1.05,1.05,1.05,1.03,1.07,1.09,
     1  1.10,1.10,1.1,1.1,1.04,1.09,1.15,1.18,1.18,1.18,1.18,1.04,1.09,
     2  1.15,1.21,1.24,1.25,1.26,1.04,1.09,1.15,1.22,1.26,1.28,1.29,
     3  1.04,1.09,1.15,1.22,1.26,1.28,1.32/
      DATA AKX1/1.0,1.09,1.13,1.14,1.14,1.14,1.0,1.11,1.155,1.16,1.16,
     1  1.16,1.0,1.135,1.19,1.20,1.20,1.20/
      DATA AKX2/1.0,1.055,1.085,1.09,1.095,1.10,1.0,1.065,1.10,1.105,
     1  1.11,1.115,1.0,1.08,1.11,1.12,1.125,1.13/
      DATA AKD1/1.0,1.23,1.32,1.37,1.41,1.42,1.0,1.2,1.3,1.35,1.39,
     1  1.4,1.0,1.16,1.25,1.3,1.35,1.36,1.0,1.11,1.2,1.25,1.29,1.3/
      DATA AKD2/1.0,1.09,1.18,1.25,1.27,1.27,1.0,1.08,1.16,1.22,1.24,
     1  1.24,1.0,1.07,1.14,1.18,1.21,1.21,1.0,1.06,1.12,1.16,1.18,1.18/
      DATA AKA1/1.0,0.96,0.935,0.92,0.91,0.905,1.0,0.968,0.95,0.935,
     1  0.93,0.925,1.0,0.976,0.96,0.95,0.94,0.935,1.0,0.984,0.973,
     2  0.965,0.955,0.95/
      DATA AKB1/1.0,0.99,1.0,1.06,1.1,1.0,1.0,0.97,0.98,1.04,1.08,
     1  1.0,1.0,0.94,0.94,1.0,1.05,1.0,1.0,0.89,0.88,0.945,1.01,1.0/
      DATA AKJPER/1.0,1.0,1.0,1.0,1.0,0.978,0.979,0.985,0.991,1.0,
     1  0.955,0.957,0.967,0.98,1.0,0.93,0.933,0.948,0.968,1.0,
     2  0.903,0.907,0.928,0.956,1.0/
      DATA AKJPIL/1.0,1.0,1.0,1.0,1.0,0.973,0.973,0.984,0.99,1.0,
     1  0.933,0.94,0.96,0.976,1.0,0.88,0.888,0.92,0.953,1.0,0.76,0.772,
     2  0.84,0.905,1.0/
      DATA AKJPEC/1.0,0.902,0.81,0.71,0.615,0.52,1.0,0.92,0.841,
     1  0.761,0.684,0.605,1.0,0.961,0.921,0.88,0.842,0.802,1.0,1.0,
     2  1.0,1.0,1.0,1.0/
      DATA AKY1/1.0,0.94,0.895,0.86,0.86,1.0,0.97,0.93,0.88,0.88,1.0,
     1  0.985,0.955,0.91,0.91,1.0,0.995,0.98,0.94,0.94,1.0,1.0,1.0,
     2  0.98,0.98/
      DATA AKY2/1.0,0.935,0.89,0.88,0.88,1.0,0.965,0.925,0.91,0.91,1.0,
     1  0.975,0.95,0.945,0.945,1.0,0.985,0.97,0.97,0.97,1.0,0.99,0.99,
     2  0.99,0.99/
      DATA SUBPGM/040404./
      WRITE(8,*) SUBPGM
      DO 10 I=1,9
      FACTRK(I)=1.00
   10 CONTINUE
      ELOVRB=CVAR(1)/CVAR(3)
      IF(ELOVRB.GT.2.0) ELOVRB=2.0
      EM=CVAR(2)
      IF(IBRTYP.GT.1) GO TO 70
C
C  COMPUTE C', KF, KR, & KW FOR TYPE 1 OPENING
C
      CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP1,EM,ELOVRB)
      FRDN=CVAR(9)
      IF(FRDN.GT.1.2) FRDN=1.2
      IF(FRDN.LE.0.0) FRDN=0.0
      FACTRK(1)=0.2*FRDN+0.9
      IF(FRDN.GT.0.5) FACTRK(1)=FACTRK(1)+0.16*FRDN-0.08
      ROVRB=CVAR(6)/CVAR(3)
      IF(ROVRB.LE.0.) GO TO 20
      IF(ROVRB.GT.0.14) ROVRB=0.14
      CALL GRIDPT(FACTRK(2),7,DW1,6,DM1,AKRND,ROVRB,EM)
   20 WWANGL=CVAR(8)
      IF(WWANGL.LE.0.) GO TO 190
      WOVRB=CVAR(7)/CVAR(3)
      IF(WOVRB.LT.0.0005) GO TO 190
      IF(WOVRB.GT.0.01) GO TO 30
      FACTRK(3)=1.01
      GO TO 190
   30 IF(WOVRB.GT.0.14) WOVRB=0.14
      IF(WWANGL.GT.22.5) GO TO 40
      FACTRK(3)=1.0+WOVRB*EM
      GO TO 190
   40 IF(WWANGL.GT.52.5) GO TO 60
      IF(WWANGL.GT.37.5) GO TO 50
      CALL GRIDPT(FACTRK(3),7,DW1,6,DM1,AKW30,WOVRB,EM)
      GO TO 190
   50 CALL GRIDPT(FACTRK(3),7,DW1,6,DM1,AKW45,WOVRB,EM)
      GO TO 190
   60 CALL GRIDPT(FACTRK(3),7,DW1,6,DM1,AKW60,WOVRB,EM)
      GO TO 190
   70 EMBSS=CVAR(15)
      GO TO (80,80,100,120),IBRTYP
C
C  COMPUTE C' & KY FOR TYPE 2 OPENING
C
   80 YOVR2B=CVAR(10)/CVAR(3)
      IF(YOVR2B.LT.0.03) YOVR2B=0.03
      IF(EMBSS.GT.1.5) GO TO 90
      CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP2A,EM,ELOVRB)
      IF(YOVR2B.GE.0.15) GO TO 190
      CALL GRIDPT(FACTRK(4),5,DM2,5,DYOB2,AKY1,EM,YOVR2B)
      GO TO 190
   90 CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP2B,EM,ELOVRB)
      IF(YOVR2B.GE.0.15) GO TO 190
      CALL GRIDPT(FACTRK(4),5,DM2,5,DYOB2,AKY2,EM,YOVR2B)
      GO TO 190
C
C  COMPUTE C' & KX FOR TYPE 3 OPENING
C
  100 XOVRB=CVAR(11)/CVAR(3)
      IF(XOVRB.GT.0.30) XOVRB=0.30
      XLOB=ELOVRB
      IF(XLOB.GT.0.5) XLOB=0.5
      IF(EMBSS.GT.1.75) GO TO 115
      IF(EMBSS.GT.1.25) GO TO 110
      CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP3A,EM,ELOVRB)
      CALL GRIDPT(FACTRK(5),5,DXOB3,3,DLOB3,AKX1,XOVRB,XLOB)
      GO TO 190
  110 CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP3B,EM,ELOVRB)
      CALL GRIDPT(FACTRK(5),5,DXOB3,3,DLOB3,AKX2,XOVRB,XLOB)
      GO TO 190
  115 CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP3C,EM,ELOVRB)
      FACTRK(5)=1.0+0.3*XOVRB
      IF(XOVRB.GT.0.20) FACTRK(5)=FACTRK(5)+0.02-0.1*XOVRB
      GO TO 190
C
C  COMPUTE C' & KTHETA FOR TYPE 4 OPENING
C
  120 IF(EMBSS.GT.1.5) GO TO 130
      CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP4A,EM,ELOVRB)
      GO TO 140
  130 CALL GRIDPT(CPRIME,6,DEXM,8,DEXB,TYP4B,EM,ELOVRB)
  140 WWANGL=CVAR(8)
      IF(WWANGL.LE.30.) GO TO 190
      IF(WWANGL.GT.75.) WWANGL=75.
      DO 150 I=2,6
      MTHETA=I
      IF(DM1(I).GT.EM) GO TO 160
  150 CONTINUE
      MTHETA=6
  160 IF(EMBSS.GT.1.5) GO TO 170
      SLOPE2=THSL1(MTHETA)
      SLOPE1=THSL1(MTHETA-1)
      GO TO 180
  170 SLOPE2=THSL2(MTHETA)
      SLOPE1=THSL2(MTHETA-1)
  180 THTAK1=SLOPE1*(WWANGL-30.)+1.0
      THTAK2=SLOPE2*(WWANGL-30.)+1.0
      FACTRK(6)=THTAK1+(THTAK2-THTAK1)*(EM-DM1(MTHETA-1))/
     *               (DM1(MTHETA)-DM1(MTHETA-1))
      IF(FACTRK(6).LT.1.0) FACTRK(6)=1.0
C
C  COMPUTE KJ IF PIERS EXIST
C
  190 AJ=CVAR(5)
      IF(AJ.LE.0.0) GO TO 210
      IF(AJ.GT.0.2) AJ=0.2
      IPIER=CVAR(4)
      EMPIER=EM
      IF(EMPIER.LT.0.4) EMPIER=0.4
      IF(IPIER.GT.0) GO TO 200
      CALL GRIDPT(FACTRK(7),5,PIM,5,PIJ,AKJPER,EMPIER,AJ)
      GO TO 210
  200 CALL GRIDPT(FACTRK(7),5,PIM,5,PLOB,AKJPIL,EMPIER,ELOVRB)
      IF(AJ.GT.0.095.AND.AJ.LT.0.105) GO TO 210
      CALL GRIDPT(FACTRK(7),6,PLJC,4,PLKJC,AKJPEC,AJ,FACTRK(7))
C
C  COMPUTE KD & KA OR KB IF SPUR DIKES ARE PRESENT
C
  210 IF(CVAR(14).LE.0) GO TO 500
      IDIKE=CVAR(14)
      EMDIKE=EM
      IF(EMDIKE.LT.0.2) EMDIKE=0.2
      IF(EMDIKE.GT.0.8) EMDIKE=0.8
      IF(IDIKE.GT.2) GO TO 220
      DLOVRB=CVAR(12)/CVAR(3)
      IF(DLOVRB.GT.1.5) DLOVRB=1.5
      CALL GRIDPT(FACTRK(8),6,SDLDOB,4,SDM,AKD1,DLOVRB,EMDIKE)
      IF(IDIKE.NE.2) GO TO 500
      CALL GRIDPT(FACTRK(9),6,SDLDOB,4,SDM,AKA1,DLOVRB,EMDIKE)
      GO TO 500
  220 CALL GRIDPT(FACTRK(8),6,SDLDOB,4,SDM,AKD2,DLOVRB,EMDIKE)
      IF(IDIKE.NE.4) GO TO 500
      DLOBD=CVAR(12)/CVAR(13)
      IF(DLOBD.GT.2.8) DLOBD=2.8
      CALL GRIDPT(FACTRK(9),6,SDLDBD,4,SDM,AKB1,DLOBD,EMDIKE)
C
C  MULTIPLY CPRIME BY ALL OF THE ADJUSTMENT FACTORS
C
  500 WRITE(8,*) CPRIME
      C=CPRIME
      DO 510 I=1,9
      C=C*FACTRK(I)
  510 CONTINUE
      WRITE(8,*) C,FACTRK
      IF(C.GT.1.00) C=1.00
      WRITE(8,*) C,CVAR
      RETURN
      END
      SUBROUTINE GRIDPT(RESULT,NR,DEX1,NC,DEX2,VARRAY,VAR1,VAR2)
C
C***   LAST REVISED 02-13-84
C
      DIMENSION DEX1(NR),DEX2(NC),VARRAY(NR,NC)
      DATA SUBPGM/090909./
      WRITE(8,*) SUBPGM
      DO 20 IK=1,NR
      IF(DEX1(IK).GT.VAR1) GO TO 30
   20 CONTINUE
      IHI=NR
   30 IHI=IK
      ILO=IK-1
      IF(IHI.EQ.1) ILO=1
      IF(IHI.GT.NR) IHI=NR
      DO 40 JK=1,NC
      IF(DEX2(JK).GT.VAR2) GO TO 50
   40 CONTINUE
      JHI=NC
   50 JHI=JK
      JLO=JK-1
      IF(JHI.EQ.1) JLO=1
      IF(JHI.GT.NC) JHI=NC
      C1L=VARRAY(ILO,JLO)
      C1H=VARRAY(IHI,JLO)
      C2L=VARRAY(ILO,JHI)
      C2H=VARRAY(IHI,JHI)
C     WRITE(8,*) C1L,C1H,C2L,C2H
      DEXBD=DEX2(JHI)-DEX2(JLO)
      IF(DEXBD.EQ.0.0) DEXBD=10.
      C2=C1H+(C2H-C1H)*(VAR2-DEX2(JLO))/DEXBD
      C1=C1L+(C2L-C1L)*(VAR2-DEX2(JLO))/DEXBD
      IF(IHI.EQ.ILO) GO TO 200
      RESULT=C2+(C1-C2)*(DEX1(IHI)-VAR1)/(DEX1(IHI)-DEX1(ILO))
C     WRITE(8,*) RESULT
      GO TO 205
  200 RESULT=C2
C     WRITE(8,*) RESULT
  205 RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #8 OF PC VERSION +++++
      SUBROUTINE ENRGEQ(NDXA,AVECTR,NDXP,PVECTR,XSDATA)
C
C***   LAST REVISED 10-02-84
C
      REAL KT,KD,KU,K
      COMMON/IPTCB1/IPTXY,IPTRGH,IPTFL,IPTMSC,IPTPEA,IPTABG,IPTEND
      DIMENSION K(3),AVECTR(1),PVECTR(1),DVECTR(40),XSDATA(IPTEND)
      WS=AVECTR(NDXA)
      DVECTR(40)=PVECTR(40)
      DVECTR(15)=PVECTR(15)
      CALL XSPROP(WS,PVECTR(13),PVECTR(14),NDXP,PVECTR,XSDATA)
      IF(AVECTR(12).GT.0.0) GO TO 10
      IF(ABS(PVECTR(40)-2.).GT.0.5) GO TO 10
      NPA=XSDATA(5)
      IF(NPA.LE.0) GO TO 10
      APR=PIERAF(WS,NPA,XSDATA(IPTPEA+1))
      ANET=PVECTR(6)-APR
      PVECTR(5)=PVECTR(5)*ANET/PVECTR(6)
      PVECTR(6)=ANET
   10 CALL HYDEQS(NDXA,AVECTR,NDXP,PVECTR)
      KD=PVECTR(5)
      KU=PVECTR(1)
      QD=AVECTR(7)
      QU=AVECTR(3)
      IHF=XSDATA(IPTMSC+2)
      IF(IHF.LE.0.OR.IHF.GT.3) GO TO 50
      IF(IHF.GT.1) GO TO 30
C   USE ARITHMETIC AVERAGE CONVEYANCE
      SF=((QD+QU)/(KD+KU))**2
      GO TO 60
   30 SFD=(QD/KD)**2
      SFU=(QU/KU)**2
      IF(IHF.EQ.3) GO TO 40
C   USE ARITHMETIC AVERAGE FRICTION SLOPE
      SF=0.5*(SFD+SFU)
      GO TO 60
C   USE HARMONIC MEAN FRICTION SLOPE
   40 SF=2*SFD*SFU/(SFD+SFU)
      GO TO 60
C   USE GEOMETRIC MEAN CONVEYANCE
   50 SF=(0.5*(QD+QU))**2/(KD*KU)
   60 HFLGTH=ABS(AVECTR(12))
      NFL=XSDATA(4)
      IF(NFL.EQ.0) GO TO 70
      IF(NFL.GT.1) GO TO 61
      HFLGTH=XSDATA(IPTFL+1)
      GO TO 70
   61 KT=0.0
      XLT=-1.0E30
      DO 62 I=1,NFL
      XRT=XSDATA(IPTFL+2*I)
      CALL XSPROP(WS,XLT,XRT,1,DVECTR,XSDATA)
      K(I)=DVECTR(1)
      KT=KT+K(I)
      XLT=XRT
   62 CONTINUE
      HFLGTH=0.0
      DO 64 I=1,NFL
      HFLGTH=HFLGTH+XSDATA(IPTFL+2*I-1)*K(I)/KT
   64 CONTINUE
   70 HF=HFLGTH*SF
      HE=0.0
      EK=XSDATA(IPTMSC+3)
      CK=XSDATA(IPTMSC+4)
      VHD=AVECTR(6)
      VHU=AVECTR(2)
      IF(EK.LE.0.0.AND.CK.LE.0.0) GO TO 90
      IF(VHU.LE.VHD) GO TO 80
C   EXPANDING SUBREACH
      HE=EK*(VHU-VHD)
      GO TO 90
C   CONTRACTING SUBREACH
   80 HE=CK*(VHD-VHU)
   90 WSD=AVECTR(5)
      WSU=AVECTR(1)
      AVECTR(10)=WSU+VHU-HF-HE-WSD-VHD
      AVECTR(13)=HF
      AVECTR(14)=HE
      AVECTR(11)=HFLGTH
      RETURN
      END
      SUBROUTINE HYDEQS(NDXA,AVECTR,NDXP,PVECTR)
C
C***   LAST REVISED 12-13-83
C
      DIMENSION AVECTR(1),PVECTR(1)
C
C  THIS SUBROUTINE CALCULATES VELOCITY, VELOCITY HEAD, ENERGY GRADIENT,
C  AND FROUDE NO. FOR ANY CROSS SECTION USING VALUES TRANSFERRED IN VIA
C  THE ANSWER AND PROPERTY VECTORS (AVECTR & PVECTR).  RESULTS ARE
C  PLACED IN THE ANSWER VECTOR.  NDXA & NDXP INDICATE IF IT IS AN UPST
C  OR DNST X-SECTION.
C
      Q=AVECTR(NDXA+2)
      WS=AVECTR(NDXA)
      A=PVECTR(NDXP+1)
      ALPHA=PVECTR(NDXP+2)
      TOPW=PVECTR(17)
      XSTYPE=PVECTR(40)
      IF(ABS(XSTYPE-2.).GT.0.5) GO TO 5
      XMIN=PVECTR(11)
      YMIN=PVECTR(12)
      XMAX=PVECTR(9)
      YMAX=PVECTR(10)
      IF(WS.GT.(YMIN+0.8*(YMAX-YMIN)).AND.TOPW.LT.(0.75*(XMAX-XMIN)))
     *     TOPW=XMAX-XMIN
    5 V=Q/A
      VH=V**2*ALPHA/64.3
      EG=WS+VH
      FRDN=V*SQRT(ALPHA*TOPW/(32.17*A))
      AVECTR(NDXA+1)=VH
      AVECTR(15)=V
      AVECTR(9)=EG
      AVECTR(16)=FRDN
      RETURN
      END
C                                     <<<<<SUBPROGRAM CRITWS>>>>>
C     <<<<<LAST REVISED 12-31-86>>>>>
C
      SUBROUTINE   CRITWS ( Q, WSC, NDXP, PVECTR, XSDATA, YTOL )
C
C***   LAST REVISED 12-13-83
C
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C  JOS.MOD 12/86 - COSMETIC - JHPARM PARAMETER CONSISTENCY
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
C
      COMMON/IPTCB1/JUNK(4),IPTPEA,JDUM,IPTEND
      DIMENSION PVECTR(1),XSDATA(IPTEND)
C
C***  INITIALIZE VARIABLES
C
      XMIN=PVECTR(11)
      YMIN=PVECTR(12)
      XMAX=PVECTR(9)
      YMAX=PVECTR(10)
      WSB4 = 1E30
      WSMIN=YMIN+0.2
C
C***  WATER SURFACE INCREMENT IS 5% OF THE RANGE OF YMAX-YMIN
C
      WSINC=(YMAX-WSMIN)/20.0
C
C***  SET UP SCHEME TO ITERATE A MAXIMUM OF 5 TIMES TO FIND CRITICAL
C***  WATER SURFACE ELEVATION
C
      DO 60 I=1,5
      EMIN=1.0E30
      EB4=1.0E30
      WS=WSMIN
      DO 40 J=1,21
      CALL XSPROP(WS,XMIN,XMAX,NDXP,PVECTR,XSDATA)
      IF(ABS(PVECTR(40)-2.).GT.0.5) GO TO 10
      NPA=XSDATA(5)
      IF(NPA.LE.0) GO TO 10
      APR=PIERAF(WS,NPA,XSDATA(IPTPEA+1))
      A=PVECTR(NDXP+1)
      PVECTR(NDXP+1)=A-APR
      PVECTR(NDXP)=PVECTR(NDXP)*PVECTR(NDXP+1)/A
C
C***  COMPUTE ENERGY
C
   10 V=Q/PVECTR(NDXP+1)
      E=WS+PVECTR(NDXP+2)*V**2/64.3
C
C***  CHECK TO SEE IF ENERGY DECREASED
C
      IF(E.GT.EMIN) GO TO 20
C
C***  INCREMENT WATER SURFACE AND SAVE MIN.
C
      EMIN=E
      JMIN=J
      WSS=WS
   20 IF(ABS(WS-YMAX).LT.YTOL) GO TO 50
      WS=WS+WSINC
      IF(WS.GT.YMAX) WS=YMAX
      IF(WS.LE.WSB4) GO TO 30
      IF(E.LE.EB4) GO TO 30
      IF(J.GE.JMIN+5) GO TO 50
   30 EB4=E
   40 CONTINUE
C
C***  CHECK TO SEE IF CALCULATION IS WITHIN TOLERANCE, IF NOT
C***  COMPUTE NEW MINIMUM WATER SURFACE, BUT QUIT IF WSINC < YTOL
C
   50 WSC=WSS
      IF(ABS(WSS-WSB4).LE.YTOL) GO TO 70
      IF(WSINC.LT.YTOL) GO TO 70
      WSMIN=WSS-2.0*(WSINC+YTOL)
      IF(WSMIN.LT.YMIN) WSMIN=YMIN+0.2
      WSINC=0.2*WSINC
      IF(WSINC.LE.YTOL) WSINC=YTOL-0.00001
      WSB4=WSS
   60 CONTINUE
   70 RETURN
      END
C                                     <<<<<SUBPROGRAM QOVRRD>>>>>
C     <<<<<LAST REVISED 04-05-86>>>>>
C
      SUBROUTINE   QOVRRD (ISIDE, WSRD, WSD, XLT, XRT,
     *                                    ANSVEC, XSPVEC, RGDATA)
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      DIMENSION   RGDATA(IPTEND), XSPVEC(40), ANSVEC(40),
     $            HLHTH(36), COEF(36), LIMIT(3,2,2), LIST1L(6),
     $            LIST2L(6), LIST1R(6), LIST2R(6)
C
      DATA HLHTH / 0.15, 0.215, 0.28, 0.15, 0.27, 0.31, 0.0,
     $ 0.15, 0.25, 0.50, 0.90, 4.0, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5,
     $ 3.0, 4.0, 0.80, 0.84, 0.88, 0.90, 0.92, 0.94, 0.96, 1.00,
     $ 0.70, 0.80, 0.86, 0.90, 0.92, 0.94, 0.96, 1.00 /
C
      DATA COEF / 3.05, 3.08, 3.09, 2.95, 3.07, 3.09, 2.85, 2.95,
     $ 2.98, 3.02, 3.035, 3.05, 2.50, 2.68, 2.83, 2.92, 2.98,
     $ 3.02, 3.04, 3.05, 1.0, 0.988, 0.956, 0.929, 0.89, 0.82,
     $ 0.72, 0.36, 1.0, 0.988, 0.94, 0.88, 0.82, 0.73, 0.62, 0.2/
C
      DATA   LIST1L / 5, 19, 21, 23, 25, 27 /,
     $       LIST2L / 5, 29, 31, 33, 35, 37 /,
     $       LIST1R / 5, 20, 22, 24, 26, 28 /,
     $       LIST2R / 5, 30, 32, 34, 36, 38 /,
     $       LIMIT / 1, 7, 21, 2, 11, 27, 4, 13, 29, 5, 19, 35 /,
     $       SUBPGM / 171717. /
C
      WRITE(8,*) SUBPGM
C
      DMAX=0.
      SUMB=0.
      SUMDB=0.
      SUMQ=0.0
      SUMHB=0.0
      SUMTB=0.0
      NGP=RGDATA(1)
      CSKEW=COS(XSPVEC(15)/57.29578)
      UZRCF=RGDATA(IPTMSC+8)
      IPVTYP=ANSVEC(15)
      I=1
      XYINT=1.0E30
      XYREW=-1.0E30
      XYLEW=1.0E30
   10 XRD1=RGDATA(IPTXY+2*I-1)
      YRD1=RGDATA(IPTXY+2*I)
      XRD2=RGDATA(IPTXY+2*I+1)
      YRD2=RGDATA(IPTXY+2*I+2)
      IF(XRD1.GE.XLT) GO TO 40
      IF(XRD2.GT.XLT) GO TO 20
      I=I+1
      IF((I+1).GT.NGP) GO TO 160
      GO TO 10
   20 YRD1=YRD2+(YRD1-YRD2)*(XRD2-XLT)/(XRD2-XRD1)
      XRD1=XLT
      IF((WSRD-YRD1).GT.DMAX) DMAX=WSRD-YRD1
   40 IF(XRD2.LE.XRT) GO TO 50
      YRD2=YRD1+(YRD2-YRD1)*(XRT-XRD1)/(XRD2-XRD1)
      XRD2=XRT
   50 IF (WSRD.LE.YRD1.AND.WSRD.LE.YRD2) GO TO 150
      IF (WSRD.LT.YRD1.OR.WSRD.LT.YRD2) GO TO 60
      BASE=XRD2-XRD1
      XYINT=XRD2
      IF (XYLEW.GT.XYREW) XYLEW=XRD1
      IF (I.EQ.1.AND.WSRD.GE.YRD1) XYLEW=XRD1
      AVGY=0.5*(YRD1+YRD2)
      GO TO 80
   60 IF (WSRD.GE.YRD1.OR.WSRD.LE.YRD2) GO TO 70
      AVGY=0.5*(WSRD+YRD2)
      BASE=(WSRD-YRD2)*(XRD2-XRD1)/(YRD1-YRD2)
      XYINT=XRD2-BASE
      IF(I.EQ.(NGP-1)) XYREW=XRD2
      GO TO 80
   70 AVGY=0.5*(YRD1+WSRD)
      BASE=(WSRD-YRD1)*(XRD2-XRD1)/(YRD2-YRD1)
      XYINT=XRD1+BASE
      IF(I.EQ.1) XYLEW=XRD1
      IF((WSRD-YRD1).GT.DMAX) DMAX=WSRD-YRD1
   80 B=BASE*CSKEW
      H=ANSVEC(9)-AVGY
      IF(H.LE.0.0) GO TO 150
      HS=H-ANSVEC(2)
      IF(HS.LE.0.0) GO TO 150
      D=WSRD-AVGY
      IF(D.LT.0.0) D=0.0
      IF(D.LE.0.0) GO TO 150
      T=WSD-AVGY
      IF(T.LT.0.0) T=0.0
      TOVRH=T/H
      IF (IPVTYP.EQ.1.AND.TOVRH.GT.0.8) GO TO 90
      IF (IPVTYP.EQ.2.AND.TOVRH.GT.0.7) GO TO 90
      SUBKT=1.00
      GO TO 100
   90 SUBKT=TERPL8(TOVRH,LIMIT(3,1,IPVTYP),LIMIT(3,2,IPVTYP),HLHTH,COEF)
  100 CF=UZRCF
      IF(CF.GT.0.0) GO TO 140
      HOVRL=H/RGDATA(IPTMSC+7)
      IF (HOVRL.GT.0.15) GO TO 120
      IF(HS.LT.4.0) GO TO 110
      CF=3.05
      GO TO 140
  110 CF=TERPL8(H,LIMIT(2,1,IPVTYP),LIMIT(2,2,IPVTYP),HLHTH,COEF)
      GO TO 140
  120 HOVRL=HS/RGDATA(IPTMSC+7)
      IF(HOVRL.LT.0.32) GO TO 130
      CF=3.09
      GO TO 140
  130 CF=TERPL8(HOVRL,LIMIT(1,1,IPVTYP),LIMIT(1,2,IPVTYP),HLHTH,COEF)
  140 C=CF*SUBKT
      Q=C*B*H**1.5
      SUMQ=SUMQ+Q
      SUMB=SUMB+B
      SUMDB=SUMDB+D*B
      SUMHB=SUMHB+H*B
      SUMTB=SUMTB+T*B
      IF((WSRD-YRD1).GT.DMAX) DMAX=WSRD-YRD1
      IF((WSRD-YRD2).GT.DMAX) DMAX=WSRD-YRD2
      IF (XYINT.GT.1.0E25) GO TO 150
      IF (XYINT.LE.XYLEW) XYLEW=XYINT
      IF (XYINT.GE.XYREW) XYREW=XYINT
      IF(XRD1.EQ.XLT.AND.WSRD.GT.YRD1) XYLEW=XLT
      IF(XRD2.EQ.XRT.AND.WSRD.GT.YRD2) XYREW=XRT
  150 XRD1=XRD2
      YRD1=YRD2
      I=I+1
      IF((I+1).GT.NGP) GO TO 160
      XRD2=RGDATA(IPTXY+2*I+1)
      YRD2=RGDATA(IPTXY+2*I+2)
      IF(XRD1.GE.XRT.AND.XRD2.GE.XRT) GO TO 160
      GO TO 40
  160 IF(SUMQ.LE.0.0) GO TO 180
      DAVG=SUMDB/SUMB
      VAVG=SUMQ/SUMDB
      VCRIT=1.5*SUMQ/SUMHB
      HAVG=SUMHB/SUMB
      CAVG=SUMQ/(SUMB*HAVG**1.5)
      IF(ISIDE.EQ.2) GO TO 170
      CALL STORIT(XSPVEC(1),LIST1L,SUMQ,SUMB,XYLEW,XYREW,DMAX)
      CALL STORIT(XSPVEC(1),LIST2L,CAVG,HAVG,DAVG,VCRIT,VAVG)
      GO TO 200
  170 CALL STORIT(XSPVEC(1),LIST1R,SUMQ,SUMB,XYLEW,XYREW,DMAX)
      CALL STORIT(XSPVEC(1),LIST2R,CAVG,HAVG,DAVG,VCRIT,VAVG)
      GO TO 200
  180 XSPVEC(ISIDE)=0.0
      XSPVEC(ISIDE+18)=0.0
  200 RETURN
      END
C                                     <<<<<SUBPROGRAM STDPRT>>>>>
C     <<<<<LAST REVISED 04-05-86>>>>>
C
      SUBROUTINE   STDPRT(SECID, IGO, LINES, OUTVEC)
C
C          PRINTS STANDARD PROFILE RESULTS TABLE
C
      CHARACTER*5 SECID
      CHARACTER*4 HDG1,HDG1A,HDG2A,HDG4,HDG4A,HDG5A,BLANK,FLAG
      CHARACTER*4 CODE,XSCODE,ERRFLG
C
      DIMENSION OUTVEC(58),HDG1(11),HDG1A(9),HDG2A(9),HDG4(10),
     *          HDG4A(10),HDG5A(6),VLST1(9),VLST1A(9),VLST2A(9),
     *          VLST4(8),VLST4A(10),VLST5A(6),LSTV1(10),
     *          LSTV1A(10),LSTV2A(10),LSTV4(9),LSTV4L(11),
     *          LSTV4R(11),LSTV5A(7),CODE(6),FLAG(3),
     *          FMTW1(9),FMTW1A(9),FMTW2A(9),FMTW5A(6),
     *          FMTW4(8),FMTW4A(10)
      DATA   HDG1 /'XSID','CODE','SRDL',' LEW','AREA',' VHD',
     *      '  HF',' EGL','CRWS','   Q','WSEL'/,
     *      HDG1A /' SRD','FLEN',' REW','   K','ALPH','  HO',
     *      ' ERR',' FR#',' VEL'/,      HDG2A /'TYPE','PPCD',
     *      'FLOW','   C',' P/A','LSEL','BLEN','XLAB','XRAB'/,
     *       HDG4 /'XSID','CODE',' SRD','FLEN','  HF',' VHD',
     *      ' EGL',' ERR','   Q','WSEL'/,      HDG4A /'   Q',
     *      'WLEN',' LEW',' REW','DMAX','DAVG','VMAX','VAVG',
     *      'HAVG','CAVG'/,
     *      HDG5A /'M(G)','M(K)','  KQ','XLKQ','XRKQ','OTEL'/,
     *       CODE /':XS ',':FV ',':BR ',':SD ',':RG ',':AS '/
      DATA  LSTV1  / 9,10,29,17, 4,11, 7,15, 5, 3/,
     *      LSTV1A / 9, 6, 9,30,16,18,12, 8,14,13/,
     *      LSTV2A / 9,55,57,54,56,58,53,50,51,52/,
     *      LSTV4  / 8, 6, 9,11, 4, 7, 8, 5, 3/,
     *      LSTV4L / 10,30,32,34,36,38,44,46,48,42,40/,
     *      LSTV4R / 10,31,33,35,37,39,45,47,49,43,41/,
     *      LSTV5A / 6,54,50,51,52,53,55/, LASTGO/0/, MSG/6/
      DATA  FMTW1  / 2*7.0,9.0,2*6.2,2*8.2,8.0,8.2/,
     *      FMTW1A / 3*7.0,9.0,2*6.2,3*8.2/,
     *      FMTW2A / 3*5.0,2*7.3,8.2,3*7.0/,
     *      FMTW4  / 2*7.0,2*6.2,2*8.2,8.0,8.2/,
     *      FMTW4A / 8.0,3*7.0,6*6.1/,
     *      FMTW5A /2*7.3,9.0,2*7.0,8.2/
      DATA BLANK /'    '/,FLAG /'   #','  ##',' ###'/
C
      XSCODE=CODE(IGO)
      ERRFLG=BLANK
      IF(OUTVEC(2).LE.0.0) GO TO 15
      IF(ABS(OUTVEC(2)).GT.3.) GO TO 15
      IFLAG=INT(OUTVEC(2)+0.001)
      ERRFLG=FLAG(IFLAG)
      IF(LINES.GT.0)GO TO 15
   10 CALL HDGPRT (MSG)
      LINES=LINES+8
   15 IF(IGO.EQ.5) GO TO 70
      CALL FILLVL ( LSTV1 , OUTVEC, VLST1 )
      CALL FILLVL ( LSTV1A, OUTVEC, VLST1A )
      GO TO (30,30,40,50,70,20),IGO
   20 IF(LASTGO.NE.2) GO TO 60
   30 IF(LASTGO.EQ.6) GO TO 32
      IF(LINES.GT.8) GO TO 35
   32 IF(LINES+6.GT.60) LINES=0
      IF(LINES.EQ.0) GO TO 10
      LINES=LINES+3
      WRITE(MSG,602) HDG1
      WRITE(MSG,603) HDG1A
   35 IF(LINES+3.GT.60) LINES=0
      IF(LINES.EQ.0) GO TO 10
      LINES=LINES+3
      WRITE(MSG,604) SECID,XSCODE,VLST1
      WRITE(MSG,605) ERRFLG,VLST1A
      IF(IGO.NE.2.AND.IGO.NE.6) GO TO 80
      WRITE(MSG,701)
      LINES=LINES+1
      GO TO 80
   40 IF(LINES+11.GT.60) LINES=0
      IF(LINES.EQ.0) GO TO 10
      LINES=LINES+11
      CALL FILLVL ( LSTV2A, OUTVEC, VLST2A )
      WRITE(MSG,702)
      WRITE(MSG,602) HDG1
      WRITE(MSG,603) HDG1A
      WRITE(MSG,604) SECID,XSCODE,VLST1
      WRITE(MSG,605) ERRFLG,VLST1A
      WRITE(MSG,606) HDG2A
      WRITE(MSG,607) VLST2A
      GO TO 80
   50 IF(LINES+6.GT.60) LINES=0
      IF(LINES.EQ.0) GO TO 10
      LINES=LINES+6
      WRITE(MSG,602) HDG1
      WRITE(MSG,603) HDG1A
      WRITE(MSG,604) SECID,XSCODE,VLST1
      WRITE(MSG,605) ERRFLG,VLST1A
      GO TO 80
   60 IF(LINES+11.GT.60) LINES=0
      IF(LINES.EQ.0) GO TO 10
      LINES=LINES+11
      CALL FILLVL ( LSTV5A, OUTVEC, VLST5A )
      WRITE(MSG,602) HDG1
      WRITE(MSG,603) HDG1A
      WRITE(MSG,604) SECID,XSCODE,VLST1
      WRITE(MSG,605) ERRFLG,VLST1A
      WRITE(MSG,608) HDG5A
      WRITE(MSG,609) VLST5A
      WRITE(MSG,703)
      GO TO 80
   70 IF(LINES+7.GT.60) LINES=0
      IF(LINES.EQ.0) GO TO 10
      LINES=LINES+7
      CALL FILLVL ( LSTV4, OUTVEC, VLST4 )
      WRITE(MSG,610) HDG4
      IF(VLST4(7).GT.0.0) GO TO 75
      WRITE(MSG,704) ERRFLG,SECID,XSCODE,VLST4(1)
      LINES=LINES-4
      GO TO 80
   75 WRITE(MSG,611) ERRFLG,SECID,XSCODE,VLST4
      CALL FILLVL ( LSTV4L, OUTVEC, VLST4A )
      WRITE(MSG,612) HDG4A
      WRITE(MSG,613) VLST4A
      CALL FILLVL ( LSTV4R, OUTVEC, VLST4A )
      WRITE(MSG,614) VLST4A
   80 LASTGO=IGO
      RETURN
  601 FORMAT(1H1,3(1X,70A1/))
  602 FORMAT(/1H ,A5,':',A4,2A7,A9,2A6,4A8)
  603 FORMAT(4X,3A7,A9,2A6,3A8)
  604 FORMAT(/1H ,A5,A4,1X,2(1X,F6.0),1X,F8.0,2(1X,F5.2),
     $                                2(1X,F7.2),1X,F7.0,1X,F7.2)
  605 FORMAT(A4,3(1X,F6.0),1X,F8.0,2(1X,F5.2),3(1X,F7.2))
  606 FORMAT(/5X,3A5,2A7,A8,3A7)
  607 FORMAT(5X,3(1X,F4.0),2(1X,F6.3),1X,F7.2,3(1X,F6.0))
  608 FORMAT(/5X,2A7,A9,2A7,A8)
  609 FORMAT(5X,2(1X,F6.3),1X,F8.0,2(1X,F6.0),1X,F8.2)
  610 FORMAT(/4X,A5,':',A4,2A7,2A6,4A8)
  611 FORMAT(A4,A5,A4,1X,2(1X,F6.0),2(1X,F5.2),2(1X,F7.2),
     $                                           1X,F7.0,1X,F7.2)
  612 FORMAT(/7X,A8,3A7,6A6)
  613 FORMAT(4X,'LT:',1X,F7.0,3(1X,F6.0),6(1X,F5.1))
  614 FORMAT(4X,'RT:',1X,F7.0,3(1X,F6.0),6(1X,F5.1))
  701 FORMAT(10X,'<<<<<THE ABOVE RESULTS REFLECT "NORMAL"',
     $                              ' (UNCONSTRICTED) FLOW>>>>>')
  702 FORMAT(/12X,' <<<<<RESULTS REFLECTING THE CONSTRICTED',
     $                                       ' FLOW FOLLOW>>>>>')
  703 FORMAT(/20X,'  <<<<<END OF BRIDGE COMPUTATIONS>>>>>')
  704 FORMAT(A4,A5,A4,1X,F7.0,8X,'<<<<<EMBANKMENT IS ',
     $                                     'NOT OVERTOPPED>>>>>')
      END
      SUBROUTINE STORIT(OUTVEC,LIST,VAR1,VAR2,VAR3,VAR4,VAR5)
      DIMENSION OUTVEC(1),LIST(6),VAR(5)
      VAR(1)=VAR1
      VAR(2)=VAR2
      VAR(3)=VAR3
      VAR(4)=VAR4
      VAR(5)=VAR5
      NVAR=LIST(1)
      DO 10 I=1,NVAR
      IOUT=LIST(I+1)
      OUTVEC(IOUT)=VAR(I)
   10 CONTINUE
      RETURN
      END
C                                     <<<<<SUBPROGRAM SLPCON>>>>>
C     <<<<<LAST REVISED 01-03-86>>>>>
C
      SUBROUTINE   SLPCON (Q, SKSL, WSTRY, NDXP, PVECTR, XSDATA )
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      DIMENSION PVECTR(40), XSDATA(IPTEND)
      DATA MSG / 6 /
C
      ITER = 0
      WSMAX = PVECTR(10) - 0.02
      CALL XSPROP ( WSMAX, PVECTR(11), PVECTR(9),
     $                                    NDXP, PVECTR, XSDATA )
      QMAX =  PVECTR(NDXP) * SKSL**0.5
      WSMIN = PVECTR(12) + 0.25
      CALL XSPROP ( WSMIN, PVECTR(11), PVECTR(9),
     $                                    NDXP, PVECTR, XSDATA )
      QMIN =  PVECTR(NDXP) * SKSL**0.5
      IF( QMIN .GT. Q ) GO TO 50
      IF( QMAX .LT. Q ) GO TO 50
      QERRMX = QMAX/Q - 1.0
      QERRMN = QMIN/Q - 1.0
      IF( WSTRY.GT.WSMAX ) GO TO 10
      IF( WSTRY.GT.WSMIN ) GO TO 20
   10 WSTRY = ( WSMAX + WSMIN ) / 2.0
   20 CALL XSPROP ( WSTRY, PVECTR(11), PVECTR(9),
     $                                    NDXP, PVECTR, XSDATA )
      ITER = ITER + 1
      QTRY = PVECTR(NDXP) * SKSL**0.5
      QERR = QTRY/Q - 1.0
      IF( ABS ( QERR ) .LT. 0.001 ) RETURN
      IF( ITER .GE. 20 ) GO TO 70
      IF( QERR.GT.0.0 ) GO TO 30
      WSMIN = WSTRY
      QERRMN = QERR
      GO TO 40
   30 WSMAX = WSTRY
      QERRMX = QERR
   40 IF( ABS ( QERR ) .GT. 0.5 ) GO TO 10
      WSTRY = WSMAX - ( QERRMX / (QERRMX - QERRMN) )
     $                                       * ( WSMAX - WSMIN )
      GO TO 20
C
C**********ERROR MESSAGE
   50 WRITE(MSG,60) WSMIN, QMIN, WSMAX, QMAX
   60 FORMAT(/'  ===025 SLOPE-CONVEYANCE DISCHARGE OUT OF ',
     $  'RANGE.'/13X,'WSMIN,QMIN,WSMAX,QMAX = ',2(F8.2,3X,F8.0))
C
      WSTRY = PVECTR(12) - 100.0
      RETURN
C
C**********ERROR MESSAGE
   70 WRITE(MSG,80) QTRY, WSTRY
   80 FORMAT(/'  ===020 SLOPE-CONVEYANCE CONVERGENCE FAILURE:',
     $           '  USED FINAL TRIAL WS.'/30X,
     $                             'QCOMP,CRWS = ',F8.0,3X,F8.2)
C
      RETURN
      END
      FUNCTION TERPL8(YO,I1,I2,Y,Z)
C
C*** LAST REVISED 11/09/82
C
      DIMENSION Y(1),Z(1)
      IF(YO.GT.Y(I1)) GO TO 10
      I=I1
      GO TO 30
   10 DO 20 I=I1,I2
      IF(YO.GE.Y(I).AND.YO.LT.Y(I+1)) GO TO 30
   20 CONTINUE
      I=I2
   30 TERPL8=Z(I)+(YO-Y(I))*(Z(I+1)-Z(I))/(Y(I+1)-Y(I))
      RETURN
      END
C                                     <<<<<SUBPROGRAM CNTRDK>>>>>
C     <<<<<LAST REVISED 04-07-86>>>>>
C
      SUBROUTINE   CNTRDK ( XCNTR, WS, XLBNK, XRBNK, TOTALK,
     $                                            XSTYPE, XSDATA )
C
C          THIS SUBROUTINE DETERMINES THE HORIZONTAL CENTER OF
C          CONVEYANCE IN A CROSS SECTION FOR A SPECIFIED WS
C          ELEVATION.  IT FINDS THE CENTER FROM BOTH LEFT AND
C          RIGHT AND USES THE AVERAGE OF THE TWO VALUES.
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
C
      DIMENSION  XSDATA(IPTEND), DVECTR(40)
      DATA SUBPGM / 020202. /
C
C**********DEBUG OUTPUT**********
           WRITE(8,*) SUBPGM
C
      DVECTR(40) = XSTYPE
      DVECTR(15) = XSDATA(IPTMSC+1)
      HALFK = 0.5 * TOTALK
C
C          IPASS = 1 AND XLT REMAINS FIXED FOR LT TO RT PASS
C          IPASS = 2 AND XRT REMAINS FIXED FOR RT TO LT PASS
C
      IPASS = 1
C**********DEBUG OUTPUT**********
C     WRITE(8,*) HALFK, TOTALK
C
      XLT = XLBNK
      XRT = 0.5 * ( XLBNK + XRBNK )
   10 XLOW = XLBNK
      XHI = XRBNK
C
      DO 70 I=1,15
      CALL XSPROP ( WS, XLT, XRT, 1, DVECTR, XSDATA )
C**********DEBUG OUTPUT**********
C     WRITE(8,*) I, DVECTR(1), DVECTR(16), XLT, XRT
C
      ERR = ( DVECTR(1) / HALFK ) - 1.0
C
C        CHANGED TOLERANCE FROM 0.005 TO 0.001 FOR VEL. DIST.
C
      IF( ABS ( ERR ) .LT. 0.001 ) GO TO 80
      IF( IPASS .EQ. 2 ) GO TO 40
      IF( ERR .GT. 0.0 ) GO TO 20
      XLOW = XRT
      GO TO 30
   20 XHI = XRT
   30 XRT = 0.5 * ( XLOW + XHI )
      GO TO 70
   40 IF( ERR .GT. 0.0 ) GO TO 50
      XHI = XLT
      GO TO 60
   50 XLOW = XLT
   60 XLT = 0.5 * ( XLOW + XHI )
   70 CONTINUE
   80 IF( IPASS .EQ. 2 ) GO TO 90
      XCNTR = 0.5 * XRT
C**********DEBUG OUTPUT**********
C     WRITE(8,*) XCNTR, XRT
C
      IPASS = 2
      XRT = XRBNK
      XLT = 0.5 *( XLBNK + XRBNK )
      GO TO 10
   90 XCNTR = XCNTR + 0.5 * XLT
C**********DEBUG OUTPUT**********
C     WRITE(8,*) XCNTR, XLT
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM PARTK >>>>>
C     <<<<<LAST REVISED 04-07-86>>>>>
C
      SUBROUTINE   PARTK ( WS, XK, TOTALK, XSTYPE, XSDATA )
C
C          THIS SUBROUTINE DETERMINES THE STATIONING OF THE
C          "EQUAL-CONVEYANCE" STREAM TUBES IN THE BRIDGE OPENING
C          AND APPROACH X-SECS.
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      DIMENSION DVECTR(40), XK(21), XSDATA(IPTEND)
      DATA SUBPGM / 141414. /
C
C**********DEBUG OUTPUT**********
      WRITE(8,*) SUBPGM
C
      DVECTR(40)=XSTYPE
      DVECTR(15)=XSDATA(IPTMSC+1)
      IPASS=1
      XLT=0.5*(XK(1)+XK(11))
      XRT=XK(21)
      XANS=XLT
      GO TO 20
   10 IPASS=2
      XLT=XK(1)
      XRT=0.5*(XK(11)+XK(21))
      XANS=XRT
   20 JP=10*(IPASS-1)
      XLOW=XK(1+JP)
      XHI=XK(11+JP)
      DO 100 I=1,9
      IK=I+1+((10-I)*(2*JP/10))
      TARGET=TOTALK*(1.0-0.05*I)
      DO 80 J=1,15
      CALL XSPROP(WS,XLT,XRT,1,DVECTR,XSDATA)
C
C**********DEBUG OUTPUT**********
C     WRITE(8,*) IK, J, DVECTR(1), DVECTR(16), DVECTR(18),
C    $                                                 DVECTR(19)
C
      ERR=(DVECTR(1)/TARGET)-1.0
C
C        CHANGED TOLERANCE FROM 0.005 TO 0.001 FOR VEL. DIST.
C
      IF(ABS(ERR).LE.0.001) GO TO 90
      IF(IPASS.EQ.2) GO TO 50
      IF(ERR.GT.0.0) GO TO 30
      XHI=XLT
      GO TO 40
   30 XLOW=XLT
   40 XLT=0.5*(XLOW+XHI)
      XANS=XLT
      GO TO 80
   50 IF(ERR.GT.0.0) GO TO 60
      XLOW=XRT
      GO TO 70
   60 XHI=XRT
   70 XRT=0.5*(XLOW+XHI)
      XANS=XRT
   80 CONTINUE
   90 XK(IK)=XANS
      XLOW=AMIN1(XANS,XK(11))
      XHI=AMAX1(XANS,XK(11))
      X=0.5*(XLOW+XHI)
      IF(IPASS.EQ.1) XLT=X
      IF(IPASS.EQ.2) XRT=X
      XANS=X
  100 CONTINUE
      IF(IPASS.EQ.1) GO TO 10
      RETURN
      END
C                                     <<<<<SUBPROGRAM GETLAV>>>>>
C     <<<<<LAST REVISED 01-02-86>>>>>
C
      SUBROUTINE   GETLAV ( XBR, XAS, BDIST, FL1TO2, SKEWBR,
     $                                   SKEWAS, XREFBR, XBPAS )
C
      DIMENSION  XBR(21), XAS(21), FLDIST(21), XDIST(21),
     $               YDIST(21), XBRADJ(21), XASADJ(21), XBPAS(4)
      DATA SUBPGM / 080808. /
      SUMFL = 0.
      WRITE(8,*) SUBPGM
      PI = 3.141593
      IPASS = 1
   10 JP = 10 * ( IPASS - 1 )
      BLC = XBR(11+JP) - XBR(1+JP)
      BCAP = XAS(11+JP) - XAS(1+JP)
      EMPRIM = 1.0 - ( BLC / BCAP )
      IF( EMPRIM .GT. 0.0 ) GO TO 12
      FLDIST(1+JP) = BDIST
      FLDIST(11+JP) = BDIST
      SUMFL = SUMFL + 11 * BDIST
      GO TO ( 65, 70 ), IPASS
C
C          COMPUTE "OPTIMUM" APPROACH X-SEC LOCATION USING
C          EQUATIOINS 18, 19 & 20 FROM WRI 76-129
C
   12 DELTA = PI * ( 1.0 - 0.5 * BLC/BCAP )
      DELTA = ( TAN(DELTA) )**2
      DELTA = 2.0 / DELTA
      EPSLN = 1.0 + DELTA + SQRT( DELTA**2 + 2. * DELTA )
      BRKT1 = SQRT( 8.0 + 8.0/EPSLN**2 )- 3./EPSLN - EPSLN
      BRKT2=SQRT( 8.0 + 8.0 * EPSLN**2 ) *
     $                              (-1.0) - 3.*EPSLN - 1./EPSLN
      BRKT3 = 0.5 * ALOG( BRKT1 * BRKT2 ) -
     $                               ALOG( EPSLN -( 1./EPSLN ) )
      OPTLW = 2.0 * BRKT3 * BLC/( PI * ( 1. - EMPRIM ) )
      COSBR = COS( SKEWBR/57.29578 )
      COSAS = COS ( SKEWAS/57.29578 )
      YADJ = ( XBPAS(4) - XBPAS(3) )/( XBPAS(2) - XBPAS(1) )
      IF( XBPAS(3) .LE. 0.  .OR.  XBPAS(4) .LE. 0. ) YADJ = 0.0
      DO 15 I=1,21
      XBRADJ(I) = ( XBR(I) - XREFBR ) * COSBR + XBPAS(1)
      XASADJ(I) = ( XAS(I) - XBPAS(1) ) * COSAS + XBPAS(1)
   15 CONTINUE
C           ---------------
      IF( OPTLW .GE. BDIST ) GO TO 20
      Y = OPTLW
      DELY = BDIST - OPTLW
      YPBLB4 = 1.0E30
      GO TO 30
   20 Y = BDIST
      YPBLB4 = -1.0E30
      DELY = 0.
   30 DO 60 I=1,11
      IK = I + 2 * ( 11 - I) * JP/10
      X = ABS( XASADJ(IK) - XBRADJ(IK))
      IF( YPBLB4 .GE. OPTLW ) GO TO 40
      XPARAB = ABS( XASADJ(IK) - XASADJ(1+2*JP) )
      YPARAB = SQRT( 2. * BDIST * ( XPARAB + BDIST/2. ) )
      YPBLB4 = YPARAB
      IF( YPARAB .GE. OPTLW ) GO TO 40
      XDIST(IK) = X * Y/YPARAB
      GO TO 50
   40 XDIST(IK) = X * Y/OPTLW
   50 YDIST(IK) = Y + ( XASADJ(IK) - XBPAS(1) ) * YADJ
      IF( YDIST(IK) .LT. 0.0 ) YDISTK = 0.0
      FLDIST(IK) = SQRT( XDIST(IK)**2 + YDIST(IK)**2 ) + DELY
      SUMFL = SUMFL + FLDIST(IK)
   60 CONTINUE
      IF( IPASS .EQ. 2 ) GO TO 70
   65 SUMFL = SUMFL - 0.5 * ( FLDIST(1) + FLDIST(11) )
      WRITE(8,*) (FLDIST(I),I=1,11),EMPRIM,OPTLW,SUMFL
      IPASS = 2
      GO TO 10
   70 SUMFL = SUMFL - 0.5 * ( FLDIST(11) + FLDIST(21) )
      FL1TO2 = SUMFL/20.
      WRITE(8,*) (FLDIST(I),I=11,21),EMPRIM,OPTLW,SUMFL,FL1TO2
      RETURN
      END
      SUBROUTINE   ODSOPN
C
C          OPEN THE DIRECT-ACCESS FILE (UNIT 14) ON WHICH "BWAM"
C          OUTPUT WILL BE SAVED.
C
      OPEN(14,ACCESS='DIRECT',RECL=400)
C
      ZERO=0.0
      DO 10 I=1,25
   10 WRITE(14,REC=I) ZERO
      RETURN
      END
C                                     <<<<<SUBPROGRAM ODSDIR>>>>>
C     <<<<<LAST REVISED 12-30-86>>>>>
C
      SUBROUTINE   ODSDIR(ISEQ)
C
      COMMON / CHARV  / SECID(100)
      COMMON / DRCTRY / LREC, MXXSEC, ITYPE(100),
     $                            IXSERR(100), SRD(100), WSC(100)
      COMMON / HDGTT2 / ITITLE(70,3), IDATE(15), VDATE
C
      CHARACTER*1 ITITLE, IDATE, VDATE*7, SECID*5
C
C           WRITE TITLE AND DIRECTORY INFORMATION IN THE FIRST
C           SIX RECORDS OF THE CURRENT ALTERNATIVE BLOCK.
C
      WRITE(14,REC=ISEQ) (ITITLE(I,1),I=1,70)
      WRITE(14,REC=ISEQ+1) (ITITLE(I,2),I=1,70)
      WRITE(14,REC=ISEQ+2) (ITITLE(I,3),I=1,70)
      WRITE(14,REC=ISEQ+3) (SECID(I),I=1,LREC)
      WRITE(14,REC=ISEQ+4) (SECID(I),I=1,LREC)
      WRITE(14,REC=ISEQ+5) (ITYPE(I),I=1,LREC)
      RETURN
      END
      SUBROUTINE ODSTOC (IASEQ,IPSEQ,NVTOC,NPTOC,IOREC,IALT,IPR,NERRS)
      COMMON / DRCTRY / LREC, MXXSEC, ITYPE(100),
     $                            IXSERR(100), SRD(100), WSC(100)
      DIMENSION NVTOC(1,1),NPTOC(1,1),IOREC(1)
C
C          UPDATE TABLE OF CONTENTS FOR OVERALL FILE AND THE
C          CURRENT ALTERNATIVE, WRITE THE OUTPUT RECORD NUMBERS
C          FOR THE CROSS SECTIONS IN THE CURRENT PROFILE.
C
      WRITE(14,REC=1) ((NVTOC(I,J),I=1,2),J=1,IALT)
      WRITE(14,REC=IASEQ) LREC,IPR,((NPTOC(I,J),I=1,IPR),J=1,4)
      WRITE(14,REC=IPSEQ) NERRS,(IOREC(I),I=1,LREC)
      RETURN
      END
      SUBROUTINE ODSIN (ISEQ,XSECID,OUTVEC)
C
      CHARACTER*5 XSECID
C
      DIMENSION OUTVEC(58)
C
C          INPUT FROM DA-FILE THE X-SEC ID AND OUTPUT DATA.
C
      READ(14,REC=ISEQ) XSECID,OUTVEC
      RETURN
      END
      SUBROUTINE ODSOUT (ISEQ,XSECID,OUTVEC)
C
      CHARACTER*5 XSECID
C
      DIMENSION OUTVEC(58)
C
C          WRITE TO DA-FILE THE X-SEC ID AND OUTPUT DATA.
C
      WRITE(14,REC=ISEQ) XSECID,OUTVEC
      RETURN
      END
C
      SUBROUTINE OUTSTR(OUTVEC,INDEX,ANSVEC,XSPVEC)
C
C***   LAST REVISED 04-11-84
C
C          TRANSFERS RESULTS FROM ANSVEC & XSPVEC TO OUTVEC ARRAY.
C
      DIMENSION ANSVEC(1),XSPVEC(1),OUTVEC(58)
C
      OUTVEC(1)=XSPVEC(40)
      OUTVEC(2)=ANSVEC(40)
      DO 100 I=1,4
      OUTVEC(I+15)=XSPVEC(I-1+INDEX)
      OUTVEC(I+2)=ANSVEC(I-1+INDEX)
  100 CONTINUE
      DO 200 I=9,17
      OUTVEC(I+11)=XSPVEC(I)
      OUTVEC(I-2)=ANSVEC(I)
  200 CONTINUE
      DO 300 I=18,38
      OUTVEC(I+11)=XSPVEC(I)
  300 CONTINUE
      DO 400 I=18,26
      OUTVEC(I+32)=ANSVEC(I)
  400 CONTINUE
      RETURN
      END
      SUBROUTINE RATBL1(LINES,IREC,LREC,Q,RFLAG,SECID,SRD,WSEL)
C
C***   LAST REVISED 08-15-84
C
      CHARACTER*5 SECID
      CHARACTER*4 ERRFLG, FLAG(4)
      DATA  MSG/9/,  FLAG/'   #','  ##',' ###','    '/
      ERRFLG=FLAG(4)
      IF(RFLAG.LE.0.0) GO TO 10
      IF(RFLAG.GT.3.0) GO TO 10
      IFLAG=INT(RFLAG+0.001)
      ERRFLG=FLAG(IFLAG)
   10 IF(LINES.EQ.0) GO TO 15
      IF(IREC.GT.1) GO TO 30
      IF((LINES+2*(LREC+2)).LT.64) GO TO 20
      LINES=0
   15 CALL HDGPRT(MSG)
      LINES=LINES+9
   20 WRITE(MSG,601) Q,WSEL,ERRFLG,SECID,SRD,WSEL
      LINES=LINES+3
      RETURN
   30 WRITE(MSG,602) ERRFLG,SECID,SRD,WSEL
      LINES=LINES+2
      IF(IREC.LT.LREC) RETURN
      WRITE(MSG,603)
      LINES=LINES+3
      RETURN
  601 FORMAT(19X,'Q    WSEL     XSID     SRD    WSEL  AVG WSEL  DAMAGE'
     *        //12X,F8.0,F8.2,A4,A5,F8.0,F8.2)
  602 FORMAT(55X,'>',9X,'$'/28X,A4,A5,F8.0,F8.2)
  603 FORMAT(58X,'TOTAL  $'// )
      END
C                                     <<<<<SUBPROGRAM RATBL2>>>>>
C     <<<<<LAST REVISED 04-05-86>>>>>
C
      SUBROUTINE   RATBL2 (ISEQ, LINES)
C
      CHARACTER*5 SECID
C
      DIMENSION OUTVEC(58),VARRAY(26),VLST2(5),VLST4(16),FMTW2(5),
     *          FMTW4(16),LSTV2(6),LSTV4(17)
C
      DATA LSTV2/5,50,53,51,52,13/, FMTW2/8.0,8.2,2*8.0,8.2/,
     *     LSTV4/16,3,23,34,36,32,38,44,46,48,35,37,33,39,45,47,49/,
     *     FMTW4/2*8.2,3*7.0,4*6.1,3*7.0,4*6.1/, MSG/9/
C
C
      CALL ODSIN(ISEQ,SECID,OUTVEC)
      VARRAY(1)=OUTVEC(5)
      VARRAY(5)=OUTVEC(3)
      CALL ODSIN(ISEQ-4,SECID,OUTVEC)
      VARRAY(4)=OUTVEC(3)
      VARRAY(6)=VARRAY(5)-VARRAY(4)
      CALL ODSIN(ISEQ-5,SECID,OUTVEC)
      VARRAY(10)=OUTVEC(3)
      CALL ODSIN(ISEQ-3,SECID,OUTVEC)
      CALL FILLVL ( LSTV2, OUTVEC, VLST2 )
      DO 5 I=1,5
      J=I+4
      IF (J.LT.7) J=J-3
      VARRAY(J)=VLST2(I)
    5 CONTINUE
C
      CALL ODSIN(ISEQ-1,SECID,OUTVEC)
      CALL FILLVL ( LSTV4, OUTVEC, VLST4 )
      DO 10 I=1,16
      J=I+10
      VARRAY(J)=VLST4(I)
   10 CONTINUE
C
      IF (LINES.GT.0) GO TO 30
   20 CALL HDGPRT(MSG)
      LINES=LINES+9
   30 LINES=LINES+9
      IF (VARRAY(15).LE.0.0.AND.VARRAY(22).LE.0.0) GO TO 50
      IF (VARRAY(15).GT.0.0.AND.VARRAY(22).GT.0.0) GO TO 40
      LINES=LINES+9
      GO TO 50
   40 LINES=LINES+11
   50 IF (LINES.LT.64) GO TO 60
      LINES=0
      GO TO 20
   60 WRITE(MSG,601) (VARRAY(I),I=1,9)
      IF (VARRAY(15).LE.0.0.AND.VARRAY(22).LE.0.0) GO TO 90
      WRITE(MSG,602) (VARRAY(I),I=10,12)
      IF (VARRAY(15).LE.0.0) GO TO 70
      WRITE(MSG,603) (VARRAY(I),I=13,19)
      IF (VARRAY(22).LE.0.0) GO TO 80
   70 WRITE(MSG,603) (VARRAY(I),I=20,26)
   80 WRITE(MSG,604)
   90 WRITE(MSG,605) VARRAY(1),VARRAY(2),VARRAY(12)
C
 601  FORMAT(/6X,'DESIGN Q =',F8.0,6X,'UPSTREAM WSEL',28X,'DAMAGE'/
     *    1X,'BRIDGE LENGTH =',F8.0,4X,'NORMAL  W/BRIDGE   INCR'/
     *    2X,'LOW STEEL EL =',F8.2,2F10.2,F7.2,5X,'UPSTREAM ',
     *    'FLOOD $'/3X,'LT ABUT STA =',F8.0/3X,'RT ABUT STA =',
     *    F8.0,4X,'BRIDGE VELOCITY =',F7.2,4X,'BRIDGE SCOUR   $')
 602  FORMAT(/1X,'EMBANKMENT OVERTOPPING:',10X,'DURATION =',12X,
     *    'TRAFFIC LOSS   $'//4X,'WSDS =',F8.2,4X,'WSRD =',F8.2,
     *    4X,'RGMIN =',F8.2//5X,'OVERFLOW SECTION',6X,'DEPTH',5X,
     *    'VELOCITY',7X,'SCOUR'/5X,'LEW    REW  LNGTH   MAX   AVG',
     *    '  MAX   AVG   PVMT   FILL'/)
 603  FORMAT(1X,3F7.0,4F6.1)
 604  FORMAT(/56X,'EMBANKMENT     $')
 605  FORMAT(/1X,'DESIGN Q =',F8.0,' BRLEN  =',F8.0,' EMBEL  =',F8.2,
     *    '   TOTAL DAMAGE   $'//)
      RETURN
      END
C                                     <<<<<SUBPROGRAM HPTABL>>>>>
C     <<<<<LAST REVISED 04-05-86>>>>>
C
      SUBROUTINE   HPTABL (XSDATA, ISEQ, SECID, SRD, IXTYPE)
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / HPCOM / IOPTSA, ELMIN, YINC, ELMAX
      COMMON / SAPROP / SAA(20), SAB(20), SAWP(20), SAK(20)
C
      CHARACTER*5 SECID
C
      DIMENSION XSDATA(IPTEND), PVECTR(40), LIST1(6)
C
      DATA LIST1 / 5, 9, 10, 11, 12, 40 / ,  MSG / 6 /
C
      XSTYPE=1.0001*IXTYPE
      LXY=IPTXY+2*XSDATA(1)
      CALL STORIT(PVECTR(1),LIST1,XSDATA(LXY+1),XSDATA(LXY+2),
     *     XSDATA(LXY+3),XSDATA(LXY+4),XSTYPE)
      PVECTR(15)=XSDATA(IPTMSC+1)
      NSA=XSDATA(2)
      ELMN = ELMIN
      ELMX = ELMAX
      IF(ELMN.GT.(PVECTR(12)+0.25)) GO TO 10
      ELMN=PVECTR(12)+0.25*(PVECTR(10)-PVECTR(12))
      INTMIN=IFIX(ELMN+0.5001)
      ELMN=1.0*INTMIN
   10 IF(ELMX.GT.PVECTR(10)) ELMX=PVECTR(10)
      IF(ELMX.LT.ELMN) ELMX=PVECTR(10)
      WS=ELMN
   15 LINES=9
      CALL HDGPRT(MSG)
      WRITE(MSG,600) ISEQ,SECID,SRD
  600 FORMAT(5X,'CROSS-SECTION PROPERTIES:  ISEQ =',I3,
     * ';  SECID = ',A5,';  SRD =',F9.0)
      IF(IOPTSA.EQ.0) WRITE(MSG,601)
  601 FORMAT(/6X,'WSEL',5X,'AREA',8X,'K   TOPW   WETP  ALPH',
     *         '    LEW    REW     QCR')
   20 IF((LINES+3+NSA*IOPTSA).GT.60) GO TO 15
      CALL XSPROP (WS,PVECTR(11),PVECTR(9),1,PVECTR,XSDATA)
      IF(IOPTSA.EQ.0) GO TO 50
      WRITE(MSG,602)
  602 FORMAT(/6X,'WSEL  SA#',5X,'AREA',8X,'K   TOPW   WETP  ALPH',
     *         '    LEW    REW     QCR')
      DO 40 I=1,NSA
      QCR=0
      IF(SAA(I).LE.0.0) GO TO 40
      IF(SAB(I).LE.0.0) GO TO 30
      QCR=SAA(I)*SQRT(32.2*SAA(I)/SAB(I))
   30 WRITE(MSG,603) I,SAA(I),SAK(I),SAB(I),SAWP(I),QCR
      LINES=LINES+1
  603 FORMAT(10X,I5,2F9.0,2F7.0,20X,F8.0)
   40 CONTINUE
   50 QCR=0
      IF(PVECTR(2).LE.0.0.OR.PVECTR(17).LE.0.0) GO TO 60
      QCR=PVECTR(2)*SQRT(32.2*PVECTR(2)/(PVECTR(3)*PVECTR(17)))
   60 IF(IOPTSA.EQ.0) GO TO 70
      WRITE(MSG,604) WS,PVECTR(2),PVECTR(1),PVECTR(17),PVECTR(16),
     *   PVECTR(3),PVECTR(18),PVECTR(19),QCR
  604 FORMAT(F10.2,5X,2F9.0,2F7.0,F6.2,2F7.0,F8.0)
      GO TO 80
   70 WRITE(MSG,605) WS,PVECTR(2),PVECTR(1),PVECTR(17),PVECTR(16),
     *   PVECTR(3),PVECTR(18),PVECTR(19),QCR
  605 FORMAT(F10.2,2F9.0,2F7.0,F6.2,2F7.0,F8.0)
   80 LINES=LINES+1+2*IOPTSA
      IF(WS.GE.ELMX) GO TO 90
      WS=WS+YINC
      IF(WS.GT.ELMX) WS=ELMX
      GO TO 20
   90 WRITE(MSG,606)
  606 FORMAT(1H1)
      RETURN
      END
C                                     <<<<<SUBPROGRAM  VDIST>>>>>
C     <<<<<LAST REVISED 06-15-87>>>>>
C
      SUBROUTINE   VDIST (XSDATA, ISEQ, SECID, SRD, IXTYPE, Q)
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / HPCOM / IOPTSA, ELMIN, YINC, ELMAX
      COMMON / SAPROP / SAA(20), SAB(20), SAWP(20), SAK(20)
C
      CHARACTER*5 SECID
C
      DIMENSION XSDATA(IPTEND), PVECTR(40), LIST1(6), XSTA(21),
     $ ASUBI(20), VSUBI(20)
C
      DATA LIST1 / 5, 9, 10, 11, 12, 40 / ,  MSG / 6 /
C
      LINES = 99
      XSTYPE = 1.0001 * IXTYPE
      LXY = IPTXY + 2 * XSDATA(1)
      CALL STORIT ( PVECTR(1), LIST1, XSDATA(LXY+1),
     $      XSDATA(LXY+2), XSDATA(LXY+3), XSDATA(LXY+4), XSTYPE )
      PVECTR(15) = XSDATA(IPTMSC+1)
C
      ELMN = ELMIN
      ELMX = ELMAX
      IF( ELMN .GT. (PVECTR(12) + 0.25) ) GO TO 10
      ELMN = PVECTR(12) + 0.25 * ( PVECTR(10) - PVECTR(12) )
      INTMIN = IFIX(ELMN + 0.5001)
      ELMN = 1.0 * INTMIN
   10 IF( ELMX .GT. PVECTR(10) ) ELMX = PVECTR(10)
      IF( ELMX .LT. ELMN ) ELMX = PVECTR(10)
      WS = ELMN
C
   20 IF( LINES .LT. 35 ) GO TO 30
      LINES = 9
      CALL HDGPRT ( MSG )
   30 WRITE(MSG,600) ISEQ, SECID, SRD
  600 FORMAT(///5X,'VELOCITY DISTRIBUTION:  ISEQ =',I3,
     $                          ';  SECID = ',A5,';  SRD =',F9.0)
      CALL XSPROP ( WS, PVECTR(11), PVECTR(9), 1, PVECTR, XSDATA )
      VEL = Q / PVECTR(2)
      XSTA(1) = PVECTR(18)
      XSTA(21) = PVECTR(19)
      WRITE(MSG,601) WS, XSTA(1), XSTA(21), PVECTR(2),
     $                                          PVECTR(1), Q, VEL
  601 FORMAT(/6X,'    WSEL     LEW     REW    AREA        K',
     $               '        Q    VEL'/6X,F8.2,3F8.1,2F9.0,F7.2)
C
      CALL CNTRDK ( XSTA(11), WS, XSTA(1), XSTA(21), PVECTR(1),
     $                                           XSTYPE, XSDATA )
      CALL PARTK ( WS, XSTA, PVECTR(1), XSTYPE, XSDATA )
C
      DO 40 I = 1,20
      CALL XSPROP ( WS, XSTA(I), XSTA(I+1), 1, PVECTR, XSDATA )
      ASUBI(I) = PVECTR(2)
      VSUBI(I) = 0.05 * Q / ASUBI(I)
   40 CONTINUE
C
      DO 50 J = 1,4
      K1 = 5 * (J - 1) + 1
      K5 = K1 + 4
      K6 = K1 + 5
      WRITE(MSG,602) ( XSTA(K), K = K1, K6),
     $           (ASUBI(K), K = K1, K5), (VSUBI(K), K = K1, K5)
  602 FORMAT(/' X STA. ',6(4X,F7.1)/'   A(I)',6X,5(4X,F7.1),
     $                                   /'   V(I)',6X,5(5X,F6.2))
   50 CONTINUE
C
      LINES = LINES + 17
      IF( WS .GE. ELMX ) GO TO 60
      WS = WS + YINC
      IF( WS .GT. ELMX ) WS = ELMX
      GO TO 20
C
   60 CONTINUE
C
      WRITE(MSG,603)
  603 FORMAT(1H1)
      RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #9 OF PC VERSION +++++
C                                     <<<<<SUBPROGRAM FILLVL>>>>>
C     <<<<<LAST REVISED 04-05-86>>>>>
C
      SUBROUTINE   FILLVL (LIST, OUTVEC, VLIST)
C
      DIMENSION   LIST(1), OUTVEC(1), VLIST(1)
C
C          TRANSFER VALUES FROM OUTVEC TO THE VLIST VECTOR.
C          VLIST CONTAINS THE VALUES TO BE PRINTED.
C
      NVAR = LIST(1)
C
      DO 100 I = 1, NVAR
      J = LIST(I+1)
      VLIST(I) = OUTVEC(J)
  100 CONTINUE
C
      RETURN
      END
      SUBROUTINE UDTSET
C
C***   LAST REVISED 02-26-85
C
C          THIS SUBROUTINE CONTROLS INITIALIZATION OF THE VARIABLE
C          LISTS, FORMATS, AND HEADINGS FOR THE USER DEFINED TABLES.
C          THE APPROPRIATE HEADING AND FORMAT ARRAYS ARE FILLED BY
C          CALLS TO SUBROUTINE FILLEM.
C
      CHARACTER*8 FV1,FV1X,FV2X,FV4X,FV5X
C
      CHARACTER*4 FH1,FH1X,FH2X,FH4X,FH5X,HD1,HD1X,HD2X,HD4X,HD5X
C
C
      COMMON / J3COM / IRISKT, MXJ3VN, IVARNO(55), IUDTNO(3)
      COMMON / UDTBLK /  LV1,WD1,LV1X,WD1X,LV2X,WD2X,
     1                   LV5X,WD5X,LV4L,WD4X,LV4R
      COMMON /UDTCHR/  FV1,FV1X,FV2X,FV4X,FV5X,
     1                 FH1,FH1X,FH2X,FH4X,FH5X,
     2                 HD1,HD1X,HD2X,HD4X,HD5X
C
      DIMENSION LV1(35,3),WD1(35,3),HD1(40,3),FH1(40,3),FV1(40,3),
     1     LV1X( 5,3),WD1X( 5,3),HD1X(10,3),FH1X(10,3),FV1X(10,3),
     2     LV2X(15,3),WD2X(15,3),HD2X(20,3),FH2X(20,3),FV2X(20,3),
     3     LV5X(10,3),WD5X(10,3),HD5X(15,3),FH5X(15,3),FV5X(15,3),
     4     LV4L(15,3),WD4X(15,3),HD4X(20,3),FH4X(20,3),FV4X(20,3),
     5     LV4R(15,3),ISHIFT(5)
C
      DATA ISHIFT / 0, -19, -17, 12, 2/
C
      K=0
      IVN=0
      DO 10 I=1,3
      LV1 (1,I)=0
      LV1X(1,I)=0
      LV2X(1,I)=0
      LV4L(1,I)=0
      LV5X(1,I)=0
   10 CONTINUE
   15 N=0
      K=K+1
   20 IVN=IVN+1
      IF(IVN.GT.55) GO TO 70
      LVAR=IVARNO(IVN)
      IF(LVAR.LE.0) GO TO 70
      N=N+1
      IF(LVAR.LT.550) GO TO 30
      LV5X(1,K)=LV5X(1,K) + 1
      J=LV5X(1,K) + 1
      LV5X(J,K)=LVAR - 500
      GO TO 20
   30 IF(LVAR.LT.430) GO TO 40
      LV4L(1,K)=LV4L(1,K) + 1
      LV4R(1,K)=LV4L(1,K)
      J=LV4L(1,K) + 1
      LV4L(J,K)=LVAR - 400
      LV4R(J,K)=LV4L(J,K) + 1
      GO TO 20
   40 IF(LVAR.LT.250) GO TO 50
      LV2X(1,K)=LV2X(1,K) + 1
      J=LV2X(1,K) + 1
      LV2X(J,K)=LVAR - 200
      GO TO 20
   50 IF(LVAR.LT.150) GO TO 60
      LV1X(1,K)=LV1X(1,K) + 1
      J=LV1X(1,K) + 1
      LV1X(J,K)=LVAR - 100
      GO TO 20
   60 LV1(1,K)=LV1(1,K) + 1
      J=LV1(1,K) + 1
      LV1(J,K)=LVAR
      GO TO 20
   70 IUDTNO(K)=N
      IF(N.EQ.0) GO TO 120
      IF(LV1(1,K).EQ.0) GO TO  80
      CALL FILLEM (LV1(1,K),WD1(1,K),HD1(1,K),FH1(1,K),
     1                                    FV1(1,K),ISHIFT(1))
   80 IF(LV1X(1,K).EQ.0) GO TO  90
      CALL FILLEM (LV1X(1,K),WD1X(1,K),HD1X(1,K),FH1X(1,K),
     1                                   FV1X(1,K),ISHIFT(2))
   90 IF(LV2X(1,K).EQ.0) GO TO 100
      CALL FILLEM (LV2X(1,K),WD2X(1,K),HD2X(1,K),FH2X(1,K),
     1                                   FV2X(1,K),ISHIFT(3))
  100 IF(LV4L(1,K).EQ.0) GO TO 110
      CALL FILLEM (LV4L(1,K),WD4X(1,K),HD4X(1,K),FH4X(1,K),
     1                                    FV4X(1,K),ISHIFT(4))
  110 IF(LV5X(1,K).EQ.0) GO TO 15
      CALL FILLEM (LV5X(1,K),WD5X(1,K),HD5X(1,K),FH5X(1,K),
     1                                    FV5X(1,K),ISHIFT(5))
      GO TO 15
  120 CONTINUE
      RETURN
      END
      SUBROUTINE FILLEM (LSTV,FWID,HDG,FMTH,FMTV,ISHIFT)
C
C***   LAST REVISED 02-26-85
C
C          USER DEFINED TABLE SETUP ROUTINE
C          SETS UP DATA FIELDS, HEADINGS, AND FORMATS FOR TABLES.
C
      DIMENSION LSTV(10),FWID(10),HDG(10),FMTH(10),FMTV(10)
      DIMENSION AFMTS(9),FFMTS(17),FIELDS(57),HDNGS(57),
     1           AFMTDP(9)
      CHARACTER*8 FFMTS,FMTV,PRNLTD,PRNRTD,AFMTDP,ONEX
C
      CHARACTER*4 PARENL, PARENR, COLON, AFMTS, HDNGS, HDG, FMTH
C     DOUBLE PRECISION FFMTS,FMTV,PRNLTD,PRNRTD,AFMTDP,ONEX
C
      DATA AFMTS /'A1, ','A2, ','A3, ','A4, ','A5, ','A6, ',
     1     'A7, ','A8, ','A9, '/
C
      DATA AFMTDP /'A1, ','A2, ','A3, ','A4, ','A5, ','A6, ',
     1     'A7, ','A8, ','A9, '/
C
      DATA FFMTS   /'F5.0,   ','F5.1,   ','F5.2,   ','F5.3,   ',
     1   'F6.0,   ','F6.1,   ','F6.2,   ','F6.3,   ','F7.0,   ',
     2   'F7.1,   ','F7.2,   ','F7.3,   ','F8.0,   ','F8.1,   ',
     3   'F8.2,   ','F8.3,   ','F9.0,   '/
C
      DATA FIELDS / 2*0.0, 8.2, 6.2, 8.0, 7.0, 2*8.2, 2*7.0,
     1   2*6.2, 3*8.2, 2*9.0, 2*6.2, 7.0, 8.2, 7.0, 8.2, 7*7.0,
     2   2*6.2, 3*7.0, 8.2, 2*5.0, 7.3, 5.0, 7.3, 8.0, 3*7.0,
     3   6*6.1, 7.3, 9.0, 2*7.0, 7.3, 8.2/
C
      DATA HDNGS    /'XSID','CODE','WSEL','VHD ','   Q',' SRD',
     1 ' EGL',' ERR','FLEN','SLEN','  HF','  HO',' VEL',' FR#',
     2 'CRWS','   K','AREA','ALPH','BETA','XMAX','YMAX','XMIN',
     3 'YMIN','SPLT','SPRT','SKEW','XSWP','XSTW',' LEW',' REW',
     4 '  EK','  CK','BLEN','XLAB','XRAB','LSEL','FLOW','TYPE',
     5 '   C','PPCD',' P/A','   Q','WLEN',' LEW',' REW','DMAX',
     6 'CAVG','HAVG','DAVG','VMAX','VAVG','M(K)','  KQ','XLKQ',
     7 'XRKQ','M(G)','OTEL'/
C
      DATA PARENL /'(/'/,  PARENR /')'/,  COLON /':'/,
     1        PRNLTD /'('/,  PRNRTD /')'/, ONEX /'1X,'/
C
      HDG(1)=HDNGS(1)
      HDG(2)=COLON
      HDG(3)=HDNGS(2)
      FMTH(1)=PARENL
      FMTH(2)=AFMTS(9)
      FMTH(3)=AFMTS(1)
      FMTH(4)=AFMTS(4)
      FMTV(1)=PRNLTD
      FMTV(2)=AFMTDP(4)
      FMTV(3)=AFMTDP(5)
      FMTV(4)=AFMTDP(4)
      FMTV(5)=ONEX
      IVAR=LSTV(1)
      J=ISHIFT
      DO 10 I=1,IVAR
      NVAR=LSTV(I+1)
      IF(ISHIFT.EQ.12) J=ISHIFT-((NVAR-30)/2)
      FWID(I)=FIELDS(NVAR+J)
      HDG(I+3)=HDNGS(NVAR+J)
      IWID=IFIX(FWID(I))
      IDEC=IFIX((FWID(I)+0.0005-IWID)*10.)
      FMTH(I+4)=AFMTS(IWID)
      IFFMT=1+4*(IWID-5)+IDEC
      FMTV(I+5)=FFMTS(IFFMT)
   10 CONTINUE
      FMTH(IVAR+5)=PARENR
      FMTV(IVAR+6)=PRNRTD
      RETURN
      END
C                                     <<<<<SUBPROGRAM UDTPRT>>>>>
C     <<<<<LAST REVISED 11-25-87>>>>>
C
      SUBROUTINE   UDTPRT ( LREC , IOREC , IUDTNO )
C
C          THIS SUBROUTINE CONTROLS PRINTING OF THE USER DEFINED
C          TABLES.  THE ACTUAL PRINTING IS PERFORMED IN UDTPR1
C          (HEADING AND DATA) AND UDTPR2 (DATA ONLY).
C
      CHARACTER*8 FV1,FV1X,FV2X,FV4X,FV5X,WORD,
     1            XSCODE*4,ERRFLG*4,BLANK*4,FLAG*4,CODE*4,SECID*5
C
      CHARACTER*4 FH1,FH1X,FH2X,FH4X,FH5X,HD1,HD1X,HD2X,HD4X,HD5X
C
      COMMON / UDTBLK /  LV1,WD1,LV1X,WD1X,LV2X,WD2X,
     1                   LV5X,WD5X,LV4L,WD4X,LV4R
      COMMON /UDTCHR/  FV1,FV1X,FV2X,FV4X,FV5X,
     1                 FH1,FH1X,FH2X,FH4X,FH5X,
     2                 HD1,HD1X,HD2X,HD4X,HD5X
C
      DIMENSION LV1(35,3),WD1(35,3),HD1(40,3),FH1(40,3),FV1(40,3),
     1     LV1X( 5,3),WD1X( 5,3),HD1X(10,3),FH1X(10,3),FV1X(10,3),
     2     LV2X(15,3),WD2X(15,3),HD2X(20,3),FH2X(20,3),FV2X(20,3),
     3     LV5X(10,3),WD5X(10,3),HD5X(15,3),FH5X(15,3),FV5X(15,3),
     4     LV4L(15,3),WD4X(15,3),HD4X(20,3),FH4X(20,3),FV4X(20,3),
     5     LV4R(15,3)
C
      DIMENSION IOREC(1),IUDTNO(3),OUTVEC(58),VRBLS(35),WORD(3),
     1        FLAG(3),CODE(6)
C
      DATA BLANK /'    '/,FLAG /'   #','  ##',' ###'/, MSG/6/,
     1             WORD / '   FIRST', '  SECOND', '   THIRD' /,
     2       CODE /':XS ',':FV ',':BR ',':SD ',':RG ',':AS '/
C
      DO 120 K=1,3
      IF(IUDTNO(K).EQ.0) GO TO 130
      LINES=0
      DO 110 NREC=1,LREC
      ISEQ=IOREC(NREC)
      CALL ODSIN(ISEQ,SECID,OUTVEC)
      IGO = INT(OUTVEC(1) + 1.0)
      XSCODE=CODE(IGO)
      ERRFLG=BLANK
      IF(OUTVEC(2).LE.0.0) GO TO 10
      IF(ABS(OUTVEC(2)).GT.3.) GO TO 10
      IFLAG=INT(OUTVEC(2)+0.001)
      ERRFLG=FLAG(IFLAG)
   10 IF(LINES.GT.0) GO TO 30
   20 CALL HDGPRT (MSG)
      WRITE(MSG,2001) WORD(K)
 2001 FORMAT(A8,' USER DEFINED TABLE.')
      LINES=LINES+9
      NEWHD=1
   30 IF(LV1(1,K).LE.0) GO TO 50
      IF((LINES+4+2*NEWHD).GT.60) LINES=0
      IF(LINES.EQ.0) GO TO 20
      CALL FILLVL(LV1(1,K),OUTVEC,VRBLS)
      IVAR=LV1(1,K)
      IF(NEWHD.EQ.0) GO TO 40
      CALL UDTPR1 ( MSG, IVAR, LINES, HD1(1,K), FH1(1,K),
     $                   ERRFLG, SECID, XSCODE, VRBLS, FV1(1,K) )
      NEWHD=0
      GO TO 50
   40 CALL UDTPR2 ( MSG, IVAR, LINES, ERRFLG, SECID, XSCODE,
     $                                          VRBLS, FV1(1,K) )
   50 GO TO (60,60,70,60,80,90),IGO
   60 IF(LV1X(1,K).LE.0) GO TO 110
      CALL FILLVL(LV1X(1,K),OUTVEC,VRBLS)
      IVAR=LV1X(1,K)
      CALL UDTPR1 ( MSG, IVAR, LINES, HD1X(1,K), FH1X(1,K),
     $                  ERRFLG, SECID, XSCODE, VRBLS, FV1X(1,K) )
      GO TO 100
   70 IF(LV2X(1,K).LE.0) GO TO 110
      CALL FILLVL(LV2X(1,K),OUTVEC,VRBLS)
      IVAR=LV2X(1,K)
      CALL UDTPR1 ( MSG, IVAR, LINES, HD2X(1,K), FH2X(1,K),
     $                  ERRFLG, SECID, XSCODE, VRBLS, FV2X(1,K) )
      GO TO 100
   80 IF(LV4L(1,K).LE.0) GO TO 110
      CALL FILLVL(LV4L(1,K),OUTVEC,VRBLS)
      IVAR=LV4L(1,K)
      CALL UDTPR1 ( MSG, IVAR, LINES, HD4X(1,K), FH4X(1,K),
     $                  ERRFLG, SECID, XSCODE, VRBLS, FV4X(1,K) )
      CALL FILLVL(LV4R(1,K),OUTVEC,VRBLS)
      CALL UDTPR2 ( MSG, IVAR, LINES, ERRFLG, SECID, XSCODE,
     $                                         VRBLS, FV4X(1,K) )
      GO TO 100
   90 IF(LV5X(1,K).LE.0) GO TO 110
      CALL FILLVL(LV5X(1,K),OUTVEC,VRBLS)
      IVAR=LV5X(1,K)
      CALL UDTPR1 ( MSG, IVAR, LINES, HD5X(1,K), FH5X(1,K),
     $                  ERRFLG, SECID, XSCODE, VRBLS, FV5X(1,K) )
  100 NEWHD=1
  110 CONTINUE
  120 CONTINUE
  130 RETURN
      END
C                                     <<<<<SUBPROGRAM UDTPR1>>>>>
C     <<<<<LAST REVISED 11-25-87>>>>>
C
      SUBROUTINE   UDTPR1 ( MSG, IVAR, LINES, HDNG, FMTHDG,
     $                     ERRFLG, SECID, XSCODE, VRBLS, FMTVAR )
C
      DIMENSION HDNG(1), VRBLS(1)
      CHARACTER*4 HDNG, FMTHDG(20), FH(20), XSCODE, ERRFLG
      CHARACTER*127 FMTV, FMTH
      CHARACTER*8 FV(20), FMTVAR(20), SECID*5
      EQUIVALENCE (FV(1),FMTV), (FH(1),FMTH)
C
      DO 9 I = 1,20
      FV(I) = FMTVAR(I)
      FH(I) = FMTHDG(I)
    9 CONTINUE
C
      IHD = IVAR + 3
      WRITE(MSG,FMTH) ( HDNG(I), I = 1,IHD )
      WRITE(MSG,FMTV) ERRFLG, SECID, XSCODE,
     $                                   ( VRBLS(I), I = 1,IVAR )
      LINES = LINES + 3
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM UDTPR2>>>>>
C     <<<<<LAST REVISED 11-25-87>>>>>
C
      SUBROUTINE   UDTPR2 ( MSG, IVAR, LINES, ERRFLG, SECID,
     $                                    XSCODE, VRBLS, FMTVAR )
C
      DIMENSION VRBLS(1)
      CHARACTER*8 FMTVAR(20), SECID*5, XSCODE*4, ERRFLG*4
      CHARACTER*127 FMTV
      CHARACTER*8 FV(20)
      EQUIVALENCE (FV(1),FMTV)
C
      DO 9 I = 1,20
      FV(I) = FMTVAR(I)
    9 CONTINUE
C
      WRITE(MSG,FMTV) ERRFLG, SECID, XSCODE,
     $                                   ( VRBLS(I), I = 1,IVAR )
      LINES = LINES + 1
C
      RETURN
      END
      SUBROUTINE MULTBO(IREC,IRECAS,NBO,PROFNV,XSBLOK,ANSVEC,
     *                                            XSPVEC,ERRFLG)
C
C***  LAST REVISED 01-15-85
C
      REAL K4,K3,K1,KQ,KC,KS
      CHARACTER*5 SECID,XSID,SLICE
      COMMON / JHPARM / DELTAY, YTOL, QTOL, FNTEST
      COMMON/IPTCB1/IPTXY,JUNK(2),IPTMSC,IPTPEA,IPTABG,IPTEND
      COMMON / CHARV  / SECID(100)
      COMMON / DRCTRY / LREC, MXXSEC, ITYPE(100),
     $                            IXSERR(100), SRD(100), WSC(100)
      COMMON / LPARMS / ZD1TO2,ZDDTO2,ZD2TO3,ZD3TO4,
     *                  FD1TO2,FDDTO2,FD2TO3,FD3TO4
      COMMON / KQBLK / KQ,XLTKQ,XRTKQ,UZRCOD,UZRBRL,UZRXKQ
      DIMENSION XSBLOK(IPTEND,5),ANSVEC(40,5),XSPVEC(40,5),
     *   ASBLOK(420),AVECAS(40),PVECAS(40),CVBLOK(420),
     *   FVBLOK(420),AVECFV(40),PVECFV(40),PROFNS(14,10),
     *   PROFNV(14),CVAR(15,10),STAGLT(11),STAGRT(11),
     *   CJ(10),A3(10),CDF(10),QS(10),AS(10),KS(10),CRF(10),
     *   CA3(10),WSMXS(10),BOLEW(10),BOREW(10),QSB4(10),
     *   OUTVEC(58),LIST1(6),LIST2(6)
      DATA SUBPGM/252525./,DUMMY/1E30/,MSG/6/
      DATA LIST1/ 5,9,10,11,12,40 /, SLICE /'SLICE'/,
     *        LIST2 / 5,1,2,3,4,17 /
C
C            INPUT THE FULL-VALLEY SECTION TO GET VSDNST, THEN
C            INPUT THE EXIT (DOWNSTREAM MATCH) SECTION WHICH IS
C            USED TO 'FABRICATE' AN EXIT SECTION FOR EACH OF THE
C            VALLEY "SLICES".
C
      CALL DAFIN(IREC,XSBLOK(1,1))
      VSDNST=XSBLOK(IPTMSC+5,1)
      CALL DAFIN(IREC-1,XSBLOK(1,1))
      LXY=IPTXY+2*XSBLOK(1,1)
      CALL STORIT(XSPVEC(1,1),LIST1,XSBLOK(LXY+1,1),
     *      XSBLOK(LXY+2,1),XSBLOK(LXY+3,1),XSBLOK(LXY+4,1),1.0)
      XSPVEC(15,1)=XSBLOK(IPTMSC+1,1)
      DO 5 I=1,IPTEND
      ASBLOK(I)=XSBLOK(I,5)
      FVBLOK(I)=XSBLOK(I,1)
    5 CONTINUE
      DO 10 I=1,40
      PVECAS(I)=XSPVEC(I,5)
      AVECAS(I)=ANSVEC(I,5)
      PVECFV(I)=XSPVEC(I,1)
      AVECFV(I)=ANSVEC(I,1)
   10 CONTINUE
      VSUPST=XSBLOK(IPTMSC+5,5)
      DO 25 J=1,NBO
      QSB4(J)=-1E15
      CJ(J)=-1E15
      DO 15 I=1,15
      CVAR(I,J)=-1E15
   15 CONTINUE
   25 CONTINUE
      IQOK=2**(NBO+1)-2
      LINES=0
      WSB4=PROFNV(1)
      QT=PROFNV(9)
      MOREC=IREC
      SUMA3=0.0
      DO 100 J=1,NBO
      MOREC=MOREC+1
      IF(ITYPE(MOREC).EQ.2) GO TO 40
      IF(ITYPE(MOREC).EQ.6) GO TO 30
      WRITE(MSG,2929) ITYPE(MOREC-1),ITYPE(MOREC),ITYPE(MOREC+1)
 2929 FORMAT(/'CROSS SECTIONS IMPROPERLY ORDERED - RUN ABORTED.',
     *              /25X,3I7)
      STOP 963
   30 CALL DAFIN(MOREC,CVBLOK)
      PROFNS(6,J)=PROFNV(6)
      PROFNS(5,J)=PROFNV(5)
      PROFNS(2,J)=PROFNV(6)+CVBLOK(IPTMSC+12)
      TWD=PROFNS(5,J)-CVBLOK(IPTMSC+14)
      DEP=AMIN1(CVBLOK(IPTABG+1)/12.0 , TWD)
      ISHAPE=CVBLOK(IPTMSC+6)
      CALL CULGOM(DEP, ISHAPE, CVBLOK(IPTABG+1), A3(J), WP, T)
      SPAN=CVBLOK(IPTABG+2)/12.0
      IF(ISHAPE.EQ.2) SPAN=CVBLOK(IPTABG+1)/12.0
      BOLEW(J)=CVBLOK(IPTMSC+15)-SPAN/2.0
      BOREW(J)=BOLEW(J)+SPAN
      GO TO 90
   40 CALL DAFIN(MOREC,XSBLOK(1,2))
      LXY=IPTXY+2*XSBLOK(1,2)
      CALL STORIT(XSPVEC(1,2),LIST1,XSBLOK(LXY+1,2),
     *      XSBLOK(LXY+2,2),XSBLOK(LXY+3,2),XSBLOK(LXY+4,2),2.0)
      PROFNS(6,J)=SRD(MOREC)
      PROFNS(5,J)=PROFNV(5)
      IF(PROFNS(6,J).EQ.PROFNV(6)) GO TO 50
      PROFNS(5,J)=PROFNS(5,J)+(PROFNV(5)-PROFNV(7))*
     $           (PROFNS(6,J)-PROFNV(10))/(PROFNV(6)-PROFNV(10))
   50 XSPVEC(15,2)=XSBLOK(IPTMSC+1,2)
      CALL XSPROP(PROFNS(5,J),XSPVEC(11,2),XSPVEC(9,2),1,
     *                                  XSPVEC(1,2),XSBLOK(1,2))
      A3(J)=XSPVEC(2,2)
      BOLEW(J)=XSPVEC(18,2)
      BOREW(J)=XSPVEC(19,2)
      BRLEN=XSBLOK(IPTABG+1,2)
      BRWDTH=XSBLOK(IPTMSC+7,2)
      IF(ABS(BRLEN).LT.1E5) GO TO 60
      BRLEN=XSPVEC(9,2)-XSPVEC(11,2)
   60 PROFNS(2,J)=PROFNS(6,J)+BRLEN+BRWDTH
      IF(PROFNS(2,J).GT.PROFNV(2)) PROFNS(2,J)=PROFNV(2)
      PROFNS(1,J)=PROFNV(1)
      IF(PROFNS(2,J).EQ.PROFNV(2)) GO TO 70
      PROFNS(1,J)=PROFNS(1,J)+(PROFNV(1)-PROFNV(5))*
     $           (PROFNS(2,J)-PROFNV(6))/(PROFNV(2)-PROFNV(6))
   70 PROFNS(10,J)=PROFNS(6,J)-BRLEN
      IF(PROFNS(10,J).LT.PROFNV(10)) PROFNS(10,J)=PROFNV(10)
      PROFNS(7,J)=PROFNV(7)
      IF(PROFNS(10,J).EQ.PROFNV(10)) GO TO 80
      PROFNS(7,J)=PROFNS(7,J)+(PROFNV(5)-PROFNV(7))*
     $           (PROFNS(6,J)-PROFNV(10))/(PROFNV(6)-PROFNV(10))
   80 IF(ITYPE(MOREC+1).NE.3) GO TO 90
      MOREC=MOREC+1
      PROFNS(4,J)=SRD(MOREC)
      PROFNS(3,J)=PROFNS(5,J)+(PROFNS(1,J)-PROFNS(5,J))*
     $       (PROFNS(4,J)-PROFNS(6,J))/(PROFNS(2,J)-PROFNS(6,J))
   90 SUMA3=SUMA3+A3(J)
  100 CONTINUE
C
C          'ROUGH' Q-APPORTIONMENT BASED ONLY ON 'NORMAL' AREA
C
      DO 110 J=1,NBO
      QS(J)=A3(J)*QT/SUMA3
  110 CONTINUE
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9110) (A3(I),I=1,NBO)
 9110 FORMAT(/' A3 --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9111) (QS(I),I=1,NBO)
 9111 FORMAT(/' QS --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9112) (BOLEW(I),I=1,NBO)
 9112 FORMAT(/' BOLEW --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9113) (BOREW(I),I=1,NBO)
 9113 FORMAT(/' BOREW --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      STAGLT(1)=-1E15
      STAGRT(NBO)=1E15
      NSP=NBO-1
  115 DO 120 J=1,NSP
      STAGRT(J)=BOREW(J)+(A3(J)/(A3(J)+A3(J+1)))*
     *                               (BOLEW(J+1)-BOREW(J))
      STAGLT(J+1)=STAGRT(J)
  120 CONTINUE
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9120) (STAGLT(I),I=1,NBO)
 9120 FORMAT(/' STAGLT --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9121) (STAGRT(I),I=1,NBO)
 9121 FORMAT(/' STAGRT --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      SUMKS=0.0
      SUMAS=0.0
      DO 130 J=1,NBO
      CALL XSPROP(WSB4,STAGLT(J),STAGRT(J),1,PVECAS,
     *     ASBLOK)
      AS(J)=PVECAS(2)
      KS(J)=PVECAS(1)
      SUMAS=SUMAS+AS(J)
      SUMKS=SUMKS+KS(J)
  130 CONTINUE
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9130) (AS(I),I=1,NBO),SUMAS
 9130 FORMAT(/' AS --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9131) (KS(I),I=1,NBO),SUMKS
 9131 FORMAT(/' KS --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      SUMCA3=0.0
      MOREC=IREC
      DO 160 J=1,NBO
      IF(CJ(J).GT.0.0) GO TO 150
      MOREC=MOREC+1
      IF(ITYPE(MOREC).EQ.6) CJ(J)=1.0
      IF(ITYPE(MOREC).NE.2) GO TO 150
      CALL DAFIN(MOREC,XSBLOK(1,2))
      LXY=IPTXY+2*XSBLOK(1,2)
      CALL STORIT(XSPVEC(1,2),LIST1,XSBLOK(LXY+1,2),
     *      XSBLOK(LXY+2,2),XSBLOK(LXY+3,2),XSBLOK(LXY+4,2),2.0)
      XSPVEC(15,2)=XSBLOK(IPTMSC+1,2)
      XSBLOK(1,3)=-1.0
      IF(ITYPE(MOREC+1).NE.3) GO TO 140
      MOREC=MOREC+1
      CALL DAFIN(MOREC,XSBLOK(1,3))
      LXY=IPTXY+2*XSBLOK(1,3)
      CALL STORIT(XSPVEC(1,3),LIST1,XSBLOK(LXY+1,3),
     *      XSBLOK(LXY+2,3),XSBLOK(LXY+3,3),XSBLOK(LXY+4,3),3.0)
      XSPVEC(15,3)=XSBLOK(IPTMSC+1,3)
  140 CDF(J)=QS(J)*SUMKS/(KS(J)*QT)
      XSPVEC(13,5)=STAGLT(J)
      XSPVEC(14,5)=STAGRT(J)
      SHIFT=VSUPST*(PROFNV(2)-PROFNS(2,J))
      CALL XSMOD(ASBLOK,XSBLOK(1,5),XSPVEC(1,5),PVECAS,SHIFT,CDF(J))
      CALL XSPROP(PROFNS(1,J),XSPVEC(13,5),XSPVEC(14,5),1,
     *                                  XSPVEC(1,5),XSBLOK(1,5))
      CALL CPARMS(PROFNS(1,J),CVAR(1,J),IBRTYP,XSBLOK,ANSVEC,XSPVEC)
      CALL CPARMV(IBRTYP,CVAR(1,J),CJ(J),PROFNS(1,J),PROFNS(3,J),
     *       PROFNS(5,J),QS(J),XSBLOK,ANSVEC,XSPVEC)
  150 CA3(J)=CJ(J)*A3(J)
      SUMCA3=SUMCA3+CA3(J)
      CRR=(KS(J)/AS(J))/(SUMKS/SUMAS)
      CRF(J)=LOG(10.0*CRR**0.46)
  160 CONTINUE
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9150) (CA3(I),I=1,NBO),SUMCA3
 9150 FORMAT(/' CA3 --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9151) (CJ(I),I=1,NBO)
 9151 FORMAT(/' CJ --- ',10F8.3)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9152) (CDF(I),I=1,NBO)
 9152 FORMAT(/' CDF --- ',10F8.3)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9153) (CRF(I),I=1,NBO)
 9153 FORMAT(/' CRF --- ',10F8.3)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      IQTOL=0
      SUMQS=0.0
      DO 170 J=1,NBO
      QS(J)=CRF(J)*QT*CA3(J)/SUMCA3
      SUMQS=SUMQS+QS(J)
  170 CONTINUE
      DO 180 J=1,NBO
      QS(J)=QS(J)*QT/SUMQS
      IF(ABS((QS(J)/QSB4(J))-1.0).LE.QTOL)
     *                           IQTOL=IQTOL+2**J
      CDF(J)=QS(J)*SUMKS/(KS(J)*QT)
  180 CONTINUE
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9181) (QS(I),I=1,NBO)
 9181 FORMAT(/' QS --- ',10F8.0)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      WRITE(6,9182) (CDF(I),I=1,NBO)
 9182 FORMAT(/' CDF --- ',10F8.3)
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      MOREC=IREC
      SUMK=0.0
      WTDSUM=0.0
      DO 350 J=1,NBO
      DO 190 I=1,5
      IF(I.EQ.2.OR.I.EQ.3) GO TO 190
      XSPVEC(13,I)=STAGLT(J)
      XSPVEC(14,I)=STAGRT(J)
  190 CONTINUE
      PVECAS(13)=STAGLT(J)
      PVECAS(14)=STAGRT(J)
      MOREC=MOREC+1
      IF(ITYPE(MOREC).EQ.2) GO TO 195
      CALL DAFIN(MOREC,CVBLOK)
      CALL CULCAL (1,CVBLOK,QS(J),PROFNS(5,J),PROFNS(1,J),A3(J))
      GO TO 210
  195 SHIFT=VSDNST*(PROFNS(10,J)-PROFNV(10))
      CALL XSMOD(FVBLOK,XSBLOK(1,1),XSPVEC(1,1),PVECFV,SHIFT,-1.1)
      CALL XSPROP(PROFNS(7,J),XSPVEC(13,1),XSPVEC(14,1),1,
     *                                  XSPVEC(1,1),XSBLOK(1,1))
      DO 200 I=1,4
      PROFNS(I+10,J)=XSPVEC(I,1)
  200 CONTINUE
      PROFNS(9,J)=QS(J)
      PROFNS(8,J)=PROFNS(13,J)*((PROFNS(9,J)/PROFNS(12,J))**2)/64.3
  210 SHIFT=VSUPST*(PROFNV(2)-PROFNS(2,J))
      CALL XSMOD(ASBLOK,XSBLOK(1,5),XSPVEC(1,5),PVECAS,SHIFT,CDF(J))
      CALL XSPROP(PROFNS(1,J),XSPVEC(13,5),XSPVEC(14,5),1,
     *                                  XSPVEC(1,5),XSBLOK(1,5))
      IF(ITYPE(MOREC).EQ.2) GO TO 250
      CALL STORIT(ANSVEC(1,5),LIST2,PROFNS(1,J),DUMMY,QS(J),
     *                                   PROFNS(2,J),DUMMY)
      CALL HYDEQS(1,ANSVEC(1,5),1,XSPVEC(1,5))
      DO 220 I=1,5
      ANSVEC(I+9,5)=1E15
  220 CONTINUE
      XSID=SLICE
      IGO=1
      CALL OUTSTR(OUTVEC,1,ANSVEC(1,5),XSPVEC(1,5))
      CALL STDPRT(XSID,IGO,LINES,OUTVEC)
      GO TO 285
  250 CALL DAFIN(MOREC,XSBLOK(1,2))
      LXY=IPTXY+2*XSBLOK(1,2)
      CALL STORIT(XSPVEC(1,2),LIST1,XSBLOK(LXY+1,2),
     *      XSBLOK(LXY+2,2),XSBLOK(LXY+3,2),XSBLOK(LXY+4,2),2.0)
      XSPVEC(15,2)=XSBLOK(IPTMSC+1,2)
      ANSVEC(4,2)=PROFNS(6,J)
      ANSVEC(4,5)=PROFNS(2,J)
      IRECBO=MOREC
      XSBLOK(1,3)=-1E5
      IF(ITYPE(MOREC+1).NE.3) GO TO 260
      MOREC=MOREC+1
      CALL DAFIN(MOREC,XSBLOK(1,3))
      LXY=IPTXY+2*XSBLOK(1,3)
      CALL STORIT(XSPVEC(1,3),LIST1,XSBLOK(LXY+1,3),
     *      XSBLOK(LXY+2,3),XSBLOK(LXY+3,3),XSBLOK(LXY+4,3),3.0)
      XSPVEC(15,3)=XSBLOK(IPTMSC+1,3)
      ANSVEC(4,3)=PROFNS(4,J)
  260 CALL BRIDGE(IRECBO,IRECAS,PROFNS(1,J),XSBLOK(1,1),
     *               ANSVEC(1,1),XSPVEC(1,1),CVAR(1,J),ERRFLG)
      IF(ERRFLG .GT. 0.9) RETURN
      BOLEW(J)=XSPVEC(18,2)
      BOREW(J)=XSPVEC(19,2)
      A3(J)=XSPVEC(2,2)
      CJ(J)=ANSVEC(24,2)
      DO 280 L=2,5
      IF(XSBLOK(1,L).LE.0.0) GO TO 280
      IF(L.EQ.2) XSID=SECID(IRECBO)
      IF(L.EQ.3) XSID=SECID(IRECBO+1)
      IF(L.EQ.4) XSID=SECID(IRECAS-1)
      IF(L.EQ.5) XSID=SLICE
      IGO=L+1
      CALL OUTSTR(OUTVEC,1,ANSVEC(1,L),XSPVEC(1,L))
      CALL STDPRT(XSID,IGO,LINES,OUTVEC)
  280 CONTINUE
  285 DO 290  I=1,4
      PVECAS(I)=XSPVEC(I,5)
      PVECAS(I+4)=XSPVEC(I,5)
      AVECAS(I)=ANSVEC(I,5)
      AVECAS(I+4)=ANSVEC(I,5)
  290 CONTINUE
      AVECAS(4)=PROFNV(2)
      AVECAS(8)=PROFNS(2,J)
      AVECAS(12)=PROFNV(2)-PROFNS(2,J)
      IF(ABS(AVECAS(12)).LE.5) GO TO 330
      CALL STEPBW(SECID(IRECAS),1,AVECAS,1,PVECAS,ASBLOK)
      DO 300 I=1,4
      AVECAS(I+4)=AVECAS(I)
      PVECAS(I+4)=PVECAS(I)
  300 CONTINUE
      CALL OUTSTR(OUTVEC,1,AVECAS,PVECAS)
      XSID=SECID(IRECAS)
      IGO=1
      CALL STDPRT(XSID,IGO,LINES,OUTVEC)
  330 WSC(IRECAS)=AVECAS(17)
      SUMK=SUMK+PVECAS(1)
      WTDSUM=WTDSUM+AVECAS(1)*PVECAS(1)
  350 CONTINUE
      WSMTCH=WTDSUM/SUMK
      IWSOK=0
      ERR=WSMTCH-WSB4
      IF(ABS(ERR).LE.YTOL) IWSOK=1
      WSB4=WSMTCH
      CALL XSPROP(WSMTCH,PVECAS(11),PVECAS(9),1,
     *                                  PVECAS,ASBLOK)
      CALL STORIT(AVECAS,LIST2,WSMTCH,DUMMY,QT,
     *                                   PROFNV(2),DUMMY)
      CALL HYDEQS(1,AVECAS,1,PVECAS)
      DO 360 I=1,4
      AVECAS(I+10)=1E15
  360 CONTINUE
      AVECAS(10)=ERR
      XSID=SECID(IRECAS)
      IGO=1
      CALL OUTSTR(OUTVEC,1,AVECAS,PVECAS)
      CALL STDPRT(XSID,IGO,LINES,OUTVEC)
      IF(IQTOL.EQ.IQOK.AND.IWSOK.EQ.1) RETURN
      DO 380 J=1,NBO
      QSB4(J)=QS(J)
  380 CONTINUE
      GO TO 115
      END
C                                     <<<<<SUBPROGRAM CULCAL>>>>>
C     <<<<<LAST REVISED 04-10-86>>>>>
C
      SUBROUTINE   CULCAL ( IOPT, XPOOL, Q, TWE, HWE, AREA )
C
C         CULCAL IS CALLED FROM CULVRT AND MULTBO
C
C         CULCAL EXTRACTS CULHY5 INPUT ARGS FROM XPOOL AND
C         RETURNS HEADWATER ELEVATION (ABOVE PROPER DATUM) TO
C         CALLING ROUTINE.
C
C         IOPT .GT. 0 CAUSES PRINTING OF INTERMEDIATE OUTPUT
C         (WHICH IS THE ONLY OUTPUT FOR NOW).
C
      COMMON / IPTCB1 / IPTXY, IPTRGH, IPTFL, IPTMSC, IPTPEA,
     $                                             IPTABG, IPTEND
      COMMON / CVAREA / ASUBC, ASUBN, AIN, AOUT
C
      DIMENSION  XPOOL(1)
C
      DATA MSG / 6 /
C
      ISHAPE = XPOOL(IPTMSC+6)
      IEQNO = XPOOL(IPTMSC+7)
      CKE = XPOOL(IPTMSC+8)
      CVALPH = XPOOL(IPTMSC+9)
      CN = XPOOL(IPTMSC+10)
      BBLS = XPOOL(IPTMSC+11)
      CVLENG = XPOOL(IPTMSC+12)
      USINV = XPOOL(IPTMSC+13)
      DSINV = XPOOL(IPTMSC+14)
      CVSLPE = ( USINV - DSINV ) / CVLENG
      IF( CVSLPE .LE. 0.0 ) CVSLPE = 0.00001
      QB = Q / BBLS
      TWD = TWE - DSINV
C
      CALL CULHY5 ( ISHAPE, XPOOL(IPTABG+1), CVLENG, CVSLPE,
     $                 IEQNO, CKE, CN, CVALPH, TWD, QB, DSUBC,
     $                  DSUBN, OTFULL, HWIN, HWOT, VELIN, VELOT )
      HWE  =  AMAX1(HWIN,HWOT) + DSINV
      AREA = AIN
C
      IF( IOPT .EQ. 0 ) GO TO 500
C
      WRITE(MSG,101) ISHAPE, (XPOOL(IPTABG+I),I=1,5)
  101 FORMAT(5X,'CULVERT SUMMARY:'//5X,'    ISHAPE      RISE  ',
     $ '    SPAN    BOTRAD    TOPRAD    CORNER'/7X,I8,5(1X,F9.2))
C
      WRITE(MSG,102) IEQNO, CKE, CN, CVALPH, CVLENG, CVSLPE
  102 FORMAT(/5X,'     IEQNO       CKE        CN    CVALPH   ',
     $             ' CVLENG    CVSLPE'/7X,I8,1X,F9.2,1X,F9.3,
     $                                        2(1X,F9.2),1X,F9.4)
C
      WRITE(MSG,103) TWD, QB, HWIN, HWOT, OTFULL
  103 FORMAT(/5X,'     TWDEP      QBBL      HWIC      HWOC  ',
     $                                  '  OTFULL'/5X,5(1X,F9.2))
C
      WRITE(MSG,104) DSUBC, ASUBC, DSUBN, ASUBN
  104 FORMAT(/5X,'     DSUBC     ASUBC     DSUBN     ASUBN',
     $                                            /5X,4(1X,F9.2))
C
      WRITE(MSG,105) VELOT, AOUT, VELIN, AIN, HWE
  105 FORMAT(/5X,'     VELOT      AOUT     VELIN       AIN   ',
     $                                   '    HWE'/5X,5(1X,F9.2))
C
  500 CONTINUE
      RETURN
      END
C*PCV*$LARGE
C +++++ BEGIN BLOCK #10 OF PC VERSION +++++
C                                     <<<<<SUBPROGRAM CULHY5>>>>>
C     <<<<<LAST REVISED 04-09-86>>>>>
C
      SUBROUTINE   CULHY5 ( ISHAPE, DIMENS, DIST, SLOPE,
     $                  IEQNO, CKE, CN, ALPHA, TW, Q, DSUBC,
     $                  DSUBN, OTFULL, HWIN, HWOT, VELIN, VELOT )
C
      COMMON / CVAREA / ASUBC, ASUBN, AIN, AOUT
C
      DIMENSION  DIMENS(1)
C
C     CULVERT BACKWATER ANALYSIS --    F.H.W.A.  METHODOLOGY
C
C     FHWA CULVERT PROCEDURES DESCRIBED IN --
C            HY6   -- HYDRAULIC ANAL OF CULVERTS (BOX AND CIRCLE)
C            HY2   -- HYDRAULIC ANAL OF PIPE-ARCH CULVERTS
C            CDS-4 -- HYDRAULIC ANAL OF PIPE-ARCH AND ELLIPTICAL....
C            HEC-5 -- HYDRAULIC CHARTS FOR SELECTION OF HIWAY CULVERTS
C
C     FORTRAN CODING ADAPTED 9/82 BY WK.  FROM F.H.W.A. PROG  HY2, 1969.
C
C   INPUT ARGUMENTS --
C     ISHAPE - CODE = 1=BOX, 2=CIRCLE, 3=ARCH
C     DIMENS - INCHES--  RISE,SPAN,BOTTOM-RADIUS,TOP-RAD,CORNER-RAD.
C     DIST   - CULVERT LENGTH, FEET
C     SLOPE  - INVERT-SLOPE, FT/FT
C     IEQNO  - EQUATION NUMBER FOR INLET CONTROL,  FROM TABLE.
C     CKE    - ENTRANCE LOSS COEFF,      DO.
C     CN     - MANNINGS ROUGHNESS,       DO.
C     ALPHA  - VELOCITY HEAD COEFF,      DO.
C     TW     - TAILWATER DEPTH, FT.
C     Q      - DISCHARGE, CFS.
C
C   OUTPUT ARGUMENTS --
C     DSUBC, DSUBN  - CRITICAL AND NORMAL DEPTHS
C     OTFULL        - FULL-FLOW TEST -- HGL ELEV - TOP OF PIPE AT INLET
C     HWIN, HWOT    - HEADWATER ELEVS, INLET-CONTROL / OUTLET-CONT.
C     VELIN, VELOT  - VELOCITIES,           DO.
C
      PIPBOT = SLOPE*DIST*SQRT(1.-SLOPE**2)
      OTFULL = -999.
      VELOT = 1E30
      AOUT = 1E30
C
      HWIN = CULVIC (Q,ISHAPE,DIMENS,SLOPE,IEQNO) + PIPBOT
C
      CALL CULDEP(  0 ,ALPHA*(Q**2)/32.2,ISHAPE,DIMENS,
     $              DSUBC, AREA, WP, T)
      ASUBC = AREA
      VELIN = Q / AREA
      AIN = AREA
C
      CALL  CULDEP( 1,  Q*CN/(1.486*SQRT(SLOPE)), ISHAPE,DIMENS,
     $              DSUBN , AREA, WP,T )
      ASUBN = AREA
C
      IF( DSUBN .GT. DSUBC )  GO TO 50
      IF( TW .LT. DSUBC ) GO TO 300
C
   50 FRISE   = DIMENS(1)/12.
      H0 = AMAX1(  TW, (FRISE+DSUBC)/2. )
      CALL CULGOM ( FRISE,ISHAPE, DIMENS, AREA, WP, T)
      VSQR2G  = (Q/AREA)**2 / 64.309
      HF  =  ( 29.132*(CN**2)*DIST/(AREA/WP)**1.33333 )*VSQR2G
      HGL =  H0 + HF
      OTFULL = HGL - (PIPBOT + FRISE)
      HWOT = -1E38
C
      IF( OTFULL .LT. 0.0 ) GO TO 100
      HWOT = HGL + VSQR2G*(1.+CKE)
      VELIN = Q / AREA
      AIN = AREA
      GO TO 150
C
  100 CALL CULBWR ( TW, DSUBC, DSUBN, ISHAPE, DIMENS, SLOPE,
     $                      DIST, Q, CN, CKE, ALPHA, AREA, HWOT )
      HWOT = HWOT + PIPBOT
      IF( HWOT .LT. HWIN ) GO TO 150
      VELIN = Q / AREA
      AIN = AREA
C
  150 DEP =  AMIN1( FRISE,  AMAX1( TW, DSUBC )  )
      CALL  CULGOM ( DEP, ISHAPE,DIMENS, AREA, WP,T)
      VELOT = Q / AREA
      AOUT = AREA
C
  300 CONTINUE
C
      RETURN
      END
C                                     <<<<<SUBPROGRAM CULVIC>>>>>
C     <<<<<LAST REVISED ??-??-83>>>>>
C
      FUNCTION     CULVIC ( Q, I1, DIMENS, SLOPE, I5 )
C
C          INLET CONTROL CALCULATIONS
C
C     I5 =  ENTRANCE TYPE  =  EQUATION NO.
C     I1 =  SHAPE INDEX
C     DIMENS = DIMENSIONS IN INCHES
C     FSPAN,FRISE = FEET, SPAN AND RISE OF ARCH OR BOX.
C     FRISE = DIAM OF CIRCLE, FT.
C
C     FORTRAN CODING ADAPTED 9/82 BY WK.  FROM F.H.W.A. PROG  HY2, 1969.
C
      DIMENSION  DIMENS(2)
C
      DIMENSION PIPCOF(6,10),  BOXCOF(6,7),  ARCHCF(6,15)
C
      DATA  ARCHCF  /
     $  .16884,  .38783,  -.03679,  .01173,  -.00066,         2E-5,
     $  .13010,  .43477,  -.07911,  .01764,  -.00114,         2E-5,
     $  .09618,  .52593,  -.13504,  .03394,  -.00325,        13E-5,
     $  .089053, .712545, -.270921, .079250, -.00798048, .000293213,
     $  .12263,  .48250,  -.00002, -.04287,   .01454,      -117E-5,
     $  .14168,  .49323,  -.03235, -.02098,   .00989,       -86E-5,
     $  .09219,  .65732,  -.19432,  .04476,  -.00176,       -12E-5,
     $  .083301, .795145, -.434075, .163774, -.02491390, .001410660,
     $  .10620,  .70370,  -.35310,  .13740,  -.02076,       117E-5,
     $  .23645,  .37198,  -.04010,  .03058,  -.00576,        45E-5,
     $  .10212,  .72503,  -.34558,  .12454,  -.01676,        81E-5,
     $  .111281, .610579, -.194937, .051289, -.00480538, .000168547,
     $  .12346,  .50432,  -.13261,  .04020,  -.00448,        21E-5,
     $  .09728,  .57515,  -.15977,  .04223,  -.00374,        12E-5,
     $  .09455,  .61669,  -.22431,  .07407,  -.01002,        54E-5  /
C
      DATA  BOXCOF /
     $  .072492,  .50709,  -.11747,  .022170,  -.0014896,  38.013E-6,
     $  .122117,  .505435, -.108560, .0207809, -.00136757, 34.5642E-6,
     $  .122117,  .505435, -.108560, .0207809, -.00136757, 34.5642E-6,
     $  .144138,  .461363, -.092151, .0200028, -.00136449, 35.8431E-6,
     $  .156609,  .398935, -.064039, .0112014, -.0006449, 14.566E-6,
     $  .0895633, .4412465,-.0743498,.01273183,-.0007588, 17.74E-6,
     $  .0967588, .4551575,-.0812895,.01215577,-.00067794,14.8E-6 /
C
      DATA  PIPCOF /
     $  .108786,  .662381,  -.233801,  .0579585, -.00557890, .000205052,
     $  .114099,  .653562,  -.233615,  .0597723, -.00616338, .000242832,
     $  .167287,  .558766,  -.159813,  .0420069, -.00369252, .000125169,
     $  .087483,  .706578,  -.253295,  .0667001, -.00661651, .000250619,
     $  .120659,  .630768,  -.218423,  .0591815, -.00599169, .000229287,
     $  .063343,  .766512,  -.316097,  .0876701, -.00983695, .000416760,
     $  .081730,  .698353,  -.253683,  .0651250, -.00719750, .000312451,
     $  .187321,  .567710,  -.156544,  .0447052, -.00343602, .000089661,
     $  .107137,  .757789,  -.361462,  .1233932, -.01606422, .000767390,
     $  .167433,  .538595,  -.149374,  .0391543, -.00343974, .000115882/
C
C
      FRISE = DIMENS(1)/12.
      FSPAN = DIMENS(2)/12.
      IF (I1.EQ.2) FSPAN=FRISE
C
      X   = Q / ( FSPAN * SQRT(FRISE**3) )
      HWOVD = 1E38
C
      SCORR = 0.50
      IF( I1.EQ.1 .AND. I5.GE.5 )  SCORR = 0.0
      IF( I1.EQ.1 .AND. I5.EQ.6 )  SCORR = 0.20/SLOPE
      IF( I1.EQ.2 .AND. I5.EQ.9 )  SCORR = 0.0
C
      IF ( I1 .EQ. 1)  HWOVD = BOXCOF(1,I5)+(BOXCOF(2,I5)+(BOXCOF(3,I5)+
     $       (BOXCOF(4,I5)+(BOXCOF(5,I5)+BOXCOF(6,I5)*X)*X)*X)*X)*X
     $       -   SCORR*SLOPE
C
      IF ( I1 .EQ. 2) HWOVD = PIPCOF(1,I5)+(PIPCOF(2,I5)+(PIPCOF(3,I5)+
     $       (PIPCOF(4,I5)+(PIPCOF(5,I5)+PIPCOF(6,I5)*X)*X)*X)*X)*X
     $       - SCORR*SLOPE
C
      IF ( I1 .EQ. 3) HWOVD = ARCHCF(1,I5)+(ARCHCF(2,I5)+(ARCHCF(3,I5)+
     $       (ARCHCF(4,I5)+(ARCHCF(5,I5)+ARCHCF(6,I5)*X)*X)*X)*X)*X
     $       - SCORR*SLOPE
C
      CULVIC   = HWOVD * FRISE
      RETURN
      END
C                                     <<<<<SUBPROGRAM CULBWR>>>>>
C     <<<<<LAST REVISED 04-09-86>>>>>
C
      SUBROUTINE   CULBWR ( WTW, DSUBC, DSUBN, I1, DIMENS,
     $       SLOPE, DIST, QADJ, CNUSE, CKEUSE, ALPHA, AREA, WHW )
C
C          BACKWATER PROFILE ROUTINE
C
C     FORTRAN CODING ADAPTED 9/82 BY WK.  FROM F.H.W.A. PROG  HY2, 1969.
C
      DIMENSION  DIMENS(1)
      DIMENSION  V(2), SPH(2), HYDR(2)
C
C
      FRISE = DIMENS(1)/12.
      DEP = AMAX1 ( WTW, DSUBC )
C
      NSW6 = 0
      IF ( DEP .GT. DSUBN )  NSW6 = 1
C
      SUMX = 0.
      I     = 1
C
      IF ( DEP - FRISE ) 428 ,410,420
  410 IF ( NSW6 ) 428 ,490, 428
  420 DEP   = WTW - SLOPE * DIST
      IF ( DEP - DSUBN )425,425,476
  425 SUMX = (WTW-FRISE/(1.+SLOPE*SLOPE)**0.5)*(1.0+1.0/SLOPE/SLOPE)**.5
      DEP    = FRISE
  428 CONTINUE
      CALL CULGOM ( DEP,I1, DIMENS, AREA, WP, T)
      V(I)  = QADJ / AREA
      SPH(I)= DEP + ALPHA * V(I) * V(I) / 64.4
      HYDR(I) = AREA / WP
      IF ( I - 2 )431,450,450
  431 I     = I + 1
  435 IF ( NSW6 )480,440,445
  440 DEP   = DEP + 0.2
      IF ( DEP - FRISE ) 428 ,490,490
  445 DEP   = DEP - 0.2
      GO TO  428
  450 AVEV  = ( V(1) + V(2) ) * 0.5
      AVEHR = ( HYDR(1) + HYDR(2) ) * 0.5
C
C     COMPUTE SLOPE OF WATER SURFACE,S1
C
      S1    = CNUSE * CNUSE * AVEV * AVEV / 2.21 / AVEHR**1.33333
      IF ( NSW6 )452,451,452
  451 IF ( S1 - SLOPE )475,475,460
  452 IF ( SLOPE - S1 )475,475,461
  460 DX1   = ( SPH(2) - SPH(1) ) / ( S1 - SLOPE )
      GO TO 465
  461 DX1   = ( SPH(1) - SPH(2) ) / ( SLOPE - S1 )
C
C     ACCUMULATE LENGTH OF BACKWATER CURVE
C
  465 SUMX  = SUMX + DX1
      TEM473  =  SUMX - DIST*SQRT(1.-SLOPE**2)
      IF ( TEM473 )470,471,471
  470 V(1)  = V(2)
      SPH(1) = SPH(2)
      HYDR(1) = HYDR(2)
      GO TO 435
  471 IF ( NSW6 )473,472,473
  472 DEP   = DEP - ( TEM473 )/ DX1 * 0.2
      GO TO 476
  473 DEP   = DEP + ( TEM473 ) / DX1 * 0.2
      GO TO 476
  475 DEP   = DSUBN
  476 NSW6  = -1
      I     = 1
      GO TO  428
  480 WHW   = SPH(1) + CKEUSE * V(1) * V(1) / 64.4
  490 RETURN
C
      END
C                                     <<<<<SUBPROGRAM CULDEP>>>>>
C     <<<<<LAST REVISED ??-??-83>>>>>
C
      SUBROUTINE   CULDEP ( NSW10, QFACT, I1, DIMENS, DEP,
     $                                              AREA, WP, T )
C
C        ITERATIVE ROUTINE USED FOR CALCULATING
C        CRITICAL DEPTH,DSUBC, AND NORMAL DEPTH,DSUBN
C
C     DIMENS = CULVERT DIMENSIONS VECTOR
C     QFACT  = GIVEN VALUE OF DISCHARGE FCN.  THIS RTNE LOOKS
C               FOR DEP-VALUE TO MATCH THIS.
C     NSW10  = NORMAL-VS-CRITICAL FLOW COMP.
C
C     FORTRAN CODING ADAPTED 9/82 BY WK.  FROM F.H.W.A. PROG  HY2, 1969.
C
C            REVISED 9/82 TO RETURN CORRECT AREA,WP,T WHEN DEP = FRISE
C
      DIMENSION  DIMENS(6)
C
      FRISE = DIMENS(1)/12.
C
      DECRM = 0.2  * FRISE
      IF ( NSW10 )705,706,705
  705 CONTINUE
      TEMP  = QFACT
      DEP   = 0.90 * FRISE
      GO TO 707
  706 CONTINUE
      Q2OVG = QFACT
      DEP   = 0.98 * FRISE
  707 KOUNT = 0
  708 CONTINUE
      CALL CULGOM ( DEP,I1, DIMENS, AREA, WP, T)
  710 IF ( NSW10 )740,711,740
  711 TEMP  = AREA * AREA * AREA / T
      IF ( TEMP - Q2OVG )720,750,730
  720 IF ( KOUNT )721,750,721
  721 IF (DECRM  -    0.003 )760,760,722
  722 DEP   = DEP + DECRM
      DECRM = 0.2 * DECRM
  730 DEP   = DEP - DECRM
      KOUNT = KOUNT + 1
      GO TO  708
  740 AOVWP = AREA**1.66667 / WP**0.666667
      IF ( AOVWP - TEMP )720,760,730
  750 DEP   = FRISE
      CALL CULGOM ( DEP,I1, DIMENS,AREA,WP,T)
  760 RETURN
C
      END
C                                     <<<<<SUBPROGRAM CULGOM>>>>>
C     <<<<<LAST REVISED ??-??-83>>>>>
C
      SUBROUTINE   CULGOM ( DEP, I1, DIMENS, AREA, WP, T )
C
C        ROUTINE FOR CALCULATING AREA,WETTED PERIMETER, AND TOP SURFACE
C        WIDTH OF WATER FOR ANY DEPTH OF FLOW IN PIPE-ARCH CULVERTS
C
C     NOTE -- DIMENSIONS DIMENS MUST BE GIVEN IN  INCHES ,  DEP IN  FEET.
C
C     FORTRAN CODING ADAPTED 9/82 BY WK.  FROM F.H.W.A. PROG  HY2, 1969.
C
C     REVISED 9/82 TO HANDLE CIRCLES AND BOXES, TOO.  WK.
C
      DIMENSION  DIMENS(1)
C
C
      IF ( I1.EQ.1)  GO TO 1111
      IF ( I1.EQ.2)  GO TO 2222
      IF ( I1.EQ.3)  GO TO 3333
      STOP 413
C
 3333 CONTINUE
      RISEQQ = DIMENS(1)
      SPANQQ = DIMENS(2)
      BRQQ = DIMENS(3)
      TRQQ = DIMENS(4)
      CRQQ = DIMENS(5)
C
       Y3=DEP *12.0
      IF ( Y3 .LE. 0.     )  Y3 = 0.0001*RISEQQ
      IF ( Y3 .GT. RISEQQ )  Y3 =        RISEQQ
C
      SPHI1 = (SPANQQ/2.-CRQQ)/(BRQQ-CRQQ)
      CPHI1 = SQRT(1.-SPHI1**2)
C
      BDISQQ = CRQQ + (BRQQ-CRQQ)*(1.-CPHI1)
C
      TPHI2=(SPANQQ/2.-CRQQ)/(BDISQQ-(RISEQQ-TRQQ))
C
      PHI1=ATAN(SPHI1/CPHI1)
      PHI2=ATAN(TPHI2)
C
      Y1 = BRQQ-BRQQ*COS(PHI1)
      Y2 = BDISQQ +CRQQ*COS(PHI2)
      AREA3=0.
      AREA2=0.
      AREA1=0.
      WP1=0.
      WP2=0.
      WP3=0.
      TOP=0.0
      B1=2*BRQQ
      A1=0.
      AK1=1./(BRQQ*BRQQ)
      RAD1=SQRT(B1*B1)
      B2=2*BDISQQ
      A2= CRQQ*CRQQ-BDISQQ*BDISQQ
      AK2=1./CRQQ**2
      RAD2=SQRT(B2*B2-(4*A2*(-1.)))
      B3=2*(RISEQQ-TRQQ)
      A3=2*RISEQQ*TRQQ-RISEQQ*RISEQQ
      AK3=1./TRQQ**2
      RAD3=SQRT(B3*B3-(4*A3*(-1.)))
      IF(Y3.GT.Y2.OR.Y3.EQ.Y2)GO TO 325
      Y2=Y3
      IF(Y3.GT.Y1.OR.Y3.EQ.Y1)GO TO 345
      Y1=Y3
      IF(Y3.GT.0.0)GO TO 367
  325 X3=ABS(A3+B3*Y3-Y3*Y3)
      X33=A3+B3*Y2-Y2*Y2
  330 CALL MARQUE(3,Y3,Y2,B3,X3,X33,AK3,RAD3,
     $              XX1,ASUB1,XX2,ASUB2)
      AREA3=(ASUB1-ASUB2)/144.0*2.
      WP3 = 2.*TRQQ*(XX1-XX2)
  345 X2=A2+B2*Y2-Y2*Y2
      X22=A2+B2*Y1-Y1*Y1
      CALL MARQUE(2,Y2,Y1,B2,X2,X22,AK2,RAD2,
     $              XX1,ASUB1,XX2,ASUB2)
      ASUB3 = (SPANQQ/2.-CRQQ)* Y2-(SPANQQ/2.-CRQQ)*Y1
      AREA2= (ASUB1-ASUB2+ASUB3)/144.0*2.0
      WP2 = 2.*CRQQ*(XX1-XX2)
  367 X1=B1*Y1-Y1*Y1
      CALL MARQUE(1,Y1,0.,B1,X1,0.,AK1,RAD1,
     $              XX1,ASUB1,XX2,ASUB2)
      AREA1=(ASUB1-ASUB2)/144.0*2.
      WP1 = 2. *BRQQ*(XX1-XX2)
      AREA=AREA1+AREA2+AREA3
      WP  =(WP1+WP2+WP3)/12.0
      IF(Y3.GT.Y2) GO TO 110
      IF(Y3.GT.Y1) GO TO 13
      IF(Y3.GT.0.0) GO TO 15
  110 TOP=2*SQRT(X3)
      GO TO 19
  13  TOP=2*(SQRT (X2)+(SPANQQ/2.-CRQQ))
      GO TO 19
  15  TOP=2*SQRT(X1)
  19  T=TOP/12.0
      IF( T.LE.0. )  T = 1E-8
      RETURN
C
C
C            BOX SECTION
C
1111  CONTINUE
      D = AMAX1( 1E-12 ,AMIN1(DEP*12., DIMENS(1) ))
      AREA = DIMENS(2)*D/144.
      T=DIMENS(2)
      IF (D.GT.0.999*DIMENS(1)) T=1E-5+1000.*(1.-D/DIMENS(1))*T
      WP=DIMENS(2)+2.*D
      IF(D.GE.DIMENS(1)*0.999) WP=WP+DIMENS(2)-T
      WP=WP/12.
      T=T/12.
      RETURN
C
C            CIRCLE SECTION
C
2222  CONTINUE
      D=AMAX1(1E-5,AMIN1(DEP*12., DIMENS(1)))
      R=DIMENS(1)/2.
      PSI=ACOS(1.-D/R)
      SINPSI=SIN(PSI)
      T=2.*R*SINPSI
      WP=2.*PSI*R
      AREA = (R**2)*(PSI-(1.-D/R)*SINPSI)
      T=T/12.
      WP=WP/12.
      AREA=AREA/144.
      RETURN
C
      END
C                                     <<<<<SUBPROGRAM MARQUE>>>>>
C     <<<<<LAST REVISED ??-??-83>>>>>
C
      SUBROUTINE   MARQUE ( ICODE, UL, LL, BB, UX, LX, AK,
     $                              RAD, XX1, ASUB1, XX2, ASUB2 )
C
C     FORTRAN CODING ADAPTED 9/82 BY WK.  FROM F.H.W.A. PROG  HY2, 1969.
C
      REAL LL,LX
      XX1 = (2.*UL-BB)/RAD
      IF(ABS(XX1).LE.1.) GO TO 90
      XX1=SIGN(1.,XX1)
  90   CONTINUE
      XX1= ASIN(XX1)
      ASUB1=((( -2*UL+BB)*SQRT(UX))*(-.25))+1./(2*AK)*XX1
      XX2=(2.*LL-BB)/RAD
      IF(ABS(XX2).LE.1.) GO TO 99
      XX2=SIGN(1.  ,XX2)
  99   CONTINUE
      XX2= ASIN(XX2)
      ASUB2=((((-2)*LL+BB)*SQRT(LX))*(-.25))+1./(2*AK)*XX2
      RETURN
      END
C                                     <<<<<SUBPROGRAM CULPAD>>>>>
C     <<<<<LAST REVISED ??-??-83>>>>>
C
      SUBROUTINE   CULPAD ( JSHAPE, DIMENS )
C
C     CULPAD -- PIPE-ARCH DIMENSIONS -- APPROXIMATE
C
C        REGRESSION EQNS BASED ON DIMENSIONS TABULATED IN FHWA - CDS-4
C
C  PARAMETERS --
C     JSHAPE = SHAPE CODE -- 1 = CMP .LE. 18"CR,  2 = CMP-31",
C                 3 = CMP-47",  4 = ALUM. 31.8",   5 = R.C.P.
C     DIMENS = DIMENSIONS VECTOR --
C          1ST 2 ELEMENTS = RISE, SPAN  = INPUT.
C          DIMENS(3,4,5) = APPROX BOTTOM, TOP, CORNER RADII  =  OUTPUT.
C
      DIMENSION  DIMENS(5)
C
C
      RISE = DIMENS(1)
      SPAN = DIMENS(2)
      GO TO (10,20,30,40,50), JSHAPE
      STOP 513
C
10    CR = 18.
      IF (RISE.LT.55.) CR = 1.141+0.205*RISE
      TR = 0.594 + 0.498*SPAN
      BR = 7.00 - 2.036*RISE + 2.741*SPAN
      GO TO 99
20    CR = 31.
      TR = -0.346 + 0.505*SPAN
      BR = -956.6 + 29.39*RISE - 13.49*SPAN
      GO TO 99
30    CR = 47.
      TR = -3.27 + 0.521*SPAN
      BR =  -982.3  + 18.44*RISE  - 7.805*SPAN
      GO TO 99
40    CR = 31.8
      TR = -0.696 + 0.522*SPAN
      BR  =  363.3  - 9.639*RISE  +  5.398*SPAN
      GO TO 99
50    CR = 0.598 + 0.243*RISE
      TR = 1.21  +  0.499*SPAN
      BR  =  -60.13  + 2.106*SPAN  +  0.583*ABS(SPAN-95.)
      GO TO 99
C
99    DIMENS(3) = BR
      DIMENS(4) = TR
      DIMENS(5) = CR
      RETURN
      END
      SUBROUTINE XSMOD (XSORIG,XSADJ,XSPVEC,PVECTR,SHIFT,CDF)
C
C***   LAST REVISED 10-11-84
C
      COMMON / IPTCB1 / IPTXY,IPTRGH,IPTFL,IPTMSC,IPTPEA,IPTABG,IPTEND
      DIMENSION XSORIG(IPTEND),XSADJ(IPTEND),XSPVEC(40),PVECTR(40)
      NGP=XSORIG(1)
      YMIN=1E15
      DO 20 I=1,NGP
      K=IPTXY+2*I
      XSADJ(K-1)=XSORIG(K-1)
      XSADJ(K)=XSORIG(K)+SHIFT
      IF(XSORIG(K-1).LT.XSPVEC(13)) GO TO 5
      IF(XSORIG(K-1).GT.XSPVEC(14)) GO TO 5
      YMIN=AMIN1(YMIN,XSADJ(K))
    5 IF(K+1.GT.IPTXY+2*NGP) GO TO 20
      IF(XSORIG(K-1).GE.XSPVEC(13)) GO TO 10
      IF(XSORIG(K+1).LE.XSPVEC(13)) GO TO 10
      YINT=XSORIG(K)+(XSORIG(K+2)-XSORIG(K))*
     *       (XSPVEC(13)-XSORIG(K-1))/(XSORIG(K+1)-XSORIG(K-1))
      YMIN=AMIN1(YMIN,YINT+SHIFT)
   10 IF(XSORIG(K-1).GE.XSPVEC(14)) GO TO 20
      IF(XSORIG(K+1).LE.XSPVEC(14)) GO TO 20
      YINT=XSORIG(K)+(XSORIG(K+2)-XSORIG(K))*
     *       (XSPVEC(14)-XSORIG(K-1))/(XSORIG(K+1)-XSORIG(K-1))
      YMIN=AMIN1(YMIN,YINT+SHIFT)
   20 CONTINUE
      XSPVEC(12)=YMIN
      XSPVEC(10)=PVECTR(10)+SHIFT
      IF(CDF.LE.0.0) RETURN
      NSA=XSORIG(2)
      NBEG=IPTRGH+3*(IPTFL-IPTRGH)/5
      DO 30 I=1,NSA
      INV=NBEG+2*(I-1)
      XSADJ(INV+1)=XSORIG(INV+1)/CDF
      XSADJ(INV+2)=XSORIG(INV+2)/CDF
   30 CONTINUE
      RETURN
      END
C                                     <<<<<SUBPROGRAM XSPROP>>>>>
C     <<<<<LAST REVISED 05-02-86>>>>>
C
      SUBROUTINE   XSPROP (WS, XLT, XRT, NDXP, PVECTR, XSDATA)
C
C  THIS VERSION WRITTEN TO ACCESS THE LARGE X-SEC DATA BLOCK AND TO
C  PERMIT SUBDIVISION AND/OR SLICING VIA STATION VALUES AS OPPOSED TO
C  USING SUBAREA NUMBERS AND/OR COORDINATE PAIR NUMBERS.
C
      REAL K
      COMMON /SAPROP/ A,B,WP,K
      COMMON/IPTCB1/ IPTXY,IPTRGH,IPTFL,IPTMSC,JUNK(2),IPTEND
      DIMENSION A(20),B(20),WP(20),R(20),K(20),XSDATA(IPTEND),
     *      PVECTR(1),LIST1(5),LIST2(6)
      DATA LIST1/4,1,2,3,4/,LIST2/5,16,17,18,19,39/,DUMMY/1.0E30/
      DATA SUBPGM/222222./
C     WRITE(6,*)
C     WRITE(6,*) SUBPGM
C     WRITE(6,*)
      NGP=XSDATA(1)
      NSA=XSDATA(2)
      NRD=XSDATA(3)
      CSKEW=COS(PVECTR(15)/57.29578)
      XMAX = XSDATA(IPTXY+2*NGP+1)
      DO 5 I=1,NSA
      A(I)=0.0
      B(I)=0.0
      K(I)=0.0
      R(I)=0.0
    5 WP(I)=0.0
      SUMA=0.0
      SUMB=0.0
      SUMK=0.0
      SUMP=0.0
      ANUM=0.0
      BNUM=0.0
      XTNDED=0.0
      JLT=0
      I=1
      XYINT=1.0E30
      XYREW=-1.0E30
      XYLEW=1.0E30
      J=1
      IHOLD=0
      X1 = XLT - 999
   10 XSAJ=XSDATA(IPTRGH+J)
      IF(XLT.LT.XSAJ) GO TO 15
      IF(J.EQ.NSA) GO TO 15
      J=J+1
      GO TO 10
   15 XHOLD=XSAJ
      JRT=J
      IF(XRT.LT.XHOLD) XHOLD=XRT
   20 X0 = X1
      X1=XSDATA(IPTXY+2*I-1)
      Y1=XSDATA(IPTXY+2*I)
      X2=XSDATA(IPTXY+2*I+1)
      Y2=XSDATA(IPTXY+2*I+2)
C*********DEBUG OUTPUT
C*        ST=20.4
C*        WRITE(6,*) ST,I,X1,X2,XHOLD
      IF(X1.GE.XLT) GO TO 30
      IF(X2.GT.XLT) GO TO 25
      I=I+1
      IF((I+1).GT.NGP) GO TO 145
      GO TO 20
   25 Y1=Y2+(Y1-Y2)*(X2-XLT)/(X2-X1)
      X0 = X1
      X1=XLT
C*********DEBUG OUTPUT
C*        ST=25.2
C*        WRITE(6,*) ST,I,X1,X2,XHOLD
   30 IF( ABS( X1 - XRT ) .GT. 0.0005 ) GO TO 32
      IF( ABS( X2 - X1 ) .LT. 0.0005  .AND.
     $    ABS( XRT - XMAX ) .LT. 0.0005 ) GO TO 35
      IF( ABS( WS - Y1 ) .GT. 0.0005  .AND.
     $                         ABS( WS - Y2 ) .LT. 0.0 ) GO TO 33
   32 IF(X1.GE.XRT.AND.X2.GE.XRT) GO TO 105
C*********DEBUG OUTPUT
C*        ST=30.1
C*        WRITE(6,*) ST,I
   33 IF(X2.GT.X1) GO TO 35
      IF( X2 .GT. X0 ) GO TO 35
      IF(X1.LE.XLT.AND.X2.LE.XLT) GO TO 145
      IF(X2.GE.XHOLD) GO TO 45
      GO TO 40
   35 IF(X2.LE.XHOLD) GO TO 45
C*********DEBUG OUTPUT
C*        ST=35.1
C*        WRITE(6,*) ST,I
   40 Y2=Y1+(Y2-Y1)*(XHOLD-X1)/(X2-X1)
      X2=XHOLD
      IHOLD=1
C*********DEBUG OUTPUT
C*        ST=40.3
C*        WRITE(6,*) ST,I,X1,X2,XHOLD
      IF(X1.GE.XRT.AND.X2.GE.XRT) GO TO 105
   45 IF (WS.LE.Y1.AND.WS.LE.Y2) GO TO 90
C*********DEBUG OUTPUT
C*        ST=45.1
C*        WRITE(6,*) ST,I
      IF (WS.LT.Y1.OR.WS.LT.Y2) GO TO 50
C*********DEBUG OUTPUT
C*        ST=45.2
C*        WRITE(6,*) ST,I
      BASE=X2-X1
      XYINT=X2
      IF (XYLEW.GT.XYREW) XYINT=X1
      IF (I.EQ.1.AND.WS.GE.Y1) XYLEW=X1
      ALT=Y2-Y1
      BASE=BASE*CSKEW
      DELA=BASE*(WS-0.5*(Y1+Y2))
      GO TO 65
   50 IF (WS.GE.Y1.OR.WS.LE.Y2) GO TO 55
C*********DEBUG OUTPUT
C*        ST=50.1
C*        WRITE(6,*) ST,I
      ALT=WS-Y2
      BASE=ALT*(X2-X1)/(Y1-Y2)
      XYINT=X2-BASE
      IF(I.EQ.(NGP-1)) XYINT=X2
      GO TO 60
   55 ALT=WS-Y1
C*********DEBUG OUTPUT
C*        ST=55.1
C*        WRITE(6,*) ST,I
      BASE=ALT*(X2-X1)/(Y2-Y1)
      XYINT=X1+BASE
      IF(I.EQ.1) XYINT=X1
   60 BASE=BASE*CSKEW
      DELA=0.5*ALT*BASE
   65 DELWP=SQRT(BASE**2+ALT**2)
C*********DEBUG OUTPUT
C*        ST=65.1
C*        WRITE(6,*) ST,I
      B(J)=B(J)+BASE
      A(J)=A(J)+DELA
      IF(ABS(PVECTR(40)-2.).LT.0.5) GO TO 80
      IF(X1.NE.XSDATA(IPTXY+1)) GO TO 70
      IF(I.NE.1) GO TO 70
      IF(WS.LE.Y1) GO TO 80
      DELWP=DELWP+WS-Y1
      XTNDED=XTNDED+1.
      GO TO 80
   70 IF(X2.NE.XSDATA(IPTXY+2*NGP-1)) GO TO 80
      IF(I+1.NE.NGP) GO TO 80
      IF(WS.LE.Y2) GO TO 80
      DELWP=DELWP+WS-Y2
      XTNDED=XTNDED+2.
   80 WP(J)=WP(J)+DELWP
      GO TO 100
   90 IF (WS.NE.Y1.OR.WS.NE.Y2) GO TO 100
      TOP=X2-X1
      IF (TOP.GE.0) GO TO 100
      WP(J)=WP(J)-TOP
      B(J)=B(J)+TOP
  100 IF (XYINT.GT.1.0E25) GO TO 105
      IF (XYINT.LT.XYLEW) XYLEW=XYINT
      IF (XYINT.GT.XYREW) XYREW=XYINT
      IF(X1.EQ.XLT.AND.WS.GT.Y1) XYLEW=XLT
      IF(X2.EQ.XRT.AND.WS.GT.Y2) XYREW=XRT
  105 X0 = X1
      X1=X2
      Y1=Y2
C*********DEBUG OUTPUT
C*        ST=105.2
C*        WRITE(6,*) ST,I,X1,X2,XHOLD,A(J),WP(J)
      IF(IHOLD.EQ.0) GO TO 110
      IHOLD=0
      GO TO 115
  110 I=I+1
C*********DEBUG OUTPUT
C*        ST=110.1
C*        WRITE(6,*) ST,I,X1,X2,XHOLD,A(J),WP(J)
      IF((I+1).GT.NGP) GO TO 145
  115 X2=XSDATA(IPTXY+2*I+1)
      Y2=XSDATA(IPTXY+2*I+2)
C*********DEBUG OUTPUT
C*        ST=115.2
C*        WRITE(6,*) ST,I,X1,X2,XHOLD,A(J),WP(J)
      IF(X2.LT.X1) GO TO 120
      IF( X2 .LT. X0 ) GO TO 120
C*********DEBUG OUTPUT
C*        ST=115.3
C*        WRITE(6,*) ST,I
      IF(X1.LT.XHOLD) GO TO 30
C*********DEBUG OUTPUT
C*        ST=115.4
C*        WRITE(6,*) ST,I
      IF(X1.LT.XSAJ) GO TO 30
      IF( ABS( X1 - X2 ) .GT. 0.005 ) GO TO 116
      IF( ( Y1 - Y2 ) .LT. -0.005 ) GO TO 30
  116 CONTINUE
C*********DEBUG OUTPUT
C*        ST=116.1
C*        WRITE(6,*) ST,I
      J=J+1
      IF(J.GT.NSA) J=NSA
      JRT=J
      XSAJ=XSDATA(IPTRGH+JRT)
      XHOLD=XSAJ
      IF(XRT.LT.XHOLD) XHOLD=XRT
C*********DEBUG OUTPUT
C*        ST=116.2
C*        WRITE(6,*) ST,I,X1,X2,XHOLD
      GO TO 30
  120 IF(X1.GT.XRT) GO TO 30
C*********DEBUG OUTPUT
C*        ST=120.1
C*        WRITE(6,*) ST,I
      IF(JLT.EQ.0) JLT=JRT
      IF(X1.GT.XHOLD) GO TO 30
C*********DEBUG OUTPUT
C*        ST=120.2
C*        WRITE(6,*) ST,I
      IF(X1.GT.XSAJ) GO TO 30
      IF( ABS( X1 - X2 ) .GT. 0.005 ) GO TO 121
      IF( ( Y2 - Y1 ) .LT. -0.005 ) GO TO 30
  121 CONTINUE
C*********DEBUG OUTPUT
C*        ST=121.1
C*        WRITE(6,*) ST,I
      IF(J.GT.1) GO TO 125
C*********DEBUG OUTPUT
C*        ST=121.2
C*        WRITE(6,*) ST,I
      XHOLD=XLT
      GO TO 135
  125 IF(JLT.EQ.J) GO TO 130
      J=J-1
  130 JLT=J-1
      IF(JLT.LE.0) JLT=1
C*********DEBUG OUTPUT
C*        ST=125.1
C*        WRITE(6,*) ST,I
      XSAJ=XSDATA(IPTRGH+JLT)
      XHOLD=XSAJ
      IF(XHOLD.GT.XRT) XHOLD=XRT
  135 IF(X1.LE.XRT) GO TO 140
      IF(XRT.GT.XHOLD)  XHOLD=XRT
C*********DEBUG OUTPUT
C*        ST=135.2
C*        WRITE(6,*) ST,I
      GO TO 30
  140 IF(XLT.GT.XHOLD) XHOLD=XLT
C*********DEBUG OUTPUT
C*        ST=140.1
C*        WRITE(6,*) ST,I
      GO TO 30
  145 NFIFTH=(IPTFL-IPTRGH)/5
      DO 190 J=1,NSA
      IBD=IPTRGH+NFIFTH+2*(J-1)
      IBN=IBD+2*NFIFTH
      IF (B(J).LT.0.01) GO TO 155
      DEPTH=A(J)/B(J)
      IF(DEPTH.GT.XSDATA(IBD+1)) GO TO 150
      EN=XSDATA(IBN+1)
      GO TO 170
  150 IF (DEPTH.LT.XSDATA(IBD+2)) GO TO 160
  155 EN=XSDATA(IBN+2)
      GO TO 170
  160 EN=XSDATA(IBN+1)+(XSDATA(IBN+2)-XSDATA(IBN+1))*
     1        (DEPTH-XSDATA(IBD+1))/(XSDATA(IBD+2)-XSDATA(IBD+1))
  170 IF(WP(J).LE.0.0) GO TO 180
      R(J)=A(J)/WP(J)
      IF(R(J).LE.0.0) GO TO 180
      K(J)=(1.49/EN)*A(J)*R(J)**(2.0/3.0)
      SUMK=SUMK+K(J)
  180 SUMB=SUMB+B(J)
      IF(A(J).LE.0.0) GO TO 190
      SUMA=SUMA+A(J)
      BINC=K(J)*K(J)/A(J)
      AINC=BINC*K(J)/A(J)
      BNUM=BNUM+BINC
      ANUM=ANUM+AINC
      SUMP=SUMP+WP(J)
C*********DEBUG OUTPUT
C*        ST=180.8
C*        WRITE(6,*) ST,J,A(J),WP(J),K(J)
  190 CONTINUE
      ALPH=1.0
      BETA=1.0
      IF(SUMK.EQ.0.0) GO TO 200
      BDEN=SUMK*SUMK/SUMA
      ADEN=BDEN*SUMK/SUMA
      ALPH=ANUM/ADEN
      BETA=BNUM/BDEN
  200 DO 205 I=2,5
      LIST1(I)=NDXP+I-2
  205 CONTINUE
      CALL STORIT(PVECTR(1),LIST1,SUMK,SUMA,ALPH,BETA,DUMMY)
      CALL STORIT(PVECTR(1),LIST2,SUMP,SUMB,XYLEW,XYREW,XTNDED)
      RETURN
      END
